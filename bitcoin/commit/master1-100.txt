repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:011c39c2969420d7ca8b40fbf6f3364fe72da2d0
commit B:c9327306b580bb161d1732c0a0260b46c0df015c
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
    int64_t m_stale_tip_check_time; //! Next time to check for stale tip

identifier:int64_t,m_stale_tip_check_time,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    NOAUTH = 0x00,        //! No authentication required
    GSSAPI = 0x01,        //! GSSAPI
    USER_PASS = 0x02,     //! Username/password
    NO_ACCEPTABLE = 0xff, //! No acceptable methods
    SUCCEEDED = 0x00,        //! Succeeded
    GENFAILURE = 0x01,       //! General failure
    NOTALLOWED = 0x02,       //! Connection not allowed by ruleset
    NETUNREACHABLE = 0x03,   //! Network unreachable
    HOSTUNREACHABLE = 0x04,  //! Network unreachable
    CONNREFUSED = 0x05,      //! Connection refused
    TTLEXPIRED = 0x06,       //! TTL expired
    CMDUNSUPPORTED = 0x07,   //! Command not supported
    ATYPEUNSUPPORTED = 0x08, //! Address type not supported

identifier:NOAUTH,0x00,GSSAPI,0x01,USER_PASS,0x02,NO_ACCEPTABLE,0xff,SUCCEEDED,0x00,GENFAILURE,0x01,NOTALLOWED,0x02,NETUNREACHABLE,0x03,HOSTUNREACHABLE,0x04,CONNREFUSED,0x05,TTLEXPIRED,0x06,CMDUNSUPPORTED,0x07,ATYPEUNSUPPORTED,0x08,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
    UNSET,        //! Use default settings based on other criteria
    ECONOMICAL,   //! Force estimateSmartFee to use non-conservative estimates
    CONSERVATIVE, //! Force estimateSmartFee to use conservative estimates

identifier:UNSET,ECONOMICAL,CONSERVATIVE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.h
changed code snippet:
    CScriptWitness scriptWitness; //! Only serialized through CTransaction

identifier:CScriptWitness,scriptWitness,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/ismine.cpp
changed code snippet:
    TOP = 0,        //! scriptPubKey execution
    P2SH = 1,       //! P2SH redeemScript
    WITNESS_V0 = 2  //! P2WSH witness script execution
    NO = 0,          //! Not ours
    WATCH_ONLY = 1,  //! Included in watch-only balance
    SPENDABLE = 2,   //! Included in all balances
    INVALID = 3,     //! Not spendable by anyone (uncompressed pubkey in segwit, P2SH inside P2SH or witness, witness inside witness)

identifier:TOP,P2SH,WITNESS_V0,NO,WATCH_ONLY,SPENDABLE,INVALID,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    UNKNOWN = 0, //! Manually removed or unknown reason
    EXPIRY,      //! Expired from mempool
    SIZELIMIT,   //! Removed in size limiting
    REORG,       //! Removed for reorganization
    BLOCK,       //! Removed for block
    CONFLICT,    //! Removed for conflict with in-block transaction
    REPLACED     //! Removed for replacement

identifier:UNKNOWN,EXPIRY,SIZELIMIT,REORG,BLOCK,CONFLICT,REPLACED,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:0809e68a9084630ff4d11ec0503a3d0ab52bc6d7
commit B:430bf6c7a1a24a59050e7c9dac56b64b820edb43
++@DIFF ENTRY SEPERATOR@++
changed file:src/amount.h
changed code snippet:
static const CAmount CENT = 1000000;

identifier:CAmount,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/ccoins_caching.cpp
changed code snippet:
    dummyTransactions[0].vout[0].nValue = 11 * CENT;
    dummyTransactions[0].vout[1].nValue = 50 * CENT;
    dummyTransactions[1].vout[0].nValue = 21 * CENT;
    dummyTransactions[1].vout[1].nValue = 22 * CENT;
    t1.vout[0].nValue = 90 * CENT;
        assert(value == (50 + 21 + 22) * CENT);

identifier:dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,t1,vout,nValue,CENT,assert,value,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
    std::string strTxid = vStrInputParts[0];
    if ((strTxid.size() != 64) || !IsHex(strTxid))
    uint256 txid(uint256S(strTxid));
            uint256 txid = ParseHashStr(prevOut["txid"].get_str(), "txid");

identifier:strTxid,vStrInputParts,strTxid,size,IsHex,strTxid,uint256,txid,uint256S,strTxid,uint256,txid,ParseHashStr,prevOut,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_io.h
changed code snippet:
uint256 ParseHashStr(const std::string&, const std::string& strName);

identifier:uint256,ParseHashStr,strName,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_read.cpp
changed code snippet:
uint256 ParseHashStr(const std::string& strHex, const std::string& strName)
    if (!IsHex(strHex)) // Note: IsHex("") is false
        throw std::runtime_error(strName + " must be hexadecimal string (not '" + strHex + "')");
    uint256 result;
    return result;

identifier:uint256,ParseHashStr,strHex,strName,IsHex,strHex,throw,strName,uint256,result,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
        "-dbcrashratio", "-forcecompactdb", "-usehd",

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
        LOCK(cs_main);

        LOCK(cs_main);
        if (TipMayBeStale(consensusParams)) {

identifier:LOCK,cs_main,LOCK,cs_main,TipMayBeStale,consensusParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
    void EvictExtraOutboundPeers(int64_t time_in_seconds);

identifier:EvictExtraOutboundPeers,int64_t,time_in_seconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
static bool ParseHashStr(const std::string& strReq, uint256& v)
{
    if (!IsHex(strReq) || (strReq.size() != 64))
        return false;

    v.SetHex(strReq);
    return true;
}


identifier:ParseHashStr,strReq,uint256,v,IsHex,strReq,strReq,size,v,SetHex,strReq,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
        /*uint256 block_hash =*/ ParseHashStr(test[pos++].get_str(), "block_hash");
        uint256 prev_filter_header_basic = ParseHashStr(test[pos++].get_str(), "prev_filter_header_basic");
        uint256 filter_header_basic = ParseHashStr(test[pos++].get_str(), "filter_header_basic");

identifier:ParseHashStr,test,pos,get_str,uint256,prev_filter_header_basic,ParseHashStr,test,pos,get_str,uint256,filter_header_basic,ParseHashStr,test,pos,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilmoneystr.cpp
changed code snippet:
            int64_t nMult = CENT*10;

identifier:int64_t,nMult,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/coinselection.h
changed code snippet:
static const CAmount MIN_CHANGE = CENT;

identifier:CAmount,MIN_CHANGE,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        if (!gArgs.GetBoolArg("-usehd", true)) {
            InitError(strprintf(_("Error creating %s: You can't create non-HD wallets with this version."), walletFile));
            return nullptr;
        }
    } else if (gArgs.IsArgSet("-usehd")) {
        bool useHD = gArgs.GetBoolArg("-usehd", true);
        if (walletInstance->IsHDEnabled() && !useHD) {
            InitError(strprintf(_("Error loading %s: You can't disable HD on an already existing HD wallet"), walletFile));
            return nullptr;
        }
        if (!walletInstance->IsHDEnabled() && useHD) {
            InitError(strprintf(_("Error loading %s: You can't enable HD on an already existing non-HD wallet"), walletFile));
            return nullptr;
        }

identifier:gArgs,GetBoolArg,InitError,strprintf,_,walletFile,nullptr,walletInstance,IsHDEnabled,useHD,InitError,strprintf,_,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:430bf6c7a1a24a59050e7c9dac56b64b820edb43
commit B:af4b8a327a16fa03621d4fe161140d0a73707247
++@DIFF ENTRY SEPERATOR@++
changed file:src/amount.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/ccoins_caching.cpp
changed code snippet:
    dummyTransactions[0].vout[0].nValue = 11 * COIN;
    dummyTransactions[0].vout[1].nValue = 50 * COIN;
    dummyTransactions[1].vout[0].nValue = 21 * COIN;
    dummyTransactions[1].vout[1].nValue = 22 * COIN;
    t1.vout[0].nValue = 90 * COIN;
        assert(value == (50 + 21 + 22) * COIN);

identifier:dummyTransactions,vout,nValue,COIN,dummyTransactions,vout,nValue,COIN,dummyTransactions,vout,nValue,COIN,dummyTransactions,vout,nValue,COIN,t1,vout,nValue,COIN,assert,value,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
    uint256 txid;
    if (!ParseHashStr(vStrInputParts[0], txid)) {
    }
            uint256 txid;
            if (!ParseHashStr(prevOut["txid"].get_str(), txid)) {
                throw std::runtime_error("txid must be hexadecimal string (not '" + prevOut["txid"].get_str() + "')");
            }

identifier:uint256,txid,ParseHashStr,vStrInputParts,txid,uint256,txid,ParseHashStr,prevOut,get_str,txid,throw,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_io.h
changed code snippet:

/**
 * Parse a hex string into 256 bits
 * @param[in] strHex a hex-formatted, 64-character string
 * @param[out] result the result of the parasing
 * @returns true if successful, false if not
 *
 * @see ParseHashV for an RPC-oriented version of this
 */
bool ParseHashStr(const std::string& strHex, uint256& result);

identifier:ParseHashStr,strHex,uint256,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_read.cpp
changed code snippet:
bool ParseHashStr(const std::string& strHex, uint256& result)
    if ((strHex.size() != 64) || !IsHex(strHex))
        return false;
    return true;

identifier:ParseHashStr,strHex,uint256,result,strHex,size,IsHex,strHex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
        "-dbcrashratio", "-forcecompactdb",

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;
    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };
    bool m_use_addrman_outgoing;

identifier:m_use_addrman_outgoing,connOptions,m_use_addrman_outgoing,GetUseAddrmanOutgoing,m_use_addrman_outgoing,m_use_addrman_outgoing,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
    LOCK(cs_main);

        if (!fImporting && !fReindex && connman->GetNetworkActive() && connman->GetUseAddrmanOutgoing() && TipMayBeStale(consensusParams)) {

identifier:LOCK,cs_main,fImporting,fReindex,connman,GetNetworkActive,connman,GetUseAddrmanOutgoing,TipMayBeStale,consensusParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
#include <sync.h>

extern CCriticalSection cs_main;
    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);

identifier:include,sync,h,CCriticalSection,cs_main,EvictExtraOutboundPeers,int64_t,time_in_seconds,EXCLUSIVE_LOCKS_REQUIRED,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
        uint256 block_hash;
        BOOST_CHECK(ParseHashStr(test[pos++].get_str(), block_hash));
        uint256 prev_filter_header_basic;
        BOOST_CHECK(ParseHashStr(test[pos++].get_str(), prev_filter_header_basic));
        uint256 filter_header_basic;
        BOOST_CHECK(ParseHashStr(test[pos++].get_str(), filter_header_basic));

identifier:uint256,block_hash,BOOST_CHECK,ParseHashStr,test,pos,get_str,block_hash,uint256,prev_filter_header_basic,BOOST_CHECK,ParseHashStr,test,pos,get_str,prev_filter_header_basic,uint256,filter_header_basic,BOOST_CHECK,ParseHashStr,test,pos,get_str,filter_header_basic,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.h
changed code snippet:
static constexpr CAmount CENT{1000000};


identifier:constexpr,CAmount,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilmoneystr.cpp
changed code snippet:
            int64_t nMult = COIN / 10;

identifier:int64_t,nMult,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/coinselection.h
changed code snippet:
static constexpr CAmount MIN_CHANGE{COIN / 100};

identifier:constexpr,CAmount,MIN_CHANGE,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:134b42a409eca0171adbb1e5b49b32f1c13c3733
commit B:01211cea71016ceadfcbe98a8ec660a5071bd82e
++@DIFF ENTRY SEPERATOR@++
changed file:src/amount.h
changed code snippet:
static const CAmount CENT = 1000000;

identifier:CAmount,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/ccoins_caching.cpp
changed code snippet:
    dummyTransactions[0].vout[0].nValue = 11 * CENT;
    dummyTransactions[0].vout[1].nValue = 50 * CENT;
    dummyTransactions[1].vout[0].nValue = 21 * CENT;
    dummyTransactions[1].vout[1].nValue = 22 * CENT;
    t1.vout[0].nValue = 90 * CENT;
        assert(value == (50 + 21 + 22) * CENT);

identifier:dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,t1,vout,nValue,CENT,assert,value,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilmoneystr.cpp
changed code snippet:
            int64_t nMult = CENT*10;

identifier:int64_t,nMult,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/coinselection.h
changed code snippet:
static const CAmount MIN_CHANGE = CENT;

identifier:CAmount,MIN_CHANGE,CENT,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:01211cea71016ceadfcbe98a8ec660a5071bd82e
commit B:423cb37658b81b2cb8475b6fdb08b3122fee51a4
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
    std::string strTxid = vStrInputParts[0];
    if ((strTxid.size() != 64) || !IsHex(strTxid))
    uint256 txid(uint256S(strTxid));
            uint256 txid = ParseHashStr(prevOut["txid"].get_str(), "txid");

identifier:strTxid,vStrInputParts,strTxid,size,IsHex,strTxid,uint256,txid,uint256S,strTxid,uint256,txid,ParseHashStr,prevOut,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_io.h
changed code snippet:
uint256 ParseHashStr(const std::string&, const std::string& strName);

identifier:uint256,ParseHashStr,strName,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_read.cpp
changed code snippet:
uint256 ParseHashStr(const std::string& strHex, const std::string& strName)
    if (!IsHex(strHex)) // Note: IsHex("") is false
        throw std::runtime_error(strName + " must be hexadecimal string (not '" + strHex + "')");
    uint256 result;
    return result;

identifier:uint256,ParseHashStr,strHex,strName,IsHex,strHex,throw,strName,uint256,result,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
static bool ParseHashStr(const std::string& strReq, uint256& v)
{
    if (!IsHex(strReq) || (strReq.size() != 64))
        return false;

    v.SetHex(strReq);
    return true;
}


identifier:ParseHashStr,strReq,uint256,v,IsHex,strReq,strReq,size,v,SetHex,strReq,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
        /*uint256 block_hash =*/ ParseHashStr(test[pos++].get_str(), "block_hash");
        uint256 prev_filter_header_basic = ParseHashStr(test[pos++].get_str(), "prev_filter_header_basic");
        uint256 filter_header_basic = ParseHashStr(test[pos++].get_str(), "filter_header_basic");

identifier:ParseHashStr,test,pos,get_str,uint256,prev_filter_header_basic,ParseHashStr,test,pos,get_str,uint256,filter_header_basic,ParseHashStr,test,pos,get_str,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:423cb37658b81b2cb8475b6fdb08b3122fee51a4
commit B:b88dd7c2dbf8daca58306afd1744c4f88049b6df
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
        LOCK(cs_main);

        LOCK(cs_main);
        if (TipMayBeStale(consensusParams)) {

identifier:LOCK,cs_main,LOCK,cs_main,TipMayBeStale,consensusParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
    void EvictExtraOutboundPeers(int64_t time_in_seconds);

identifier:EvictExtraOutboundPeers,int64_t,time_in_seconds,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:edcf29c9da02c26ce8cae9bf2a68628c7543351e
commit B:e46023287689fc8e79b9a82fe1a827d87c769423
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    consensus.vDeployments[d].nStartTime = nStartTime;
    consensus.vDeployments[d].nTimeout = nTimeout;
}

    CRegTestParams() {
static std::unique_ptr<CChainParams> globalChainParams;
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams());

void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);
}

identifier:CChainParams::UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,CRegTestParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,globalChainParams,UpdateVersionBitsParameters,d,nStartTime,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);
/**
 * Allows modifying the Version Bits regtest parameters.
 */
void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);


identifier:UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,CChainParams,CreateChainParams,chain,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>

identifier:include,boost,filesystem,detail,utf8_codecvt_facet,hpp,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
        "-dbcrashratio", "-forcecompactdb", "-usehd",
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::DEBUG_TEST);
    if (gArgs.IsArgSet("-vbparams")) {
        // Allow overriding version bits parameters for testing
        if (!chainparams.MineBlocksOnDemand()) {
            return InitError("Version bits parameters may only be overridden on regtest.");
        }
        for (const std::string& strDeployment : gArgs.GetArgs("-vbparams")) {
            std::vector<std::string> vDeploymentParams;
            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
            if (vDeploymentParams.size() != 3) {
                return InitError("Version bits parameters malformed, expecting deployment:start:end");
            }
            int64_t nStartTime, nTimeout;
            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
                return InitError(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
            }
            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
                return InitError(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
            }
            bool found = false;
            for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)
            {
                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {
                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                    found = true;
                    LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                    break;
                }
            }
            if (!found) {
                return InitError(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
            }
        }
    }

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,IsArgSet,chainparams,MineBlocksOnDemand,InitError,strDeployment,gArgs,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,InitError,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,InitError,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,InitError,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,compare,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,InitError,strprintf,vDeploymentParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
static fs::detail::utf8_codecvt_facet utf8;

    return fs::path(path.toStdString(), utf8);
    return QString::fromStdString(path.string(utf8));

identifier:fs::detail::utf8_codecvt_facet,utf8,fs::path,path,toStdString,utf8,QString::fromStdString,path,utf8,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
    CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
    for (const CBlockIndex *pindex : headers) {
        ssHeader << pindex->GetBlockHeader();
    }

    CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssBlock << block;

    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    uint256 hash = uint256S(request.params[0].get_str());
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
        uint256 hash = uint256S(request.params[1].get_str());
        const std::string strHash = request.params[0].get_str();
        const uint256 hash(uint256S(strHash));

identifier:uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    uint256 hash = ParseHashStr(request.params[0].get_str(), "txid");
            hashWatchedChain.SetHex(lpstr.substr(0, 64));
static UniValue estimatefee(const JSONRPCRequest& request)
{
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "estimatefee was removed in v0.17.\n"
        "Clients should use estimatesmartfee.");
}

    { "hidden",             "estimatefee",            &estimatefee,            {} },

identifier:uint256,hash,ParseHashStr,request,params,get_str,hashWatchedChain,SetHex,lpstr,substr,UniValue,estimatefee,JSONRPCRequest,request,throw,JSONRPCError,RPC_METHOD_DEPRECATED,estimatefee,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))
            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string("Invalid txid ")+txid.get_str());
        uint256 hash(uint256S(txid.get_str()));
        hashBlock = uint256S(request.params[1].get_str());

identifier:txid,get_str,length,IsHex,txid,get_str,throw,JSONRPCError,RPC_INVALID_PARAMETER,txid,get_str,uint256,hash,uint256S,txid,get_str,hashBlock,uint256S,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex;
    if (v.isStr())
        strHex = v.get_str();
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d)", strName, 64, strHex.length()));
    uint256 result;
    result.SetHex(strHex);
    return result;

identifier:strHex,v,isStr,strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,uint256,result,result,SetHex,strHex,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);

identifier:UpdateVersionBitsParameters,Consensus::DEPLOYMENT_SEGWIT,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:
const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};


identifier:VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:
struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];


identifier:VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,hash,hash,SetHex,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId;
        blockId.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
        const std::string& txid = find_value(o, "txid").get_str();
        if (!IsHex(txid)) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, expected hex txid");
        }

        const COutPoint outpt(uint256S(txid), nOutput);
    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,blockId,blockId,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,txid,find_value,o,get_str,IsHex,txid,throw,JSONRPCError,RPC_INVALID_PARAMETER,COutPoint,outpt,uint256S,txid,nOutput,uint256,hash,hash,SetHex,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        if (!gArgs.GetBoolArg("-usehd", true)) {
            InitError(strprintf(_("Error creating %s: You can't create non-HD wallets with this version."), walletFile));
            return nullptr;
        }
    } else if (gArgs.IsArgSet("-usehd")) {
        bool useHD = gArgs.GetBoolArg("-usehd", true);
        if (walletInstance->IsHDEnabled() && !useHD) {
            InitError(strprintf(_("Error loading %s: You can't disable HD on an already existing HD wallet"), walletFile));
            return nullptr;
        }
        if (!walletInstance->IsHDEnabled() && useHD) {
            InitError(strprintf(_("Error loading %s: You can't enable HD on an already existing non-HD wallet"), walletFile));
            return nullptr;
        }

identifier:gArgs,GetBoolArg,InitError,strprintf,_,walletFile,nullptr,walletInstance,IsHDEnabled,useHD,InitError,strprintf,_,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:3a4449e9ad945313c6637283757de8d539cf790f
commit B:ae1cc010b88dd594d2a27b2717cfe14ef04ec852
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <versionbitsinfo.h>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>

    explicit CRegTestParams(const ArgsManager& args) {
        UpdateVersionBitsParametersFromArgs(args);


    /**
     * Allows modifying the Version Bits regtest parameters.
     */
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
    {
        consensus.vDeployments[d].nStartTime = nStartTime;
        consensus.vDeployments[d].nTimeout = nTimeout;
    }
    void UpdateVersionBitsParametersFromArgs(const ArgsManager& args);
void CRegTestParams::UpdateVersionBitsParametersFromArgs(const ArgsManager& args)
{
    if (!args.IsArgSet("-vbparams")) return;

    for (const std::string& strDeployment : args.GetArgs("-vbparams")) {
        std::vector<std::string> vDeploymentParams;
        boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
        if (vDeploymentParams.size() != 3) {
            throw std::runtime_error("Version bits parameters malformed, expecting deployment:start:end");
        }
        int64_t nStartTime, nTimeout;
        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
            throw std::runtime_error(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
        }
        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
            throw std::runtime_error(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
        }
        bool found = false;
        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {
                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                found = true;
                LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                break;
            }
        }
        if (!found) {
            throw std::runtime_error(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
        }
    }
}

static std::unique_ptr<const CChainParams> globalChainParams;
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams(gArgs));

identifier:include,versionbitsinfo,h,include,boost,algorithm,classification,hpp,include,boost,algorithm,split,hpp,explicit,CRegTestParams,ArgsManager,args,UpdateVersionBitsParametersFromArgs,args,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,UpdateVersionBitsParametersFromArgs,ArgsManager,args,CRegTestParams::UpdateVersionBitsParametersFromArgs,ArgsManager,args,args,IsArgSet,strDeployment,args,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,throw,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,throw,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,throw,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,throw,strprintf,vDeploymentParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,gArgs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain);

identifier:CChainParams,CreateChainParams,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::CHAINPARAMS);

identifier:gArgs,AddArg,OptionsCategory::CHAINPARAMS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
        "-dbcrashratio", "-forcecompactdb",

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
    return fs::path(path.toStdString());
    return QString::fromStdString(path.string());

identifier:fs::path,path,toStdString,QString::fromStdString,path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
        for (const CBlockIndex *pindex : headers) {
            ssHeader << pindex->GetBlockHeader();
        }

        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
        for (const CBlockIndex *pindex : headers) {
            ssHeader << pindex->GetBlockHeader();
        }

        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssBlock << block;
        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssBlock << block;
        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssTx << tx;

        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
#include <versionbitsinfo.h>
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "hash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
        uint256 hash(ParseHashV(request.params[1], "blockhash"));
        const uint256 hash(ParseHashV(request.params[0], "hash_or_height"));

identifier:include,versionbitsinfo,h,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
#include <versionbitsinfo.h>
    uint256 hash(ParseHashV(request.params[0], "txid"));
            hashWatchedChain = ParseHashV(lpstr.substr(0, 64), "longpollid");

identifier:include,versionbitsinfo,h,uint256,hash,ParseHashV,request,params,hashWatchedChain,ParseHashV,lpstr,substr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        uint256 hash(ParseHashV(txid, "txid"));
        hashBlock = ParseHashV(request.params[1], "blockhash");

identifier:uint256,hash,ParseHashV,txid,hashBlock,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex(v.get_str());
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d, for '%s')", strName, 64, strHex.length(), strHex));
    return uint256S(strHex);

identifier:strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,strHex,uint256S,strHex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
#include <consensus/params.h>
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    gArgs.ForceSetArg("-vbparams", strprintf("segwit:0:%d", (int64_t)Consensus::BIP9Deployment::NO_TIMEOUT));

identifier:include,consensus,params,h,gArgs,ForceSetArg,strprintf,int64_t,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#ifndef WIN32
#else
    fs::path::imbue(std::locale(loc, new std::codecvt_utf8_utf16<wchar_t>()));
#endif

identifier:ifndef,WIN32,fs::path::imbue,loc,new,wchar_t,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.cpp
changed code snippet:

#include <versionbitsinfo.h>

#include <consensus/params.h>

const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};

identifier:include,versionbitsinfo,h,include,consensus,params,h,VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.h
changed code snippet:

#ifndef BITCOIN_VERSIONBITSINFO_H
#define BITCOIN_VERSIONBITSINFO_H

struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];

#endif // BITCOIN_VERSIONBITSINFO_H

identifier:ifndef,BITCOIN_VERSIONBITSINFO_H,define,BITCOIN_VERSIONBITSINFO_H,VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash(ParseHashV(request.params[0], "txid"));

identifier:uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
        const uint256 txid(ParseHashO(o, "txid"));
        const COutPoint outpt(txid, nOutput);
    EnsureWalletIsUnlocked(pwallet);

    uint256 hash(ParseHashV(request.params[0], "txid"));

identifier:uint256,blockId,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,txid,ParseHashO,o,COutPoint,outpt,txid,nOutput,EnsureWalletIsUnlocked,pwallet,uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
                } else {
                    bnb_used = false;

identifier:bnb_used,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:ae1cc010b88dd594d2a27b2717cfe14ef04ec852
commit B:7ac911afe7aee0d3ac742a20d0091c0b75e4535e
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer(new benchmark::ConsolePrinter());

identifier:benchmark::Printer,printer,new,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    consensus.vDeployments[d].nStartTime = nStartTime;
    consensus.vDeployments[d].nTimeout = nTimeout;
}

    CRegTestParams() {
static std::unique_ptr<CChainParams> globalChainParams;
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams());

void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);
}

identifier:CChainParams::UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,CRegTestParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,globalChainParams,UpdateVersionBitsParameters,d,nStartTime,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);
/**
 * Allows modifying the Version Bits regtest parameters.
 */
void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);


identifier:UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,CChainParams,CreateChainParams,chain,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>

identifier:include,boost,filesystem,detail,utf8_codecvt_facet,hpp,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void(void)>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);
    std::function<void(void)> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::DEBUG_TEST);
static bool InitSanityCheck(void)
    if (gArgs.IsArgSet("-vbparams")) {
        // Allow overriding version bits parameters for testing
        if (!chainparams.MineBlocksOnDemand()) {
            return InitError("Version bits parameters may only be overridden on regtest.");
        }
        for (const std::string& strDeployment : gArgs.GetArgs("-vbparams")) {
            std::vector<std::string> vDeploymentParams;
            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
            if (vDeploymentParams.size() != 3) {
                return InitError("Version bits parameters malformed, expecting deployment:start:end");
            }
            int64_t nStartTime, nTimeout;
            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
                return InitError(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
            }
            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
                return InitError(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
            }
            bool found = false;
            for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)
            {
                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {
                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                    found = true;
                    LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                    break;
                }
            }
            if (!found) {
                return InitError(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
            }
        }
    }

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,InitSanityCheck,gArgs,IsArgSet,chainparams,MineBlocksOnDemand,InitError,strDeployment,gArgs,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,InitError,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,InitError,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,InitError,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,compare,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,InitError,strprintf,vDeploymentParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start(void);
void ECC_Stop(void);
bool ECC_InitSanityCheck(void);

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void(void)> >("std::function<void(void)>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
static fs::detail::utf8_codecvt_facet utf8;

    return fs::path(path.toStdString(), utf8);
    return QString::fromStdString(path.string(utf8));

identifier:fs::detail::utf8_codecvt_facet,utf8,fs::path,path,toStdString,utf8,QString::fromStdString,path,utf8,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport(void);

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):
    std::function<void(void)> func;
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
    CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
    for (const CBlockIndex *pindex : headers) {
        ssHeader << pindex->GetBlockHeader();
    }

    CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssBlock << block;

    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    uint256 hash = uint256S(request.params[0].get_str());
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
        uint256 hash = uint256S(request.params[1].get_str());
        const std::string strHash = request.params[0].get_str();
        const uint256 hash(uint256S(strHash));

identifier:uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    uint256 hash = ParseHashStr(request.params[0].get_str(), "txid");
            hashWatchedChain.SetHex(lpstr.substr(0, 64));
static UniValue estimatefee(const JSONRPCRequest& request)
{
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "estimatefee was removed in v0.17.\n"
        "Clients should use estimatesmartfee.");
}

    { "hidden",             "estimatefee",            &estimatefee,            {} },

identifier:uint256,hash,ParseHashStr,request,params,get_str,hashWatchedChain,SetHex,lpstr,substr,UniValue,estimatefee,JSONRPCRequest,request,throw,JSONRPCError,RPC_METHOD_DEPRECATED,estimatefee,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))
            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string("Invalid txid ")+txid.get_str());
        uint256 hash(uint256S(txid.get_str()));
        hashBlock = uint256S(request.params[1].get_str());

identifier:txid,get_str,length,IsHex,txid,get_str,throw,JSONRPCError,RPC_INVALID_PARAMETER,txid,get_str,uint256,hash,uint256S,txid,get_str,hashBlock,uint256S,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex;
    if (v.isStr())
        strHex = v.get_str();
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d)", strName, 64, strHex.length()));
    uint256 result;
    result.SetHex(strHex);
    return result;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)

identifier:strHex,v,isStr,strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,uint256,result,result,SetHex,strHex,result,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void (void)> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void(void)> Function;
    std::list<std::function<void (void)>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void (void)> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x(new TestLockedPageAllocator(3, 1));

identifier:LockedPageAllocator,x,new,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});

identifier:small_queue,Correct_Queue,new,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,queue,Unique_Queue,new,Unique_Queue,QUEUE_BATCH_SIZE,queue,Memory_Queue,new,Memory_Queue,QUEUE_BATCH_SIZE,queue,FrozenCleanup_Queue,new,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,Standard_Queue,new,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString(void) {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn));
    std::unique_ptr<CNode> pnode2(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn));

identifier:CNode,pnode1,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);

identifier:g_connman,CConnman,new,CConnman,0x1337,0x1337,UpdateVersionBitsParameters,Consensus::DEPLOYMENT_SEGWIT,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = std::unique_ptr<ECCVerifyHandle>(new ECCVerifyHandle());

identifier:globalVerifyHandle,ECCVerifyHandle,new,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority(void)

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority(void);

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
bool LoadMempool(void)
bool DumpMempool(void)

identifier:LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:
const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};


identifier:VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:
struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];


identifier:VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,hash,hash,SetHex,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId;
        blockId.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
        const std::string& txid = find_value(o, "txid").get_str();
        if (!IsHex(txid)) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, expected hex txid");
        }

        const COutPoint outpt(uint256S(txid), nOutput);
    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,blockId,blockId,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,txid,find_value,o,get_str,IsHex,txid,throw,JSONRPCError,RPC_INVALID_PARAMETER,COutPoint,outpt,uint256S,txid,nOutput,uint256,hash,hash,SetHex,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:7ac911afe7aee0d3ac742a20d0091c0b75e4535e
commit B:fa69ac761441af3e1195fbb4018b18233a4433d2
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer = MakeUnique<benchmark::ConsolePrinter>();

identifier:benchmark::Printer,printer,MakeUnique,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));

identifier:CWalletTx,wtx,MakeUnique,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <versionbitsinfo.h>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>

    explicit CRegTestParams(const ArgsManager& args) {
        UpdateVersionBitsParametersFromArgs(args);


    /**
     * Allows modifying the Version Bits regtest parameters.
     */
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
    {
        consensus.vDeployments[d].nStartTime = nStartTime;
        consensus.vDeployments[d].nTimeout = nTimeout;
    }
    void UpdateVersionBitsParametersFromArgs(const ArgsManager& args);
void CRegTestParams::UpdateVersionBitsParametersFromArgs(const ArgsManager& args)
{
    if (!args.IsArgSet("-vbparams")) return;

    for (const std::string& strDeployment : args.GetArgs("-vbparams")) {
        std::vector<std::string> vDeploymentParams;
        boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
        if (vDeploymentParams.size() != 3) {
            throw std::runtime_error("Version bits parameters malformed, expecting deployment:start:end");
        }
        int64_t nStartTime, nTimeout;
        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
            throw std::runtime_error(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
        }
        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
            throw std::runtime_error(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
        }
        bool found = false;
        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {
                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                found = true;
                LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                break;
            }
        }
        if (!found) {
            throw std::runtime_error(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
        }
    }
}

static std::unique_ptr<const CChainParams> globalChainParams;
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams(gArgs));

identifier:include,versionbitsinfo,h,include,boost,algorithm,classification,hpp,include,boost,algorithm,split,hpp,explicit,CRegTestParams,ArgsManager,args,UpdateVersionBitsParametersFromArgs,args,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,UpdateVersionBitsParametersFromArgs,ArgsManager,args,CRegTestParams::UpdateVersionBitsParametersFromArgs,ArgsManager,args,args,IsArgSet,strDeployment,args,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,throw,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,throw,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,throw,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,throw,strprintf,vDeploymentParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,gArgs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain);

identifier:CChainParams,CreateChainParams,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::CHAINPARAMS);

identifier:gArgs,AddArg,OptionsCategory::CHAINPARAMS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void()>& handler);
    std::function<void()> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
        "-dbcrashratio", "-forcecompactdb", "-usehd",
static bool InitSanityCheck()

identifier:InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start();
void ECC_Stop();
bool ECC_InitSanityCheck();

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
    int64_t m_stale_tip_check_time; //!< Next time to check for stale tip

identifier:int64_t,m_stale_tip_check_time,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    NOAUTH = 0x00,        //!< No authentication required
    GSSAPI = 0x01,        //!< GSSAPI
    USER_PASS = 0x02,     //!< Username/password
    NO_ACCEPTABLE = 0xff, //!< No acceptable methods
    SUCCEEDED = 0x00,        //!< Succeeded
    GENFAILURE = 0x01,       //!< General failure
    NOTALLOWED = 0x02,       //!< Connection not allowed by ruleset
    NETUNREACHABLE = 0x03,   //!< Network unreachable
    HOSTUNREACHABLE = 0x04,  //!< Network unreachable
    CONNREFUSED = 0x05,      //!< Connection refused
    TTLEXPIRED = 0x06,       //!< TTL expired
    CMDUNSUPPORTED = 0x07,   //!< Command not supported
    ATYPEUNSUPPORTED = 0x08, //!< Address type not supported

identifier:NOAUTH,0x00,GSSAPI,0x01,USER_PASS,0x02,NO_ACCEPTABLE,0xff,SUCCEEDED,0x00,GENFAILURE,0x01,NOTALLOWED,0x02,NETUNREACHABLE,0x03,HOSTUNREACHABLE,0x04,CONNREFUSED,0x05,TTLEXPIRED,0x06,CMDUNSUPPORTED,0x07,ATYPEUNSUPPORTED,0x08,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
    UNSET,        //!< Use default settings based on other criteria
    ECONOMICAL,   //!< Force estimateSmartFee to use non-conservative estimates
    CONSERVATIVE, //!< Force estimateSmartFee to use conservative estimates

identifier:UNSET,ECONOMICAL,CONSERVATIVE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.h
changed code snippet:
    CScriptWitness scriptWitness; //!< Only serialized through CTransaction

identifier:CScriptWitness,scriptWitness,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void()> >("std::function<void()>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
    return fs::path(path.toStdString());
    return QString::fromStdString(path.string());

identifier:fs::path,path,toStdString,QString::fromStdString,path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport();

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void()>& _func, int64_t millis):
    std::function<void()> func;
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
        for (const CBlockIndex *pindex : headers) {
            ssHeader << pindex->GetBlockHeader();
        }

        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
        for (const CBlockIndex *pindex : headers) {
            ssHeader << pindex->GetBlockHeader();
        }

        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssBlock << block;
        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssBlock << block;
        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssTx << tx;

        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
#include <versionbitsinfo.h>
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "hash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
        uint256 hash(ParseHashV(request.params[1], "blockhash"));
        const uint256 hash(ParseHashV(request.params[0], "hash_or_height"));

identifier:include,versionbitsinfo,h,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
#include <versionbitsinfo.h>
    uint256 hash(ParseHashV(request.params[0], "txid"));
            hashWatchedChain = ParseHashV(lpstr.substr(0, 64), "longpollid");

identifier:include,versionbitsinfo,h,uint256,hash,ParseHashV,request,params,hashWatchedChain,ParseHashV,lpstr,substr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        uint256 hash(ParseHashV(txid, "txid"));
        hashBlock = ParseHashV(request.params[1], "blockhash");

identifier:uint256,hash,ParseHashV,txid,hashBlock,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex(v.get_str());
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d, for '%s')", strName, 64, strHex.length(), strHex));
    return uint256S(strHex);
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds)

identifier:strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,strHex,uint256S,strHex,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void ()> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void ()> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void()> Function;
    std::list<std::function<void ()>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void ()> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/ismine.cpp
changed code snippet:
    TOP = 0,        //!< scriptPubKey execution
    P2SH = 1,       //!< P2SH redeemScript
    WITNESS_V0 = 2, //!< P2WSH witness script execution
    NO = 0,         //!< Not ours
    WATCH_ONLY = 1, //!< Included in watch-only balance
    SPENDABLE = 2,  //!< Included in all balances
    INVALID = 3,    //!< Not spendable by anyone (uncompressed pubkey in segwit, P2SH inside P2SH or witness, witness inside witness)

identifier:TOP,P2SH,WITNESS_V0,NO,WATCH_ONLY,SPENDABLE,INVALID,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x = MakeUnique<TestLockedPageAllocator>(3, 1);

identifier:LockedPageAllocator,x,MakeUnique,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = MakeUnique<Correct_Queue>(QUEUE_BATCH_SIZE);
    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);
    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Unique_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Memory_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<FrozenCleanup_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Standard_Queue>(QUEUE_BATCH_SIZE);

identifier:small_queue,MakeUnique,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,MakeUnique,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,MakeUnique,Failing_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Unique_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Memory_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString() {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1 = MakeUnique<CNode>(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn);
    std::unique_ptr<CNode> pnode2 = MakeUnique<CNode>(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn);

identifier:CNode,pnode1,MakeUnique,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,MakeUnique,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
#include <consensus/params.h>
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    gArgs.ForceSetArg("-vbparams", strprintf("segwit:0:%d", (int64_t)Consensus::BIP9Deployment::NO_TIMEOUT));
        g_connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.

identifier:include,consensus,params,h,gArgs,ForceSetArg,strprintf,int64_t,Consensus::BIP9Deployment::NO_TIMEOUT,g_connman,MakeUnique,CConnman,0x1337,0x1337,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = MakeUnique<ECCVerifyHandle>();

identifier:globalVerifyHandle,MakeUnique,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    UNKNOWN = 0, //!< Manually removed or unknown reason
    EXPIRY,      //!< Expired from mempool
    SIZELIMIT,   //!< Removed in size limiting
    REORG,       //!< Removed for reorganization
    BLOCK,       //!< Removed for block
    CONFLICT,    //!< Removed for conflict with in-block transaction
    REPLACED,    //!< Removed for replacement

identifier:UNKNOWN,EXPIRY,SIZELIMIT,REORG,BLOCK,CONFLICT,REPLACED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#ifndef WIN32
#else
    fs::path::imbue(std::locale(loc, new std::codecvt_utf8_utf16<wchar_t>()));
#endif
int ScheduleBatchPriority()

identifier:ifndef,WIN32,fs::path::imbue,loc,new,wchar_t,endif,ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority();

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
bool LoadMempool()
bool DumpMempool()

identifier:LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.cpp
changed code snippet:

#include <versionbitsinfo.h>

#include <consensus/params.h>

const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};

identifier:include,versionbitsinfo,h,include,consensus,params,h,VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.h
changed code snippet:

#ifndef BITCOIN_VERSIONBITSINFO_H
#define BITCOIN_VERSIONBITSINFO_H

struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];

#endif // BITCOIN_VERSIONBITSINFO_H

identifier:ifndef,BITCOIN_VERSIONBITSINFO_H,define,BITCOIN_VERSIONBITSINFO_H,VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash(ParseHashV(request.params[0], "txid"));

identifier:uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
        const uint256 txid(ParseHashO(o, "txid"));
        const COutPoint outpt(txid, nOutput);
    uint256 hash(ParseHashV(request.params[0], "txid"));

identifier:uint256,blockId,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,txid,ParseHashO,o,COutPoint,outpt,txid,nOutput,uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));

identifier:CWalletTx,wtx,MakeUnique,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
                } else {
                    bnb_used = false;
        if (!gArgs.GetBoolArg("-usehd", true)) {
            InitError(strprintf(_("Error creating %s: You can't create non-HD wallets with this version."), walletFile));
            return nullptr;
        }
    } else if (gArgs.IsArgSet("-usehd")) {
        bool useHD = gArgs.GetBoolArg("-usehd", true);
        if (walletInstance->IsHDEnabled() && !useHD) {
            InitError(strprintf(_("Error loading %s: You can't disable HD on an already existing HD wallet"), walletFile));
            return nullptr;
        }
        if (!walletInstance->IsHDEnabled() && useHD) {
            InitError(strprintf(_("Error loading %s: You can't enable HD on an already existing non-HD wallet"), walletFile));
            return nullptr;
        }

identifier:bnb_used,gArgs,GetBoolArg,InitError,strprintf,_,walletFile,nullptr,walletInstance,IsHDEnabled,useHD,InitError,strprintf,_,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fa69ac761441af3e1195fbb4018b18233a4433d2
commit B:d799efe21432ad55c41d5315f24c002bc8b3d119
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
    int64_t m_stale_tip_check_time; //! Next time to check for stale tip

identifier:int64_t,m_stale_tip_check_time,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    NOAUTH = 0x00,        //! No authentication required
    GSSAPI = 0x01,        //! GSSAPI
    USER_PASS = 0x02,     //! Username/password
    NO_ACCEPTABLE = 0xff, //! No acceptable methods
    SUCCEEDED = 0x00,        //! Succeeded
    GENFAILURE = 0x01,       //! General failure
    NOTALLOWED = 0x02,       //! Connection not allowed by ruleset
    NETUNREACHABLE = 0x03,   //! Network unreachable
    HOSTUNREACHABLE = 0x04,  //! Network unreachable
    CONNREFUSED = 0x05,      //! Connection refused
    TTLEXPIRED = 0x06,       //! TTL expired
    CMDUNSUPPORTED = 0x07,   //! Command not supported
    ATYPEUNSUPPORTED = 0x08, //! Address type not supported

identifier:NOAUTH,0x00,GSSAPI,0x01,USER_PASS,0x02,NO_ACCEPTABLE,0xff,SUCCEEDED,0x00,GENFAILURE,0x01,NOTALLOWED,0x02,NETUNREACHABLE,0x03,HOSTUNREACHABLE,0x04,CONNREFUSED,0x05,TTLEXPIRED,0x06,CMDUNSUPPORTED,0x07,ATYPEUNSUPPORTED,0x08,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
    UNSET,        //! Use default settings based on other criteria
    ECONOMICAL,   //! Force estimateSmartFee to use non-conservative estimates
    CONSERVATIVE, //! Force estimateSmartFee to use conservative estimates

identifier:UNSET,ECONOMICAL,CONSERVATIVE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.h
changed code snippet:
    CScriptWitness scriptWitness; //! Only serialized through CTransaction

identifier:CScriptWitness,scriptWitness,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/ismine.cpp
changed code snippet:
    TOP = 0,        //! scriptPubKey execution
    P2SH = 1,       //! P2SH redeemScript
    WITNESS_V0 = 2  //! P2WSH witness script execution
    NO = 0,          //! Not ours
    WATCH_ONLY = 1,  //! Included in watch-only balance
    SPENDABLE = 2,   //! Included in all balances
    INVALID = 3,     //! Not spendable by anyone (uncompressed pubkey in segwit, P2SH inside P2SH or witness, witness inside witness)

identifier:TOP,P2SH,WITNESS_V0,NO,WATCH_ONLY,SPENDABLE,INVALID,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    UNKNOWN = 0, //! Manually removed or unknown reason
    EXPIRY,      //! Expired from mempool
    SIZELIMIT,   //! Removed in size limiting
    REORG,       //! Removed for reorganization
    BLOCK,       //! Removed for block
    CONFLICT,    //! Removed for conflict with in-block transaction
    REPLACED     //! Removed for replacement

identifier:UNKNOWN,EXPIRY,SIZELIMIT,REORG,BLOCK,CONFLICT,REPLACED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    EnsureWalletIsUnlocked(pwallet);


identifier:EnsureWalletIsUnlocked,pwallet,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d799efe21432ad55c41d5315f24c002bc8b3d119
commit B:d813266db1f23f49465aa2aca3c3c80a95cf63d9
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d813266db1f23f49465aa2aca3c3c80a95cf63d9
commit B:c7b3e487f229142795a0b3ce6ce409ce7084d966
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>

identifier:include,boost,filesystem,detail,utf8_codecvt_facet,hpp,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
static fs::detail::utf8_codecvt_facet utf8;

    return fs::path(path.toStdString(), utf8);
    return QString::fromStdString(path.string(utf8));

identifier:fs::detail::utf8_codecvt_facet,utf8,fs::path,path,toStdString,utf8,QString::fromStdString,path,utf8,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:c7b3e487f229142795a0b3ce6ce409ce7084d966
commit B:cc7258bdfb44c5b5f3498296d8c9e6791655e89f
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
    return fs::path(path.toStdString());
    return QString::fromStdString(path.string());

identifier:fs::path,path,toStdString,QString::fromStdString,path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#ifndef WIN32
#else
    fs::path::imbue(std::locale(loc, new std::codecvt_utf8_utf16<wchar_t>()));
#endif

identifier:ifndef,WIN32,fs::path::imbue,loc,new,wchar_t,endif,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:cc7258bdfb44c5b5f3498296d8c9e6791655e89f
commit B:8efd87455bc957d6647c41680541d84e98e8353f
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>

identifier:include,boost,filesystem,detail,utf8_codecvt_facet,hpp,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
static fs::detail::utf8_codecvt_facet utf8;

    return fs::path(path.toStdString(), utf8);
    return QString::fromStdString(path.string(utf8));

identifier:fs::detail::utf8_codecvt_facet,utf8,fs::path,path,toStdString,utf8,QString::fromStdString,path,utf8,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:bb8c9b3f74344d1fda5cf62a2385c47f528742e9
commit B:9c5af58d51cea7d0cf2a598a9979eeba103b23ff
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
    uint256 txid;
    if (!ParseHashStr(vStrInputParts[0], txid)) {
    }
            uint256 txid;
            if (!ParseHashStr(prevOut["txid"].get_str(), txid)) {
                throw std::runtime_error("txid must be hexadecimal string (not '" + prevOut["txid"].get_str() + "')");
            }

identifier:uint256,txid,ParseHashStr,vStrInputParts,txid,uint256,txid,ParseHashStr,prevOut,get_str,txid,throw,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    consensus.vDeployments[d].nStartTime = nStartTime;
    consensus.vDeployments[d].nTimeout = nTimeout;
}

    CRegTestParams() {
static std::unique_ptr<CChainParams> globalChainParams;
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams());

void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);
}

identifier:CChainParams::UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,CRegTestParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,globalChainParams,UpdateVersionBitsParameters,d,nStartTime,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);
/**
 * Allows modifying the Version Bits regtest parameters.
 */
void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);


identifier:UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,CChainParams,CreateChainParams,chain,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_io.h
changed code snippet:

/**
 * Parse a hex string into 256 bits
 * @param[in] strHex a hex-formatted, 64-character string
 * @param[out] result the result of the parasing
 * @returns true if successful, false if not
 *
 * @see ParseHashV for an RPC-oriented version of this
 */
bool ParseHashStr(const std::string& strHex, uint256& result);

identifier:ParseHashStr,strHex,uint256,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_read.cpp
changed code snippet:
bool ParseHashStr(const std::string& strHex, uint256& result)
    if ((strHex.size() != 64) || !IsHex(strHex))
        return false;
    return true;

identifier:ParseHashStr,strHex,uint256,result,strHex,size,IsHex,strHex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::DEBUG_TEST);
    if (gArgs.IsArgSet("-vbparams")) {
        // Allow overriding version bits parameters for testing
        if (!chainparams.MineBlocksOnDemand()) {
            return InitError("Version bits parameters may only be overridden on regtest.");
        }
        for (const std::string& strDeployment : gArgs.GetArgs("-vbparams")) {
            std::vector<std::string> vDeploymentParams;
            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
            if (vDeploymentParams.size() != 3) {
                return InitError("Version bits parameters malformed, expecting deployment:start:end");
            }
            int64_t nStartTime, nTimeout;
            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
                return InitError(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
            }
            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
                return InitError(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
            }
            bool found = false;
            for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)
            {
                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {
                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                    found = true;
                    LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                    break;
                }
            }
            if (!found) {
                return InitError(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
            }
        }
    }

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,IsArgSet,chainparams,MineBlocksOnDemand,InitError,strDeployment,gArgs,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,InitError,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,InitError,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,InitError,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,compare,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,InitError,strprintf,vDeploymentParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
        uint256 block_hash;
        BOOST_CHECK(ParseHashStr(test[pos++].get_str(), block_hash));
        uint256 prev_filter_header_basic;
        BOOST_CHECK(ParseHashStr(test[pos++].get_str(), prev_filter_header_basic));
        uint256 filter_header_basic;
        BOOST_CHECK(ParseHashStr(test[pos++].get_str(), filter_header_basic));

identifier:uint256,block_hash,BOOST_CHECK,ParseHashStr,test,pos,get_str,block_hash,uint256,prev_filter_header_basic,BOOST_CHECK,ParseHashStr,test,pos,get_str,prev_filter_header_basic,uint256,filter_header_basic,BOOST_CHECK,ParseHashStr,test,pos,get_str,filter_header_basic,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);

identifier:UpdateVersionBitsParameters,Consensus::DEPLOYMENT_SEGWIT,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:
const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};


identifier:VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:
struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];


identifier:VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:9c5af58d51cea7d0cf2a598a9979eeba103b23ff
commit B:20442f617f7f86cbdde1c41c1165e2b750f756c7
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
    std::string strTxid = vStrInputParts[0];
    if ((strTxid.size() != 64) || !IsHex(strTxid))
    uint256 txid(uint256S(strTxid));
            uint256 txid = ParseHashStr(prevOut["txid"].get_str(), "txid");

identifier:strTxid,vStrInputParts,strTxid,size,IsHex,strTxid,uint256,txid,uint256S,strTxid,uint256,txid,ParseHashStr,prevOut,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_io.h
changed code snippet:
uint256 ParseHashStr(const std::string&, const std::string& strName);

identifier:uint256,ParseHashStr,strName,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_read.cpp
changed code snippet:
uint256 ParseHashStr(const std::string& strHex, const std::string& strName)
    if (!IsHex(strHex)) // Note: IsHex("") is false
        throw std::runtime_error(strName + " must be hexadecimal string (not '" + strHex + "')");
    uint256 result;
    return result;

identifier:uint256,ParseHashStr,strHex,strName,IsHex,strHex,throw,strName,uint256,result,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
static bool ParseHashStr(const std::string& strReq, uint256& v)
{
    if (!IsHex(strReq) || (strReq.size() != 64))
        return false;

    v.SetHex(strReq);
    return true;
}


identifier:ParseHashStr,strReq,uint256,v,IsHex,strReq,strReq,size,v,SetHex,strReq,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    uint256 hash = uint256S(request.params[0].get_str());
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
        uint256 hash = uint256S(request.params[1].get_str());
        const std::string strHash = request.params[0].get_str();
        const uint256 hash(uint256S(strHash));

identifier:uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    uint256 hash = ParseHashStr(request.params[0].get_str(), "txid");
            hashWatchedChain.SetHex(lpstr.substr(0, 64));

identifier:uint256,hash,ParseHashStr,request,params,get_str,hashWatchedChain,SetHex,lpstr,substr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))
            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string("Invalid txid ")+txid.get_str());
        uint256 hash(uint256S(txid.get_str()));
        hashBlock = uint256S(request.params[1].get_str());

identifier:txid,get_str,length,IsHex,txid,get_str,throw,JSONRPCError,RPC_INVALID_PARAMETER,txid,get_str,uint256,hash,uint256S,txid,get_str,hashBlock,uint256S,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex;
    if (v.isStr())
        strHex = v.get_str();
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d)", strName, 64, strHex.length()));
    uint256 result;
    result.SetHex(strHex);
    return result;

identifier:strHex,v,isStr,strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,uint256,result,result,SetHex,strHex,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
        /*uint256 block_hash =*/ ParseHashStr(test[pos++].get_str(), "block_hash");
        uint256 prev_filter_header_basic = ParseHashStr(test[pos++].get_str(), "prev_filter_header_basic");
        uint256 filter_header_basic = ParseHashStr(test[pos++].get_str(), "filter_header_basic");

identifier:ParseHashStr,test,pos,get_str,uint256,prev_filter_header_basic,ParseHashStr,test,pos,get_str,uint256,filter_header_basic,ParseHashStr,test,pos,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,hash,hash,SetHex,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId;
        blockId.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
        const std::string& txid = find_value(o, "txid").get_str();
        if (!IsHex(txid)) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, expected hex txid");
        }

        const COutPoint outpt(uint256S(txid), nOutput);
    EnsureWalletIsUnlocked(pwallet);

    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,blockId,blockId,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,txid,find_value,o,get_str,IsHex,txid,throw,JSONRPCError,RPC_INVALID_PARAMETER,COutPoint,outpt,uint256S,txid,nOutput,EnsureWalletIsUnlocked,pwallet,uint256,hash,hash,SetHex,request,params,get_str,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:20442f617f7f86cbdde1c41c1165e2b750f756c7
commit B:ff40357da10afd16b9efb06c4e6e8981fac8c239
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <versionbitsinfo.h>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>

    explicit CRegTestParams(const ArgsManager& args) {
        UpdateVersionBitsParametersFromArgs(args);


    /**
     * Allows modifying the Version Bits regtest parameters.
     */
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
    {
        consensus.vDeployments[d].nStartTime = nStartTime;
        consensus.vDeployments[d].nTimeout = nTimeout;
    }
    void UpdateVersionBitsParametersFromArgs(const ArgsManager& args);
void CRegTestParams::UpdateVersionBitsParametersFromArgs(const ArgsManager& args)
{
    if (!args.IsArgSet("-vbparams")) return;

    for (const std::string& strDeployment : args.GetArgs("-vbparams")) {
        std::vector<std::string> vDeploymentParams;
        boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
        if (vDeploymentParams.size() != 3) {
            throw std::runtime_error("Version bits parameters malformed, expecting deployment:start:end");
        }
        int64_t nStartTime, nTimeout;
        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
            throw std::runtime_error(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
        }
        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
            throw std::runtime_error(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
        }
        bool found = false;
        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {
                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                found = true;
                LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                break;
            }
        }
        if (!found) {
            throw std::runtime_error(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
        }
    }
}

static std::unique_ptr<const CChainParams> globalChainParams;
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams(gArgs));

identifier:include,versionbitsinfo,h,include,boost,algorithm,classification,hpp,include,boost,algorithm,split,hpp,explicit,CRegTestParams,ArgsManager,args,UpdateVersionBitsParametersFromArgs,args,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,UpdateVersionBitsParametersFromArgs,ArgsManager,args,CRegTestParams::UpdateVersionBitsParametersFromArgs,ArgsManager,args,args,IsArgSet,strDeployment,args,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,throw,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,throw,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,throw,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,throw,strprintf,vDeploymentParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,gArgs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain);

identifier:CChainParams,CreateChainParams,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::CHAINPARAMS);

identifier:gArgs,AddArg,OptionsCategory::CHAINPARAMS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
#include <versionbitsinfo.h>
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "hash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "blockhash"));
        uint256 hash(ParseHashV(request.params[1], "blockhash"));
        const uint256 hash(ParseHashV(request.params[0], "hash_or_height"));

identifier:include,versionbitsinfo,h,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
#include <versionbitsinfo.h>
    uint256 hash(ParseHashV(request.params[0], "txid"));
            hashWatchedChain = ParseHashV(lpstr.substr(0, 64), "longpollid");

identifier:include,versionbitsinfo,h,uint256,hash,ParseHashV,request,params,hashWatchedChain,ParseHashV,lpstr,substr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        uint256 hash(ParseHashV(txid, "txid"));
        hashBlock = ParseHashV(request.params[1], "blockhash");

identifier:uint256,hash,ParseHashV,txid,hashBlock,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex(v.get_str());
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d, for '%s')", strName, 64, strHex.length(), strHex));
    return uint256S(strHex);

identifier:strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,strHex,uint256S,strHex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
#include <consensus/params.h>
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    gArgs.ForceSetArg("-vbparams", strprintf("segwit:0:%d", (int64_t)Consensus::BIP9Deployment::NO_TIMEOUT));

identifier:include,consensus,params,h,gArgs,ForceSetArg,strprintf,int64_t,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.cpp
changed code snippet:

#include <versionbitsinfo.h>

#include <consensus/params.h>

const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};

identifier:include,versionbitsinfo,h,include,consensus,params,h,VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.h
changed code snippet:

#ifndef BITCOIN_VERSIONBITSINFO_H
#define BITCOIN_VERSIONBITSINFO_H

struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];

#endif // BITCOIN_VERSIONBITSINFO_H

identifier:ifndef,BITCOIN_VERSIONBITSINFO_H,define,BITCOIN_VERSIONBITSINFO_H,VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash(ParseHashV(request.params[0], "txid"));

identifier:uint256,hash,ParseHashV,request,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId(ParseHashV(request.params[0], "blockhash"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
    uint256 hash(ParseHashV(request.params[0], "txid"));
        const uint256 txid(ParseHashO(o, "txid"));
        const COutPoint outpt(txid, nOutput);
    uint256 hash(ParseHashV(request.params[0], "txid"));

identifier:uint256,blockId,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,hash,ParseHashV,request,params,uint256,txid,ParseHashO,o,COutPoint,outpt,txid,nOutput,uint256,hash,ParseHashV,request,params,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:4dac24db23d121ec21080f04e210227c4ff5d281
commit B:67654b64056e8b7e8312607d7275f73dbc9548ad
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    consensus.vDeployments[d].nStartTime = nStartTime;
    consensus.vDeployments[d].nTimeout = nTimeout;
}

    CRegTestParams() {
static std::unique_ptr<CChainParams> globalChainParams;
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams());

void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);
}

identifier:CChainParams::UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,CRegTestParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,globalChainParams,UpdateVersionBitsParameters,d,nStartTime,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);
/**
 * Allows modifying the Version Bits regtest parameters.
 */
void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);


identifier:UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,CChainParams,CreateChainParams,chain,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::DEBUG_TEST);
    if (gArgs.IsArgSet("-vbparams")) {
        // Allow overriding version bits parameters for testing
        if (!chainparams.MineBlocksOnDemand()) {
            return InitError("Version bits parameters may only be overridden on regtest.");
        }
        for (const std::string& strDeployment : gArgs.GetArgs("-vbparams")) {
            std::vector<std::string> vDeploymentParams;
            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
            if (vDeploymentParams.size() != 3) {
                return InitError("Version bits parameters malformed, expecting deployment:start:end");
            }
            int64_t nStartTime, nTimeout;
            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
                return InitError(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
            }
            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
                return InitError(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
            }
            bool found = false;
            for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)
            {
                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {
                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                    found = true;
                    LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                    break;
                }
            }
            if (!found) {
                return InitError(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
            }
        }
    }

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,IsArgSet,chainparams,MineBlocksOnDemand,InitError,strDeployment,gArgs,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,InitError,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,InitError,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,InitError,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,compare,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,InitError,strprintf,vDeploymentParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);

identifier:UpdateVersionBitsParameters,Consensus::DEPLOYMENT_SEGWIT,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:
const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};


identifier:VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:
struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];


identifier:VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:37612099ec7314b15a07d8bac55161ed4e8e7491
commit B:db15805668e923c3493d77122d20926496cf6a1a
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    uint256 hash = uint256S(request.params[0].get_str());
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
    std::string strHash = request.params[0].get_str();
    uint256 hash(uint256S(strHash));
        uint256 hash = uint256S(request.params[1].get_str());
        const std::string strHash = request.params[0].get_str();
        const uint256 hash(uint256S(strHash));

identifier:uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,strHash,request,params,get_str,uint256,hash,uint256S,strHash,uint256,hash,uint256S,request,params,get_str,strHash,request,params,get_str,uint256,hash,uint256S,strHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    uint256 hash = ParseHashStr(request.params[0].get_str(), "txid");
            hashWatchedChain.SetHex(lpstr.substr(0, 64));

identifier:uint256,hash,ParseHashStr,request,params,get_str,hashWatchedChain,SetHex,lpstr,substr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
        if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))
            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string("Invalid txid ")+txid.get_str());
        uint256 hash(uint256S(txid.get_str()));
        hashBlock = uint256S(request.params[1].get_str());

identifier:txid,get_str,length,IsHex,txid,get_str,throw,JSONRPCError,RPC_INVALID_PARAMETER,txid,get_str,uint256,hash,uint256S,txid,get_str,hashBlock,uint256S,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
    std::string strHex;
    if (v.isStr())
        strHex = v.get_str();
    if (64 != strHex.length())
        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("%s must be of length %d (not %d)", strName, 64, strHex.length()));
    uint256 result;
    result.SetHex(strHex);
    return result;

identifier:strHex,v,isStr,strHex,v,get_str,strHex,length,throw,JSONRPCError,RPC_INVALID_PARAMETER,strprintf,strName,strHex,length,uint256,result,result,SetHex,strHex,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,hash,hash,SetHex,request,params,get_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
        uint256 blockId;
        blockId.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
    uint256 hash;
    hash.SetHex(request.params[0].get_str());
        const std::string& txid = find_value(o, "txid").get_str();
        if (!IsHex(txid)) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, expected hex txid");
        }

        const COutPoint outpt(uint256S(txid), nOutput);
    EnsureWalletIsUnlocked(pwallet);

    uint256 hash;
    hash.SetHex(request.params[0].get_str());

identifier:uint256,blockId,blockId,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,uint256,hash,hash,SetHex,request,params,get_str,txid,find_value,o,get_str,IsHex,txid,throw,JSONRPCError,RPC_INVALID_PARAMETER,COutPoint,outpt,uint256S,txid,nOutput,EnsureWalletIsUnlocked,pwallet,uint256,hash,hash,SetHex,request,params,get_str,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:db15805668e923c3493d77122d20926496cf6a1a
commit B:985d28cc90eda7f637b47cda78e74099d3df8734
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:985d28cc90eda7f637b47cda78e74099d3df8734
commit B:f5035f9d0fae2ea35ef2ce32307b7ef8d455e10d
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
static UniValue estimatefee(const JSONRPCRequest& request)
{
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "estimatefee was removed in v0.17.\n"
        "Clients should use estimatesmartfee.");
}

    { "hidden",             "estimatefee",            &estimatefee,            {} },

identifier:UniValue,estimatefee,JSONRPCRequest,request,throw,JSONRPCError,RPC_METHOD_DEPRECATED,estimatefee,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:f5035f9d0fae2ea35ef2ce32307b7ef8d455e10d
commit B:e798ae41e0f0665243af4e31d4f8a731a139c390
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
    CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
    for (const CBlockIndex *pindex : headers) {
        ssHeader << pindex->GetBlockHeader();
    }

    CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssBlock << block;

    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e798ae41e0f0665243af4e31d4f8a731a139c390
commit B:1d0ce94a54be17b139a052b8e7b4605fe9ac1ecd
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:1d0ce94a54be17b139a052b8e7b4605fe9ac1ecd
commit B:6fa901fb4726ddac025d5396ecf09d047a8aa9a1
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <versionbitsinfo.h>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>

    explicit CRegTestParams(const ArgsManager& args) {
        UpdateVersionBitsParametersFromArgs(args);


    /**
     * Allows modifying the Version Bits regtest parameters.
     */
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
    {
        consensus.vDeployments[d].nStartTime = nStartTime;
        consensus.vDeployments[d].nTimeout = nTimeout;
    }
    void UpdateVersionBitsParametersFromArgs(const ArgsManager& args);
void CRegTestParams::UpdateVersionBitsParametersFromArgs(const ArgsManager& args)
{
    if (!args.IsArgSet("-vbparams")) return;

    for (const std::string& strDeployment : args.GetArgs("-vbparams")) {
        std::vector<std::string> vDeploymentParams;
        boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
        if (vDeploymentParams.size() != 3) {
            throw std::runtime_error("Version bits parameters malformed, expecting deployment:start:end");
        }
        int64_t nStartTime, nTimeout;
        if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
            throw std::runtime_error(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
        }
        if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
            throw std::runtime_error(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
        }
        bool found = false;
        for (int j=0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {
            if (vDeploymentParams[0] == VersionBitsDeploymentInfo[j].name) {
                UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                found = true;
                LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                break;
            }
        }
        if (!found) {
            throw std::runtime_error(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
        }
    }
}

static std::unique_ptr<const CChainParams> globalChainParams;
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams(gArgs));

identifier:include,versionbitsinfo,h,include,boost,algorithm,classification,hpp,include,boost,algorithm,split,hpp,explicit,CRegTestParams,ArgsManager,args,UpdateVersionBitsParametersFromArgs,args,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,UpdateVersionBitsParametersFromArgs,ArgsManager,args,CRegTestParams::UpdateVersionBitsParametersFromArgs,ArgsManager,args,args,IsArgSet,strDeployment,args,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,throw,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,throw,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,throw,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,throw,strprintf,vDeploymentParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,gArgs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
std::unique_ptr<const CChainParams> CreateChainParams(const std::string& chain);

identifier:CChainParams,CreateChainParams,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::CHAINPARAMS);

identifier:gArgs,AddArg,OptionsCategory::CHAINPARAMS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
#include <versionbitsinfo.h>

identifier:include,versionbitsinfo,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
#include <versionbitsinfo.h>

identifier:include,versionbitsinfo,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
#include <consensus/params.h>
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    gArgs.ForceSetArg("-vbparams", strprintf("segwit:0:%d", (int64_t)Consensus::BIP9Deployment::NO_TIMEOUT));

identifier:include,consensus,params,h,gArgs,ForceSetArg,strprintf,int64_t,Consensus::BIP9Deployment::NO_TIMEOUT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.cpp
changed code snippet:

#include <versionbitsinfo.h>

#include <consensus/params.h>

const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};

identifier:include,versionbitsinfo,h,include,consensus,params,h,VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbitsinfo.h
changed code snippet:

#ifndef BITCOIN_VERSIONBITSINFO_H
#define BITCOIN_VERSIONBITSINFO_H

struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];

#endif // BITCOIN_VERSIONBITSINFO_H

identifier:ifndef,BITCOIN_VERSIONBITSINFO_H,define,BITCOIN_VERSIONBITSINFO_H,VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,endif,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:6fa901fb4726ddac025d5396ecf09d047a8aa9a1
commit B:980b38f8a12130d2761d0f748db750165cfed025
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    consensus.vDeployments[d].nStartTime = nStartTime;
    consensus.vDeployments[d].nTimeout = nTimeout;
}

    CRegTestParams() {
static std::unique_ptr<CChainParams> globalChainParams;
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)
        return std::unique_ptr<CChainParams>(new CRegTestParams());

void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)
{
    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);
}

identifier:CChainParams::UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,consensus,vDeployments,d,nStartTime,nStartTime,consensus,vDeployments,d,nTimeout,nTimeout,CRegTestParams,CChainParams,globalChainParams,CChainParams,CreateChainParams,chain,CChainParams,new,CRegTestParams,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,globalChainParams,UpdateVersionBitsParameters,d,nStartTime,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.h
changed code snippet:
    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);
std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);
/**
 * Allows modifying the Version Bits regtest parameters.
 */
void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);


identifier:UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,CChainParams,CreateChainParams,chain,UpdateVersionBitsParameters,Consensus::DeploymentPos,d,int64_t,nStartTime,int64_t,nTimeout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparamsbase.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#include <versionbitsinfo.h>
    gArgs.AddArg("-vbparams=deployment:start:end", "Use given start/end times for specified version bits deployment (regtest-only)", true, OptionsCategory::DEBUG_TEST);
    if (gArgs.IsArgSet("-vbparams")) {
        // Allow overriding version bits parameters for testing
        if (!chainparams.MineBlocksOnDemand()) {
            return InitError("Version bits parameters may only be overridden on regtest.");
        }
        for (const std::string& strDeployment : gArgs.GetArgs("-vbparams")) {
            std::vector<std::string> vDeploymentParams;
            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(":"));
            if (vDeploymentParams.size() != 3) {
                return InitError("Version bits parameters malformed, expecting deployment:start:end");
            }
            int64_t nStartTime, nTimeout;
            if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {
                return InitError(strprintf("Invalid nStartTime (%s)", vDeploymentParams[1]));
            }
            if (!ParseInt64(vDeploymentParams[2], &nTimeout)) {
                return InitError(strprintf("Invalid nTimeout (%s)", vDeploymentParams[2]));
            }
            bool found = false;
            for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)
            {
                if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {
                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);
                    found = true;
                    LogPrintf("Setting version bits activation parameters for %s to start=%ld, timeout=%ld\n", vDeploymentParams[0], nStartTime, nTimeout);
                    break;
                }
            }
            if (!found) {
                return InitError(strprintf("Invalid deployment (%s)", vDeploymentParams[0]));
            }
        }
    }

identifier:include,versionbitsinfo,h,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,IsArgSet,chainparams,MineBlocksOnDemand,InitError,strDeployment,gArgs,GetArgs,vDeploymentParams,boost::split,vDeploymentParams,strDeployment,boost::is_any_of,vDeploymentParams,size,InitError,int64_t,nStartTime,nTimeout,ParseInt64,vDeploymentParams,nStartTime,InitError,strprintf,vDeploymentParams,ParseInt64,vDeploymentParams,nTimeout,InitError,strprintf,vDeploymentParams,found,j,j,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,j,vDeploymentParams,compare,VersionBitsDeploymentInfo,j,name,UpdateVersionBitsParameters,Consensus::DeploymentPos,j,nStartTime,nTimeout,found,LogPrintf,vDeploymentParams,nStartTime,nTimeout,found,InitError,strprintf,vDeploymentParams,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.
    // TODO: fix the code to support SegWit blocks.
    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);

identifier:UpdateVersionBitsParameters,Consensus::DEPLOYMENT_SEGWIT,Consensus::BIP9Deployment::NO_TIMEOUT,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:980b38f8a12130d2761d0f748db750165cfed025
commit B:ba923e32a0c03fcbb6ffe317580fd1d04669ce71
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.cpp
changed code snippet:
const struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_BITS_DEPLOYMENTS] = {
    {
        /*.name =*/ "testdummy",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "csv",
        /*.gbt_force =*/ true,
    },
    {
        /*.name =*/ "segwit",
        /*.gbt_force =*/ true,
    }
};


identifier:VBDeploymentInfo,VersionBitsDeploymentInfo,Consensus::MAX_VERSION_BITS_DEPLOYMENTS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/versionbits.h
changed code snippet:
struct VBDeploymentInfo {
    /** Deployment name */
    const char *name;
    /** Whether GBT clients can safely ignore this rule in simplified usage */
    bool gbt_force;
};

extern const struct VBDeploymentInfo VersionBitsDeploymentInfo[];


identifier:VBDeploymentInfo,name,gbt_force,VBDeploymentInfo,VersionBitsDeploymentInfo,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:ba923e32a0c03fcbb6ffe317580fd1d04669ce71
commit B:30973e9844d9ed8f2932ad7088cae39c49f3ebb5
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
        for (const CBlockIndex *pindex : headers) {
            ssHeader << pindex->GetBlockHeader();
        }

        CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
        for (const CBlockIndex *pindex : headers) {
            ssHeader << pindex->GetBlockHeader();
        }

        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssBlock << block;
        CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssBlock << block;
        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssTx << tx;

        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
        ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:30973e9844d9ed8f2932ad7088cae39c49f3ebb5
commit B:fae9e84cbb519d835d5a7a88b77ddb4ddd009e8a
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer(new benchmark::ConsolePrinter());

identifier:benchmark::Printer,printer,new,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false))
    {
        fprintf(stderr, "Error: SSL mode for RPC (-rpcssl) is no longer supported.\n");
        return EXIT_FAILURE;
    }

identifier:gArgs,GetBoolArg,fprintf,stderr,EXIT_FAILURE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false)) {
        uiInterface.ThreadSafeMessageBox(
            "SSL mode for RPC (-rpcssl) is no longer supported.",
            "", CClientUIInterface::MSG_ERROR);
        return false;
    }

HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void(void)>& _handler):

identifier:gArgs,GetBoolArg,uiInterface,ThreadSafeMessageBox,CClientUIInterface::MSG_ERROR,HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);
    std::function<void(void)> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-rpcssl", "-benchmark", "-h", "-help", "-socks", "-tor", "-debugnet", "-whitelistalwaysrelay",
        "-prematurewitness", "-walletprematurewitness", "-promiscuousmempoolflags", "-blockminsize", "-dbcrashratio", "-forcecompactdb", "-usehd",
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is (0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
static bool InitSanityCheck(void)
    // Check for -debugnet
    if (gArgs.GetBoolArg("-debugnet", false))
        InitWarning(_("Unsupported argument -debugnet ignored, use -debug=net."));
    // Check for -socks - as this is a privacy risk to continue, exit here
    if (gArgs.IsArgSet("-socks"))
        return InitError(_("Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported."));
    // Check for -tor - as this is a privacy risk to continue, exit here
    if (gArgs.GetBoolArg("-tor", false))
        return InitError(_("Unsupported argument -tor found, use -onion."));

    if (gArgs.GetBoolArg("-benchmark", false))
        InitWarning(_("Unsupported argument -benchmark ignored, use -debug=bench."));

    if (gArgs.GetBoolArg("-whitelistalwaysrelay", false))
        InitWarning(_("Unsupported argument -whitelistalwaysrelay ignored, use -whitelistrelay and/or -whitelistforcerelay."));

    if (gArgs.IsArgSet("-blockminsize"))
        InitWarning("Unsupported argument -blockminsize ignored.");


identifier:hidden_args,gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,InitSanityCheck,gArgs,GetBoolArg,InitWarning,_,gArgs,IsArgSet,InitError,_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start(void);
void ECC_Stop(void);
bool ECC_InitSanityCheck(void);

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("%1 will close now to finish the encryption process. "
                                         "your bitcoins from being stolen by malware infecting your computer.").arg(tr(PACKAGE_NAME)) +
                    QApplication::quit();

identifier:tr,arg,tr,PACKAGE_NAME,QApplication::quit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void(void)> >("std::function<void(void)>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport(void);

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):
    std::function<void(void)> func;
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
    CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);
    for (const CBlockIndex *pindex : headers) {
        ssHeader << pindex->GetBlockHeader();
    }

    CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssBlock << block;

    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());
    ssTx << tx;


identifier:CDataStream,ssHeader,SER_NETWORK,PROTOCOL_VERSION,CBlockIndex,pindex,headers,ssHeader,pindex,GetBlockHeader,CDataStream,ssBlock,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssBlock,block,CDataStream,ssTx,SER_NETWORK,PROTOCOL_VERSION,RPCSerializationFlags,ssTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void (void)> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void(void)> Function;
    std::list<std::function<void (void)>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void (void)> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x(new TestLockedPageAllocator(3, 1));

identifier:LockedPageAllocator,x,new,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});

identifier:small_queue,Correct_Queue,new,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,queue,Unique_Queue,new,Unique_Queue,QUEUE_BATCH_SIZE,queue,Memory_Queue,new,Memory_Queue,QUEUE_BATCH_SIZE,queue,FrozenCleanup_Queue,new,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,Standard_Queue,new,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString(void) {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn));
    std::unique_ptr<CNode> pnode2(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn));

identifier:CNode,pnode1,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.

identifier:g_connman,CConnman,new,CConnman,0x1337,0x1337,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = std::unique_ptr<ECCVerifyHandle>(new ECCVerifyHandle());

identifier:globalVerifyHandle,ECCVerifyHandle,new,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority(void)

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority(void);

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, false))
bool LoadMempool(void)
bool DumpMempool(void)

identifier:CheckTransaction,tx,state,LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                g_dbenvs.erase(strPath);
        if (shutdown) env = nullptr;

identifier:g_dbenvs,erase,strPath,shutdown,env,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
            "Note that this will shutdown the server.\n"
    // BDB seems to have a bad habit of writing old data into
    // slack space in .dat files; that is bad if the old data is
    // unencrypted private keys. So:
    StartShutdown();
    return "wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:StartShutdown,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    pcontext = zmq_init(1);
        zmq_ctx_destroy(pcontext);

identifier:pcontext,zmq_init,zmq_ctx_destroy,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fae9e84cbb519d835d5a7a88b77ddb4ddd009e8a
commit B:1eb9a9b524a82157e65180e85a832bd721388459
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer = MakeUnique<benchmark::ConsolePrinter>();

identifier:benchmark::Printer,printer,MakeUnique,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));

identifier:CWalletTx,wtx,MakeUnique,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void()>& handler);
    std::function<void()> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-h", "-help",
        "-dbcrashratio", "-forcecompactdb", "-usehd",
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is: "
        "level 0 reads the blocks from disk, "
        "level 1 verifies block validity, "
        "level 2 verifies undo data, "
        "level 3 checks disconnection of tip blocks, "
        "and level 4 tries to reconnect the blocks, "
        "each level includes the checks of the previous levels "
        "(0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
static bool InitSanityCheck()

identifier:hidden_args,gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start();
void ECC_Stop();
bool ECC_InitSanityCheck();

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("Your wallet is now encrypted. "
                                         "your bitcoins from being stolen by malware infecting your computer.") +

identifier:tr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void()> >("std::function<void()>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport();

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void()>& _func, int64_t millis):
    std::function<void()> func;
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:
    { "getnodeaddresses", 0, "count"},

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
static UniValue getnodeaddresses(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() > 1) {
        throw std::runtime_error(
            "getnodeaddresses ( count )\n"
            "\nReturn known addresses which can potentially be used to find new nodes in the network\n"
            "\nArguments:\n"
            "1. \"count\"    (numeric, optional) How many addresses to return. Limited to the smaller of " + std::to_string(ADDRMAN_GETADDR_MAX) +
                " or " + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + "% of all known addresses. (default = 1)\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"time\": ttt,                (numeric) Timestamp in seconds since epoch (Jan 1 1970 GMT) keeping track of when the node was last seen\n"
            "    \"services\": n,              (numeric) The services offered\n"
            "    \"address\": \"host\",          (string) The address of the node\n"
            "    \"port\": n                   (numeric) The port of the node\n"
            "  }\n"
            "  ,....\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getnodeaddresses", "8")
            + HelpExampleRpc("getnodeaddresses", "8")
        );
    }
    if (!g_connman) {
        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, "Error: Peer-to-peer functionality missing or disabled");
    }

    int count = 1;
    if (!request.params[0].isNull()) {
        count = request.params[0].get_int();
        if (count <= 0) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Address count out of range");
        }
    }
    // returns a shuffled list of CAddress
    std::vector<CAddress> vAddr = g_connman->GetAddresses();
    UniValue ret(UniValue::VARR);

    int address_return_count = std::min<int>(count, vAddr.size());
    for (int i = 0; i < address_return_count; ++i) {
        UniValue obj(UniValue::VOBJ);
        const CAddress& addr = vAddr[i];
        obj.pushKV("time", (int)addr.nTime);
        obj.pushKV("services", (uint64_t)addr.nServices);
        obj.pushKV("address", addr.ToStringIP());
        obj.pushKV("port", addr.GetPort());
        ret.push_back(obj);
    }
    return ret;
}

    { "network",            "getnodeaddresses",       &getnodeaddresses,       {"count"} },

identifier:UniValue,getnodeaddresses,JSONRPCRequest,request,request,fHelp,request,params,size,throw,ADDRMAN_GETADDR_MAX,ADDRMAN_GETADDR_MAX_PCT,HelpExampleCli,HelpExampleRpc,g_connman,throw,JSONRPCError,RPC_CLIENT_P2P_DISABLED,count,request,params,isNull,count,request,params,get_int,count,throw,JSONRPCError,RPC_INVALID_PARAMETER,CAddress,vAddr,g_connman,GetAddresses,UniValue,ret,UniValue::VARR,address_return_count,count,vAddr,size,i,i,address_return_count,i,UniValue,obj,UniValue::VOBJ,CAddress,addr,vAddr,i,obj,pushKV,addr,nTime,obj,pushKV,uint64_t,addr,nServices,obj,pushKV,addr,ToStringIP,obj,pushKV,addr,GetPort,ret,push_back,obj,ret,getnodeaddresses,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void ()> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void ()> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void()> Function;
    std::list<std::function<void ()>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void ()> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x = MakeUnique<TestLockedPageAllocator>(3, 1);

identifier:LockedPageAllocator,x,MakeUnique,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = MakeUnique<Correct_Queue>(QUEUE_BATCH_SIZE);
    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);
    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Unique_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Memory_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<FrozenCleanup_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Standard_Queue>(QUEUE_BATCH_SIZE);

identifier:small_queue,MakeUnique,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,MakeUnique,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,MakeUnique,Failing_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Unique_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Memory_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString() {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1 = MakeUnique<CNode>(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn);
    std::unique_ptr<CNode> pnode2 = MakeUnique<CNode>(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn);

identifier:CNode,pnode1,MakeUnique,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,MakeUnique,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
        g_connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.

identifier:g_connman,MakeUnique,CConnman,0x1337,0x1337,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = MakeUnique<ECCVerifyHandle>();

identifier:globalVerifyHandle,MakeUnique,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority()

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority();

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, true))
bool LoadMempool()
bool DumpMempool()

identifier:CheckTransaction,tx,state,LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = COIN / 10;
static const CAmount HIGH_TX_FEE_PER_KB = COIN / 100;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    env->m_db_in_use.notify_all();
void BerkeleyEnvironment::ReloadDbEnv()
{
    // Make sure that no Db's are in use
    AssertLockNotHeld(cs_db);
    std::unique_lock<CCriticalSection> lock(cs_db);
    m_db_in_use.wait(lock, [this](){
        for (auto& count : mapFileUseCount) {
            if (count.second > 0) return false;
        }
        return true;
    });

    std::vector<std::string> filenames;
    for (auto it : mapDb) {
        filenames.push_back(it.first);
    }
    // Close the individual Db's
    for (const std::string& filename : filenames) {
        CloseDb(filename);
    }
    // Reset the environment
    Flush(true); // This will flush and close the environment
    Reset();
    Open(true);
}

        if (shutdown) {
            LOCK(cs_db);
            g_dbenvs.erase(env->Directory().string());
            env = nullptr;
        }
    }
}

void BerkeleyDatabase::ReloadDbEnv()
{
    if (!IsDummy()) {
        env->ReloadDbEnv();

identifier:env,m_db_in_use,notify_all,BerkeleyEnvironment::ReloadDbEnv,AssertLockNotHeld,cs_db,CCriticalSection,lock,cs_db,m_db_in_use,wait,lock,this,count,mapFileUseCount,count,second,filenames,it,mapDb,filenames,push_back,it,first,filename,filenames,CloseDb,filename,Flush,Reset,Open,shutdown,LOCK,cs_db,g_dbenvs,erase,env,Directory,env,nullptr,BerkeleyDatabase::ReloadDbEnv,IsDummy,env,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:
    std::condition_variable_any m_db_in_use;
    void ReloadDbEnv();
    void ReloadDbEnv();


identifier:m_db_in_use,ReloadDbEnv,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    return "wallet encrypted; The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));

identifier:CWalletTx,wtx,MakeUnique,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        // BDB seems to have a bad habit of writing old data into
        // slack space in .dat files; that is bad if the old data is
        // unencrypted private keys. So:
        database->ReloadDbEnv();


identifier:database,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    int major = 0, minor = 0, patch = 0;
    zmq_version(&major, &minor, &patch);
    LogPrint(BCLog::ZMQ, "zmq: version %d.%d.%d\n", major, minor, patch);

    pcontext = zmq_ctx_new();
        zmq_ctx_term(pcontext);

identifier:major,minor,patch,zmq_version,major,minor,patch,LogPrint,BCLog::ZMQ,major,minor,patch,pcontext,zmq_ctx_new,zmq_ctx_term,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:1eb9a9b524a82157e65180e85a832bd721388459
commit B:2c3eade704f63b360926de9e975ce80143781679
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
    return fs::path(path.toStdString());
    return QString::fromStdString(path.string());

identifier:fs::path,path,toStdString,QString::fromStdString,path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
static UniValue estimatefee(const JSONRPCRequest& request)
{
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "estimatefee was removed in v0.17.\n"
        "Clients should use estimatesmartfee.");
}

    { "hidden",             "estimatefee",            &estimatefee,            {} },

identifier:UniValue,estimatefee,JSONRPCRequest,request,throw,JSONRPCError,RPC_METHOD_DEPRECATED,estimatefee,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#ifndef WIN32
#else
    fs::path::imbue(std::locale(loc, new std::codecvt_utf8_utf16<wchar_t>()));
#endif

identifier:ifndef,WIN32,fs::path::imbue,loc,new,wchar_t,endif,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:2c3eade704f63b360926de9e975ce80143781679
commit B:25548b295861c19ad0c25319df727216f81f21a8
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer(new benchmark::ConsolePrinter());

identifier:benchmark::Printer,printer,new,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>

identifier:include,boost,filesystem,detail,utf8_codecvt_facet,hpp,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void(void)>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);
    std::function<void(void)> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
        "-dbcrashratio", "-forcecompactdb",
static bool InitSanityCheck(void)

identifier:InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start(void);
void ECC_Stop(void);
bool ECC_InitSanityCheck(void);

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void(void)> >("std::function<void(void)>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
static fs::detail::utf8_codecvt_facet utf8;

    return fs::path(path.toStdString(), utf8);
    return QString::fromStdString(path.string(utf8));

identifier:fs::detail::utf8_codecvt_facet,utf8,fs::path,path,toStdString,utf8,QString::fromStdString,path,utf8,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport(void);

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):
    std::function<void(void)> func;
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void (void)> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void(void)> Function;
    std::list<std::function<void (void)>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void (void)> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x(new TestLockedPageAllocator(3, 1));

identifier:LockedPageAllocator,x,new,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});

identifier:small_queue,Correct_Queue,new,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,queue,Unique_Queue,new,Unique_Queue,QUEUE_BATCH_SIZE,queue,Memory_Queue,new,Memory_Queue,QUEUE_BATCH_SIZE,queue,FrozenCleanup_Queue,new,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,Standard_Queue,new,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString(void) {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn));
    std::unique_ptr<CNode> pnode2(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn));

identifier:CNode,pnode1,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.

identifier:g_connman,CConnman,new,CConnman,0x1337,0x1337,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = std::unique_ptr<ECCVerifyHandle>(new ECCVerifyHandle());

identifier:globalVerifyHandle,ECCVerifyHandle,new,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority(void)

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority(void);

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
bool LoadMempool(void)
bool DumpMempool(void)

identifier:LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:25548b295861c19ad0c25319df727216f81f21a8
commit B:fa6b30c40b84b58f9c5327481a91292e23ed3a7c
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false))
    {
        fprintf(stderr, "Error: SSL mode for RPC (-rpcssl) is no longer supported.\n");
        return EXIT_FAILURE;
    }

identifier:gArgs,GetBoolArg,fprintf,stderr,EXIT_FAILURE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false)) {
        uiInterface.ThreadSafeMessageBox(
            "SSL mode for RPC (-rpcssl) is no longer supported.",
            "", CClientUIInterface::MSG_ERROR);
        return false;
    }


identifier:gArgs,GetBoolArg,uiInterface,ThreadSafeMessageBox,CClientUIInterface::MSG_ERROR,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-rpcssl", "-benchmark", "-h", "-help", "-socks", "-tor", "-debugnet", "-whitelistalwaysrelay",
        "-prematurewitness", "-walletprematurewitness", "-promiscuousmempoolflags", "-blockminsize", "-dbcrashratio", "-forcecompactdb", "-usehd",
    // Check for -debugnet
    if (gArgs.GetBoolArg("-debugnet", false))
        InitWarning(_("Unsupported argument -debugnet ignored, use -debug=net."));
    // Check for -socks - as this is a privacy risk to continue, exit here
    if (gArgs.IsArgSet("-socks"))
        return InitError(_("Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported."));
    // Check for -tor - as this is a privacy risk to continue, exit here
    if (gArgs.GetBoolArg("-tor", false))
        return InitError(_("Unsupported argument -tor found, use -onion."));

    if (gArgs.GetBoolArg("-benchmark", false))
        InitWarning(_("Unsupported argument -benchmark ignored, use -debug=bench."));

    if (gArgs.GetBoolArg("-whitelistalwaysrelay", false))
        InitWarning(_("Unsupported argument -whitelistalwaysrelay ignored, use -whitelistrelay and/or -whitelistforcerelay."));

    if (gArgs.IsArgSet("-blockminsize"))
        InitWarning("Unsupported argument -blockminsize ignored.");


identifier:hidden_args,gArgs,GetBoolArg,InitWarning,_,gArgs,IsArgSet,InitError,_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        if (!gArgs.GetBoolArg("-usehd", true)) {
            InitError(strprintf(_("Error creating %s: You can't create non-HD wallets with this version."), walletFile));
            return nullptr;
        }
    } else if (gArgs.IsArgSet("-usehd")) {
        bool useHD = gArgs.GetBoolArg("-usehd", true);
        if (walletInstance->IsHDEnabled() && !useHD) {
            InitError(strprintf(_("Error loading %s: You can't disable HD on an already existing HD wallet"), walletFile));
            return nullptr;
        }
        if (!walletInstance->IsHDEnabled() && useHD) {
            InitError(strprintf(_("Error loading %s: You can't enable HD on an already existing non-HD wallet"), walletFile));
            return nullptr;
        }

identifier:gArgs,GetBoolArg,InitError,strprintf,_,walletFile,nullptr,walletInstance,IsHDEnabled,useHD,InitError,strprintf,_,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fa6b30c40b84b58f9c5327481a91292e23ed3a7c
commit B:9a3a984bb884c1153866b64845db7300121966b3
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-h", "-help",
        "-dbcrashratio", "-forcecompactdb", "-usehd",

identifier:hidden_args,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:9a3a984bb884c1153866b64845db7300121966b3
commit B:1e5b9254a9a058e393cbe43c3a437186e9d901dc
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false))
    {
        fprintf(stderr, "Error: SSL mode for RPC (-rpcssl) is no longer supported.\n");
        return EXIT_FAILURE;
    }

identifier:gArgs,GetBoolArg,fprintf,stderr,EXIT_FAILURE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false)) {
        uiInterface.ThreadSafeMessageBox(
            "SSL mode for RPC (-rpcssl) is no longer supported.",
            "", CClientUIInterface::MSG_ERROR);
        return false;
    }


identifier:gArgs,GetBoolArg,uiInterface,ThreadSafeMessageBox,CClientUIInterface::MSG_ERROR,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-rpcssl", "-benchmark", "-h", "-help", "-socks", "-tor", "-debugnet", "-whitelistalwaysrelay",
        "-prematurewitness", "-walletprematurewitness", "-promiscuousmempoolflags", "-blockminsize", "-dbcrashratio", "-forcecompactdb", "-usehd",
    // Check for -debugnet
    if (gArgs.GetBoolArg("-debugnet", false))
        InitWarning(_("Unsupported argument -debugnet ignored, use -debug=net."));
    // Check for -socks - as this is a privacy risk to continue, exit here
    if (gArgs.IsArgSet("-socks"))
        return InitError(_("Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported."));
    // Check for -tor - as this is a privacy risk to continue, exit here
    if (gArgs.GetBoolArg("-tor", false))
        return InitError(_("Unsupported argument -tor found, use -onion."));

    if (gArgs.GetBoolArg("-benchmark", false))
        InitWarning(_("Unsupported argument -benchmark ignored, use -debug=bench."));

    if (gArgs.GetBoolArg("-whitelistalwaysrelay", false))
        InitWarning(_("Unsupported argument -whitelistalwaysrelay ignored, use -whitelistrelay and/or -whitelistforcerelay."));

    if (gArgs.IsArgSet("-blockminsize"))
        InitWarning("Unsupported argument -blockminsize ignored.");


identifier:hidden_args,gArgs,GetBoolArg,InitWarning,_,gArgs,IsArgSet,InitError,_,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:52beb9ed8876e3129360197ac632c1b59f910c55
commit B:fa910e43014d7b6a22f95e2c65b1c4a3e8d5cedc
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-h", "-help",
        "-dbcrashratio", "-forcecompactdb", "-usehd",

identifier:hidden_args,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fa910e43014d7b6a22f95e2c65b1c4a3e8d5cedc
commit B:920c090f63f4990bf0f3b3d1a6d3d8a8bcd14ba0
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer = MakeUnique<benchmark::ConsolePrinter>();

identifier:benchmark::Printer,printer,MakeUnique,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));

identifier:CWalletTx,wtx,MakeUnique,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void()>& handler);
    std::function<void()> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
static bool InitSanityCheck()

identifier:InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start();
void ECC_Stop();
bool ECC_InitSanityCheck();

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void()> >("std::function<void()>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport();

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void()>& _func, int64_t millis):
    std::function<void()> func;
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void ()> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void ()> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void()> Function;
    std::list<std::function<void ()>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void ()> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x = MakeUnique<TestLockedPageAllocator>(3, 1);

identifier:LockedPageAllocator,x,MakeUnique,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = MakeUnique<Correct_Queue>(QUEUE_BATCH_SIZE);
    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);
    auto fail_queue = MakeUnique<Failing_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Unique_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Memory_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<FrozenCleanup_Queue>(QUEUE_BATCH_SIZE);
    auto queue = MakeUnique<Standard_Queue>(QUEUE_BATCH_SIZE);

identifier:small_queue,MakeUnique,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,MakeUnique,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,MakeUnique,Failing_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Unique_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Memory_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,MakeUnique,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString() {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1 = MakeUnique<CNode>(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn);
    std::unique_ptr<CNode> pnode2 = MakeUnique<CNode>(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn);

identifier:CNode,pnode1,MakeUnique,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,MakeUnique,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
        g_connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.

identifier:g_connman,MakeUnique,CConnman,0x1337,0x1337,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = MakeUnique<ECCVerifyHandle>();

identifier:globalVerifyHandle,MakeUnique,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority()

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority();

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
bool LoadMempool()
bool DumpMempool()

identifier:LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx = MakeUnique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));

identifier:CWalletTx,wtx,MakeUnique,CWalletTx,testWallet,MakeTransactionRef,tx,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:920c090f63f4990bf0f3b3d1a6d3d8a8bcd14ba0
commit B:b6718e373ed425fa2440ddd8f1b05c76b782dc2b
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false))
    {
        fprintf(stderr, "Error: SSL mode for RPC (-rpcssl) is no longer supported.\n");
        return EXIT_FAILURE;
    }

identifier:gArgs,GetBoolArg,fprintf,stderr,EXIT_FAILURE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    if (gArgs.GetBoolArg("-rpcssl", false)) {
        uiInterface.ThreadSafeMessageBox(
            "SSL mode for RPC (-rpcssl) is no longer supported.",
            "", CClientUIInterface::MSG_ERROR);
        return false;
    }

HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void(void)>& _handler):

identifier:gArgs,GetBoolArg,uiInterface,ThreadSafeMessageBox,CClientUIInterface::MSG_ERROR,HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);
    std::function<void(void)> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-rpcssl", "-benchmark", "-h", "-help", "-socks", "-tor", "-debugnet", "-whitelistalwaysrelay",
        "-prematurewitness", "-walletprematurewitness", "-promiscuousmempoolflags", "-blockminsize", "-dbcrashratio", "-forcecompactdb", "-usehd",
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is (0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);
static bool InitSanityCheck(void)
    // Check for -debugnet
    if (gArgs.GetBoolArg("-debugnet", false))
        InitWarning(_("Unsupported argument -debugnet ignored, use -debug=net."));
    // Check for -socks - as this is a privacy risk to continue, exit here
    if (gArgs.IsArgSet("-socks"))
        return InitError(_("Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported."));
    // Check for -tor - as this is a privacy risk to continue, exit here
    if (gArgs.GetBoolArg("-tor", false))
        return InitError(_("Unsupported argument -tor found, use -onion."));

    if (gArgs.GetBoolArg("-benchmark", false))
        InitWarning(_("Unsupported argument -benchmark ignored, use -debug=bench."));

    if (gArgs.GetBoolArg("-whitelistalwaysrelay", false))
        InitWarning(_("Unsupported argument -whitelistalwaysrelay ignored, use -whitelistrelay and/or -whitelistforcerelay."));

    if (gArgs.IsArgSet("-blockminsize"))
        InitWarning("Unsupported argument -blockminsize ignored.");


identifier:hidden_args,gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,gArgs,AddArg,OptionsCategory::DEBUG_TEST,InitSanityCheck,gArgs,GetBoolArg,InitWarning,_,gArgs,IsArgSet,InitError,_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/fees.h>
#include <wallet/wallet.h>
#define CHECK_WALLET(x) x
#else
#define CHECK_WALLET(x) throw std::logic_error("Wallet function called in non-wallet build.")
#endif
#ifdef ENABLE_WALLET
#else
        throw std::logic_error("Node::getWallets() called in non-wallet build.");
#endif
        CHECK_WALLET(
            return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); })));

identifier:ifdef,ENABLE_WALLET,include,wallet,fees,h,include,wallet,wallet,h,define,CHECK_WALLET,x,x,define,CHECK_WALLET,x,throw,endif,ifdef,ENABLE_WALLET,throw,endif,CHECK_WALLET,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start(void);
void ECC_Stop(void);
bool ECC_InitSanityCheck(void);

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("%1 will close now to finish the encryption process. "
                                         "your bitcoins from being stolen by malware infecting your computer.").arg(tr(PACKAGE_NAME)) +
                    QApplication::quit();

identifier:tr,arg,tr,PACKAGE_NAME,QApplication::quit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void(void)> >("std::function<void(void)>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport(void);

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):
    std::function<void(void)> func;
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block) {
        if (!accepted) {
            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?
            return "invalid";
        }

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, e.what());

identifier:LogPrintf,__func__,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void (void)> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void(void)> Function;
    std::list<std::function<void (void)>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void (void)> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString(void) {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),
int ScheduleBatchPriority(void)

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExA,src,c_str,dest,c_str,ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority(void);

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, false))
bool LoadMempool(void)
bool DumpMempool(void)

identifier:CheckTransaction,tx,state,LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                g_dbenvs.erase(strPath);
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), e.what());
        if (shutdown) env = nullptr;

identifier:g_dbenvs,erase,strPath,LogPrintf,strFile,pathDest,e,what,shutdown,env,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
            "Note that this will shutdown the server.\n"
    // BDB seems to have a bad habit of writing old data into
    // slack space in .dat files; that is bad if the old data is
    // unencrypted private keys. So:
    StartShutdown();
    return "wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:StartShutdown,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, e.what());

identifier:error_string,strprintf,wallet_file,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    pcontext = zmq_init(1);
        zmq_ctx_destroy(pcontext);

identifier:pcontext,zmq_init,zmq_ctx_destroy,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:b6718e373ed425fa2440ddd8f1b05c76b782dc2b
commit B:2796c6e5ec9055545e987023b04eb5ebe64d5320
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/bench_bitcoin.cpp
changed code snippet:
    std::unique_ptr<benchmark::Printer> printer(new benchmark::ConsolePrinter());

identifier:benchmark::Printer,printer,new,benchmark::ConsolePrinter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/coin_selection.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:
class CWallet;


std::vector<std::shared_ptr<CWallet>> GetWallets()
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

namespace interfaces {

class Wallet;

std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

} // namespace interfaces

identifier:class,CWallet,CWallet,GetWallets,throw,namespace,interfaces,class,Wallet,Wallet,MakeWallet,CWallet,wallet,throw,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
std::string get_filesystem_error_message(const fs::filesystem_error& e)
{
#ifndef WIN32
    return e.what();
#else
    // Convert from Multi Byte to utf-16
    std::string mb_string(e.what());
    int size = MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), nullptr, 0);

    std::wstring utf16_string(size, L'\0');
    MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), &*utf16_string.begin(), size);
    // Convert from utf-16 to utf-8
    return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>().to_bytes(utf16_string);
#endif
}


identifier:get_filesystem_error_message,fs::filesystem_error,e,ifndef,WIN32,e,what,mb_string,e,what,size,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,nullptr,utf16_string,size,L,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,utf16_string,begin,size,wchar_t,wchar_t,to_bytes,utf16_string,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

    std::string get_filesystem_error_message(const fs::filesystem_error& e);

identifier:get_filesystem_error_message,fs::filesystem_error,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void()>& handler);
    std::function<void()> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    std::vector<std::string> hidden_args = {"-h", "-help",
        "-dbcrashratio", "-forcecompactdb", "-usehd",
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is: "
        "level 0 reads the blocks from disk, "
        "level 1 verifies block validity, "
        "level 2 verifies undo data, "
        "level 3 checks disconnection of tip blocks, "
        "and level 4 tries to reconnect the blocks, "
        "each level includes the checks of the previous levels "
        "(0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);
static bool InitSanityCheck()

identifier:hidden_args,gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,gArgs,AddArg,OptionsCategory::DEBUG_TEST,InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
class CWallet;
std::vector<std::shared_ptr<CWallet>> GetWallets();


class Wallet;

        return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); }));

identifier:class,CWallet,CWallet,GetWallets,class,Wallet,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start();
void ECC_Stop();
bool ECC_InitSanityCheck();

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("Your wallet is now encrypted. "
                                         "your bitcoins from being stolen by malware infecting your computer.") +

identifier:tr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void()> >("std::function<void()>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport();

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void()>& _func, int64_t millis):
    std::function<void()> func;
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:
    { "getnodeaddresses", 0, "count"},

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block && accepted) {

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
static UniValue getnodeaddresses(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() > 1) {
        throw std::runtime_error(
            "getnodeaddresses ( count )\n"
            "\nReturn known addresses which can potentially be used to find new nodes in the network\n"
            "\nArguments:\n"
            "1. \"count\"    (numeric, optional) How many addresses to return. Limited to the smaller of " + std::to_string(ADDRMAN_GETADDR_MAX) +
                " or " + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + "% of all known addresses. (default = 1)\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"time\": ttt,                (numeric) Timestamp in seconds since epoch (Jan 1 1970 GMT) keeping track of when the node was last seen\n"
            "    \"services\": n,              (numeric) The services offered\n"
            "    \"address\": \"host\",          (string) The address of the node\n"
            "    \"port\": n                   (numeric) The port of the node\n"
            "  }\n"
            "  ,....\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getnodeaddresses", "8")
            + HelpExampleRpc("getnodeaddresses", "8")
        );
    }
    if (!g_connman) {
        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, "Error: Peer-to-peer functionality missing or disabled");
    }

    int count = 1;
    if (!request.params[0].isNull()) {
        count = request.params[0].get_int();
        if (count <= 0) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Address count out of range");
        }
    }
    // returns a shuffled list of CAddress
    std::vector<CAddress> vAddr = g_connman->GetAddresses();
    UniValue ret(UniValue::VARR);

    int address_return_count = std::min<int>(count, vAddr.size());
    for (int i = 0; i < address_return_count; ++i) {
        UniValue obj(UniValue::VOBJ);
        const CAddress& addr = vAddr[i];
        obj.pushKV("time", (int)addr.nTime);
        obj.pushKV("services", (uint64_t)addr.nServices);
        obj.pushKV("address", addr.ToStringIP());
        obj.pushKV("port", addr.GetPort());
        ret.push_back(obj);
    }
    return ret;
}

    { "network",            "getnodeaddresses",       &getnodeaddresses,       {"count"} },

identifier:UniValue,getnodeaddresses,JSONRPCRequest,request,request,fHelp,request,params,size,throw,ADDRMAN_GETADDR_MAX,ADDRMAN_GETADDR_MAX_PCT,HelpExampleCli,HelpExampleRpc,g_connman,throw,JSONRPCError,RPC_CLIENT_P2P_DISABLED,count,request,params,isNull,count,request,params,get_int,count,throw,JSONRPCError,RPC_INVALID_PARAMETER,CAddress,vAddr,g_connman,GetAddresses,UniValue,ret,UniValue::VARR,address_return_count,count,vAddr,size,i,i,address_return_count,i,UniValue,obj,UniValue::VOBJ,CAddress,addr,vAddr,i,obj,pushKV,addr,nTime,obj,pushKV,uint64_t,addr,nServices,obj,pushKV,addr,ToStringIP,obj,pushKV,addr,GetPort,ret,push_back,obj,ret,getnodeaddresses,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,__func__,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void ()> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void ()> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void()> Function;
    std::list<std::function<void ()>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void ()> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/allocator_tests.cpp
changed code snippet:
    std::unique_ptr<LockedPageAllocator> x(new TestLockedPageAllocator(3, 1));

identifier:LockedPageAllocator,x,new,TestLockedPageAllocator,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});
    auto queue = std::unique_ptr<Standard_Queue>(new Standard_Queue{QUEUE_BATCH_SIZE});

identifier:small_queue,Correct_Queue,new,Correct_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,fail_queue,Failing_Queue,new,Failing_Queue,QUEUE_BATCH_SIZE,queue,Unique_Queue,new,Unique_Queue,QUEUE_BATCH_SIZE,queue,Memory_Queue,new,Memory_Queue,QUEUE_BATCH_SIZE,queue,FrozenCleanup_Queue,new,FrozenCleanup_Queue,QUEUE_BATCH_SIZE,queue,Standard_Queue,new,Standard_Queue,QUEUE_BATCH_SIZE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString() {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    std::unique_ptr<CNode> pnode1(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn));
    std::unique_ptr<CNode> pnode2(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn));

identifier:CNode,pnode1,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,CNode,pnode2,new,CNode,id,NODE_NETWORK,height,hSocket,addr,CAddress,pszDest,fInboundIn,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.

identifier:g_connman,CConnman,new,CConnman,0x1337,0x1337,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin_fuzzy.cpp
changed code snippet:
    globalVerifyHandle = std::unique_ptr<ECCVerifyHandle>(new ECCVerifyHandle());

identifier:globalVerifyHandle,ECCVerifyHandle,new,ECCVerifyHandle,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),
int ScheduleBatchPriority()

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExW,src,wstring,c_str,dest,wstring,c_str,ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority();

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, true))
        uiInterface.ShowProgress(_("Replaying blocks..."), (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);
bool LoadMempool()
bool DumpMempool()

identifier:CheckTransaction,tx,state,uiInterface,ShowProgress,_,nHeight,nForkHeight,pindexNew,nHeight,nForkHeight,LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = COIN / 10;
static const CAmount HIGH_TX_FEE_PER_KB = COIN / 100;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    env->m_db_in_use.notify_all();
void BerkeleyEnvironment::ReloadDbEnv()
{
    // Make sure that no Db's are in use
    AssertLockNotHeld(cs_db);
    std::unique_lock<CCriticalSection> lock(cs_db);
    m_db_in_use.wait(lock, [this](){
        for (auto& count : mapFileUseCount) {
            if (count.second > 0) return false;
        }
        return true;
    });

    std::vector<std::string> filenames;
    for (auto it : mapDb) {
        filenames.push_back(it.first);
    }
    // Close the individual Db's
    for (const std::string& filename : filenames) {
        CloseDb(filename);
    }
    // Reset the environment
    Flush(true); // This will flush and close the environment
    Reset();
    Open(true);
}

                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));
        if (shutdown) {
            LOCK(cs_db);
            g_dbenvs.erase(env->Directory().string());
            env = nullptr;
        }
    }
}

void BerkeleyDatabase::ReloadDbEnv()
{
    if (!IsDummy()) {
        env->ReloadDbEnv();

identifier:env,m_db_in_use,notify_all,BerkeleyEnvironment::ReloadDbEnv,AssertLockNotHeld,cs_db,CCriticalSection,lock,cs_db,m_db_in_use,wait,lock,this,count,mapFileUseCount,count,second,filenames,it,mapDb,filenames,push_back,it,first,filename,filenames,CloseDb,filename,Flush,Reset,Open,LogPrintf,strFile,pathDest,fsbridge::get_filesystem_error_message,e,shutdown,LOCK,cs_db,g_dbenvs,erase,env,Directory,env,nullptr,BerkeleyDatabase::ReloadDbEnv,IsDummy,env,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:
    std::condition_variable_any m_db_in_use;
    void ReloadDbEnv();
    void ReloadDbEnv();


identifier:m_db_in_use,ReloadDbEnv,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    return "wallet encrypted; The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    std::unique_ptr<CWalletTx> wtx(new CWalletTx(&testWallet, MakeTransactionRef(std::move(tx))));

identifier:CWalletTx,wtx,new,CWalletTx,testWallet,MakeTransactionRef,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        // BDB seems to have a bad habit of writing old data into
        // slack space in .dat files; that is bad if the old data is
        // unencrypted private keys. So:
        database->ReloadDbEnv();

        error_string = strprintf("Error loading wallet %s. %s", wallet_file, fsbridge::get_filesystem_error_message(e));

identifier:database,ReloadDbEnv,error_string,strprintf,wallet_file,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    int major = 0, minor = 0, patch = 0;
    zmq_version(&major, &minor, &patch);
    LogPrint(BCLog::ZMQ, "zmq: version %d.%d.%d\n", major, minor, patch);

    pcontext = zmq_ctx_new();
        zmq_ctx_term(pcontext);

identifier:major,minor,patch,zmq_version,major,minor,patch,LogPrint,BCLog::ZMQ,major,minor,patch,pcontext,zmq_ctx_new,zmq_ctx_term,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:2796c6e5ec9055545e987023b04eb5ebe64d5320
commit B:a23a7f60aa07de52d23ff1f2034fc43926ec3520
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (auto v_i : v) {
    for (auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/crypto_hash.cpp
changed code snippet:
    uint32_t x = 0;
        x += rng.rand32();
    uint32_t x = 0;
        x += rng.randbool();

identifier:uint32_t,x,x,rng,rand32,uint32_t,x,x,rng,randbool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/mempool_eviction.cpp
changed code snippet:
    pool.addUnchecked(tx->GetHash(), CTxMemPoolEntry(

identifier:pool,addUnchecked,tx,GetHash,CTxMemPoolEntry,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/rollingbloom.cpp
changed code snippet:
    uint64_t match = 0;
        match += filter.contains(data);

identifier:uint64_t,match,match,filter,contains,data,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", _("Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);
    if (gArgs.GetBoolArg("-rpcssl", false))
    {
        fprintf(stderr, "Error: SSL mode for RPC (-rpcssl) is no longer supported.\n");
        return EXIT_FAILURE;
    }

identifier:gArgs,AddArg,_,OptionsCategory::OPTIONS,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::OPTIONS,gArgs,GetBoolArg,fprintf,stderr,EXIT_FAILURE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <consensus/merkle.h>
#include <chainparamsseeds.h>

/**
 * What makes a good checkpoint block?
 * + Is surrounded by blocks with reasonable timestamps
 *   (no blocks before with a timestamp after, none after with
 *    timestamp before)
 * + Contains no strange transactions
 */


identifier:include,consensus,merkle,h,include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx	transaction for which we are checking input total
     * @return	Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/compat.h
changed code snippet:
#if defined(__GNUC__) && __GNUC__ < 5
#define IS_TRIVIALLY_CONSTRUCTIBLE std::is_trivial
#define IS_TRIVIALLY_CONSTRUCTIBLE std::is_trivially_constructible

identifier:defined,__GNUC__,__GNUC__,define,IS_TRIVIALLY_CONSTRUCTIBLE,define,IS_TRIVIALLY_CONSTRUCTIBLE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (uint32_t loc : locs)
            for (uint32_t loc : locs) {
        for (uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmaped).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
FILE *freopen(const fs::path& p, const char *mode, FILE *stream)
    return ::freopen(p.string().c_str(), mode, stream);

identifier:FILE,freopen,fs::path,p,mode,FILE,stream,freopen,p,c_str,mode,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
    FILE *freopen(const fs::path& p, const char *mode, FILE *stream);

identifier:FILE,freopen,fs::path,p,mode,FILE,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override
#ifdef ENABLE_WALLET
    // ifdef can be removed once we switch to better endpoint support and API versioning
    RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
#endif
#ifdef ENABLE_WALLET
    UnregisterHTTPHandler("/wallet/", false);
#endif

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,ifdef,ENABLE_WALLET,RegisterHTTPHandler,HTTPReq_JSONRPC,endif,ifdef,ENABLE_WALLET,UnregisterHTTPHandler,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    std::mutex cs;
        std::unique_lock<std::mutex> lock(cs);
                std::unique_lock<std::mutex> lock(cs);
        std::unique_lock<std::mutex> lock(cs);
    if (gArgs.GetBoolArg("-rpcssl", false)) {
        uiInterface.ThreadSafeMessageBox(
            "SSL mode for RPC (-rpcssl) is no longer supported.",
            "", CClientUIInterface::MSG_ERROR);
        return false;
    }

HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void(void)>& _handler):

identifier:cs,lock,cs,lock,cs,lock,cs,gArgs,GetBoolArg,uiInterface,ThreadSafeMessageBox,CClientUIInterface::MSG_ERROR,HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);
    std::function<void(void)> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#include <boost/interprocess/sync/file_lock.hpp>
#if !(ENABLE_WALLET)
class DummyWalletInit : public WalletInitInterface {
public:

    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();
#endif

    std::vector<std::string> hidden_args = {"-rpcssl", "-benchmark", "-h", "-help", "-socks", "-tor", "-debugnet", "-whitelistalwaysrelay",
        "-prematurewitness", "-walletprematurewitness", "-promiscuousmempoolflags", "-blockminsize", "-dbcrashratio", "-forcecompactdb", "-usehd",
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (0 to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u or testnet: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is (0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", strprintf("Output debugging information (default: %u, supplying <category> is optional)", 0) + ". " +
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set debuglogfile=0)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);
static CWaitableCriticalSection cs_GenesisWait;
static CConditionVariable condvar_GenesisWait;
            WaitableLock lock_GenesisWait(cs_GenesisWait);
        condvar_GenesisWait.notify_all();
static bool InitSanityCheck(void)
    // Check for -debugnet
    if (gArgs.GetBoolArg("-debugnet", false))
        InitWarning(_("Unsupported argument -debugnet ignored, use -debug=net."));
    // Check for -socks - as this is a privacy risk to continue, exit here
    if (gArgs.IsArgSet("-socks"))
        return InitError(_("Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported."));
    // Check for -tor - as this is a privacy risk to continue, exit here
    if (gArgs.GetBoolArg("-tor", false))
        return InitError(_("Unsupported argument -tor found, use -onion."));

    if (gArgs.GetBoolArg("-benchmark", false))
        InitWarning(_("Unsupported argument -benchmark ignored, use -debug=bench."));

    if (gArgs.GetBoolArg("-whitelistalwaysrelay", false))
        InitWarning(_("Unsupported argument -whitelistalwaysrelay ignored, use -whitelistrelay and/or -whitelistforcerelay."));

    if (gArgs.IsArgSet("-blockminsize"))
        InitWarning("Unsupported argument -blockminsize ignored.");

    LogPrintf("Using config file %s\n", GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME)).string());
        WaitableLock lock(cs_GenesisWait);
            condvar_GenesisWait.wait_for(lock, std::chrono::milliseconds(500));

identifier:include,boost,interprocess,sync,file_lock,hpp,ENABLE_WALLET,class,DummyWalletInit,public,WalletInitInterface,public,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,endif,hidden_args,gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::RPC,CWaitableCriticalSection,cs_GenesisWait,CConditionVariable,condvar_GenesisWait,WaitableLock,lock_GenesisWait,cs_GenesisWait,condvar_GenesisWait,notify_all,InitSanityCheck,gArgs,GetBoolArg,InitWarning,_,gArgs,IsArgSet,InitError,_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:
class WalletInitInterface;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:class,WalletInitInterface,WalletInitInterface,g_wallet_init_interface,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/handler.cpp
changed code snippet:
    HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) {}

identifier:HandlerImpl,boost::signals2::connection,connection,m_connection,connection,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/fees.h>
#include <wallet/wallet.h>
#define CHECK_WALLET(x) x
#else
#define CHECK_WALLET(x) throw std::logic_error("Wallet function called in non-wallet build.")
#endif
#ifdef ENABLE_WALLET
#else
        throw std::logic_error("Node::getWallets() called in non-wallet build.");
#endif
        CHECK_WALLET(
            return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); })));

identifier:ifdef,ENABLE_WALLET,include,wallet,fees,h,include,wallet,wallet,h,define,CHECK_WALLET,x,x,define,CHECK_WALLET,x,throw,endif,ifdef,ENABLE_WALLET,throw,endif,CHECK_WALLET,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.cpp
changed code snippet:
    PendingWalletTxImpl(CWallet& wallet) : m_wallet(wallet), m_key(&wallet) {}
        std::string from_account,
        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), std::move(from_account), m_key, g_connman.get(), state)) {
WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)
WalletTxStatus MakeWalletTxStatus(const CWalletTx& wtx)
WalletTxOut MakeWalletTxOut(CWallet& wallet, const CWalletTx& wtx, int n, int depth)
    WalletImpl(const std::shared_ptr<CWallet>& wallet) : m_shared_wallet(wallet), m_wallet(*wallet.get()) {}

identifier:PendingWalletTxImpl,CWallet,wallet,m_wallet,wallet,m_key,wallet,from_account,m_wallet,CommitTransaction,m_tx,value_map,order_form,from_account,m_key,g_connman,get,state,WalletTx,MakeWalletTx,CWallet,wallet,CWalletTx,wtx,WalletTxStatus,MakeWalletTxStatus,CWalletTx,wtx,WalletTxOut,MakeWalletTxOut,CWallet,wallet,CWalletTx,wtx,n,depth,WalletImpl,CWallet,wallet,m_shared_wallet,wallet,m_wallet,wallet,get,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:
        std::string from_account,

identifier:from_account,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start(void);
void ECC_Stop(void);
bool ECC_InitSanityCheck(void);

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key_io.cpp
changed code snippet:
    DestinationEncoder(const CChainParams& params) : m_params(params) {}

identifier:DestinationEncoder,CChainParams,params,m_params,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.cpp
changed code snippet:
                m_fileout = fsbridge::freopen(m_file_path, "a", m_fileout);
                if (!m_fileout) {
                    return;
                setbuf(m_fileout, nullptr); // unbuffered


identifier:m_fileout,fsbridge::freopen,m_file_path,m_fileout,m_fileout,setbuf,m_fileout,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(nPrevNodeCount);
        for (auto pnode : vNodes) {
        for (CNode* pnode : vNodes) {
            for (CNode* pnode : vNodes) {
        std::unique_lock<std::mutex> lock(mutexMsgProc);
#else
        std::unique_lock<std::mutex> lock(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,nPrevNodeCount,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,lock,mutexMsgProc,lock,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    std::mutex mutexMsgProc;

identifier:mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
static CCriticalSection g_cs_orphans;
static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman)
static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams)
        for (uint256 &orphanHash : vOrphanErase) {
void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)
            for (uint256 hash : vEraseQueue)
static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman, bool enable_bip61)

identifier:CCriticalSection,g_cs_orphans,MaybeSetPeerAsAnnouncingHeaderAndIDs,NodeId,nodeid,CConnman,connman,BlockRequestAllowed,CBlockIndex,pindex,Consensus::Params,consensusParams,uint256,orphanHash,vOrphanErase,ProcessGetData,CNode,pfrom,CChainParams,chainparams,CConnman,connman,interruptMsgProc,uint256,hash,vEraseQueue,SendRejectsAndCheckIfBanned,CNode,pnode,CConnman,connman,enable_bip61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;
    void ConsiderEviction(CNode *pto, int64_t time_in_seconds);

identifier:constexpr,DEFAULT_ENABLE_BIP61,ConsiderEviction,CNode,pto,int64_t,time_in_seconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#include <boost/algorithm/string/case_conv.hpp> // for to_lower()

    boost::to_lower(net);
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:include,boost,algorithm,case_conv,hpp,boost::to_lower,net,buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
static bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
static bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
static void noui_InitMessage(const std::string& message)
    // Connect bitcoind signal handlers

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
extern void noui_connect();

identifier:noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
/** \class CBlockPolicyEstimator
 * The BlockPolicyEstimator is used for estimating the feerate needed
 * for a transaction to be included in a block within a certain number of
 * blocks.
 *
 * At a high level the algorithm works by grouping transactions into buckets
 * based on having similar feerates and then tracking how long it
 * takes transactions in the various buckets to be mined.  It operates under
 * the assumption that in general transactions of higher feerate will be
 * included in blocks before transactions of lower feerate.   So for
 * example if you wanted to know what feerate you should put on a transaction to
 * be included in a block within the next 5 blocks, you would start by looking
 * at the bucket with the highest feerate transactions and verifying that a
 * sufficiently high percentage of them were confirmed within 5 blocks and
 * then you would look at the next highest feerate bucket, and so on, stopping at
 * the last bucket to pass the test.   The average feerate of transactions in this
 * bucket will give you an indication of the lowest feerate you can put on a
 * transaction and still have a sufficiently high chance of being confirmed
 * within your desired 5 blocks.
 *
 * Here is a brief description of the implementation:
 * When a transaction enters the mempool, we track the height of the block chain
 * at entry.  All further calculations are conducted only on this set of "seen"
 * transactions. Whenever a block comes in, we count the number of transactions
 * in each bucket and the total amount of feerate paid in each bucket. Then we
 * calculate how many blocks Y it took each transaction to be mined.  We convert
 * from a number of blocks to a number of periods Y' each encompassing "scale"
 * blocks.  This is tracked in 3 different data sets each up to a maximum
 * number of periods. Within each data set we have an array of counters in each
 * feerate bucket and we increment all the counters from Y' up to max periods
 * representing that a tx was successfully confirmed in less than or equal to
 * that many periods. We want to save a history of this information, so at any
 * time we have a counter of the total number of transactions that happened in a
 * given feerate bucket and the total number that were confirmed in each of the
 * periods or less for any bucket.  We save this history by keeping an
 * exponentially decaying moving average of each one of these stats.  This is
 * done for a different decay in each of the 3 data sets to keep relevant data
 * from different time horizons.  Furthermore we also keep track of the number
 * unmined (in mempool or left mempool without being included in a block)
 * transactions in each bucket and for how many blocks they have been
 * outstanding and use both of these numbers to increase the number of transactions
 * we've seen in that feerate bucket when calculating an estimate for any number
 * of confirmations below the number of blocks they've been outstanding.
 */

/**

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);

identifier:size_t,nSize,GetSerializeSize,txout,SER_DISK,
++@DIFF ENTRY SEPERATOR@++
changed file:src/prevector.h
changed code snippet:
    explicit prevector(size_type n) : _size(0) {
    explicit prevector(size_type n, const T& val = T()) : _size(0) {
    prevector(InputIterator first, InputIterator last) : _size(0) {
    prevector(const prevector<N, T, Size, Diff>& other) : _size(0) {
    prevector(prevector<N, T, Size, Diff>&& other) : _size(0) {

identifier:explicit,prevector,size_type,n,_size,explicit,prevector,size_type,n,T,val,T,_size,prevector,InputIterator,first,InputIterator,last,_size,prevector,prevector,N,T,Size,Diff,other,_size,prevector,prevector,N,T,Size,Diff,other,_size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/addresstablemodel.cpp
changed code snippet:
    AddressTablePriv(AddressTableModel *_parent):

identifier:AddressTablePriv,AddressTableModel,_parent,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("%1 will close now to finish the encryption process. "
                                         "your bitcoins from being stolen by malware infecting your computer.").arg(tr(PACKAGE_NAME)) +
                    QApplication::quit();

identifier:tr,arg,tr,PACKAGE_NAME,QApplication::quit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
static void InitMessage(const std::string &message)
    LogPrintf("init message: %s\n", message);
    for (WalletModel *walletModel : m_wallet_models) {
    qRegisterMetaType< std::function<void(void)> >("std::function<void(void)>");

identifier:InitMessage,message,LogPrintf,message,WalletModel,walletModel,m_wallet_models,qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.h
changed code snippet:
     @param[in] status            current hd enabled status

identifier:param,in,status,current,hd,enabled,status,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
#include <boost/scoped_array.hpp>

        IShellLink* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLink,
            TCHAR pszExePath[MAX_PATH];
            GetModuleFileName(nullptr, pszExePath, sizeof(pszExePath));
#ifdef UNICODE
            boost::scoped_array<TCHAR> args(new TCHAR[strArgs.length() + 1]);
            // Convert the QString to TCHAR*
            strArgs.toWCharArray(args.get());
            // Add missing '\0'-termination to string
            args[strArgs.length()] = '\0';
#endif

            PathRemoveFileSpec(pszExePath);
#ifndef UNICODE
            psl->SetArguments(strArgs.toStdString().c_str());
#else
            psl->SetArguments(args.get());
#endif
                WCHAR pwsz[MAX_PATH];
                // Ensure that the string is ANSI.
                MultiByteToWideChar(CP_ACP, 0, StartupShortcutPath().string().c_str(), -1, pwsz, MAX_PATH);
                hres = ppf->Save(pwsz, TRUE);

identifier:include,boost,scoped_array,hpp,IShellLink,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLink,TCHAR,pszExePath,MAX_PATH,GetModuleFileName,nullptr,pszExePath,pszExePath,ifdef,UNICODE,boost::scoped_array,TCHAR,args,new,TCHAR,strArgs,length,strArgs,toWCharArray,args,get,args,strArgs,length,endif,PathRemoveFileSpec,pszExePath,ifndef,UNICODE,psl,SetArguments,strArgs,toStdString,c_str,psl,SetArguments,args,get,endif,WCHAR,pwsz,MAX_PATH,MultiByteToWideChar,CP_ACP,StartupShortcutPath,c_str,pwsz,MAX_PATH,hres,ppf,Save,pwsz,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport(void);

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    RPCExecutor(interfaces::Node& node) : m_node(node) {}
    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):
    std::function<void(void)> func;
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)
 * @param[out]   result      stringified Result from the executed command(chain)

identifier:RPCExecutor,interfaces::Node,node,m_node,node,QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,param,out,result,stringified,Result,from,the,executed,command,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of miliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,miliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (float f : vSamplesIn) {
    for (float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiontablemodel.cpp
changed code snippet:
    TransactionTablePriv(TransactionTableModel *_parent) :

identifier:TransactionTablePriv,TransactionTableModel,_parent,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/walletmodel.cpp
changed code snippet:
        if (!newTx->commit({} /* mapValue */, std::move(vOrderForm), {} /* fromAccount */, rejectReason))

identifier:newTx,commit,vOrderForm,rejectReason,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
static std::mutex cs_rng_state;
        std::unique_lock<std::mutex> lock(cs_rng_state);
        std::unique_lock<std::mutex> lock(cs_rng_state);

identifier:cs_rng_state,lock,cs_rng_state,lock,cs_rng_state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure& e) {

identifier:e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static std::mutex cs_blockchange;
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION));
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
           "       ... ]\n";
    for (const CTxMemPool::txiter &childiter : setChildren) {
                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
            "For more information on output descriptors, see the documentation at TODO\n"

identifier:cs_blockchange,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,lock,cs_blockchange,lock,cs_blockchange,lock,cs_blockchange,CTxMemPool::txiter,childiter,setChildren,utxo_size_inc,GetSerializeSize,out,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index, or the chain tip if
 * not provided.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,or,the,chain,tip,not,provided,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:
    { "getreceivedbyaccount", 1, "minconf" },
    { "listreceivedbyaccount", 0, "minconf" },
    { "listreceivedbyaccount", 1, "include_empty" },
    { "listreceivedbyaccount", 2, "include_watchonly" },
    { "move", 2, "amount" },
    { "move", 3, "minconf" },
    { "sendfrom", 2, "amount" },
    { "sendfrom", 3, "minconf" },
    { "listaccounts", 0, "minconf" },
    { "listaccounts", 1, "include_watchonly" },

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WaitableLock lock(g_best_block_mutex);
    if (!new_block) {
        if (!accepted) {
            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?
            return "invalid";
        }
    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WaitableLock,lock,g_best_block_mutex,new_block,accepted,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#include <wallet/wallet.h>
#include <wallet/walletdb.h>
#endif
#ifdef ENABLE_WALLET
        if (HasWallets() && IsDeprecatedRPCEnabled("validateaddress")) {
            ret.pushKVs(getaddressinfo(request));
        }
#endif
        if (ret["address"].isNull()) {
            std::string currentAddress = EncodeDestination(dest);
            ret.pushKV("address", currentAddress);
            CScript scriptPubKey = GetScriptForDestination(dest);
            ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));

            UniValue detail = DescribeAddress(dest);
            ret.pushKVs(detail);
        }
class CWallet;

            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\nNote that from v0.16, createmultisig no longer accepts addresses."
            " Users must use addmultisigaddress to create multisig addresses with addresses known to the wallet.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,include,wallet,wallet,h,include,wallet,walletdb,h,endif,ifdef,ENABLE_WALLET,HasWallets,IsDeprecatedRPCEnabled,ret,pushKVs,getaddressinfo,request,endif,ret,isNull,currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,class,CWallet,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, e.what());

identifier:LogPrintf,__func__,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#endif
            // if redeemScript given and not using the local wallet (private keys
            // given), add redeemScript to the keystore so it can be signed:
#ifdef ENABLE_WALLET
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();
#endif

    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)
        throw std::runtime_error(
            "signrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n"
            "\nDEPRECATED. Sign inputs for raw transaction (serialized, hex-encoded).\n"
            "The second optional argument (may be null) is an array of previous transaction outputs that\n"
            "this transaction depends on but may not yet be in the block chain.\n"
            "The third optional argument (may be null) is an array of base58-encoded private\n"
            "keys that, if given, will be the only keys used to sign the transaction.\n"
#ifdef ENABLE_WALLET
            + HelpRequiringPassphrase(pwallet) + "\n"
#endif
            "\nArguments:\n"
            "1. \"hexstring\"     (string, required) The transaction hex string\n"
            "2. \"prevtxs\"       (string, optional) An json array of previous dependent transaction outputs\n"
            "     [               (json array of json objects, or 'null' if none provided)\n"
            "       {\n"
            "         \"txid\":\"id\",             (string, required) The transaction id\n"
            "         \"vout\":n,                  (numeric, required) The output number\n"
            "         \"scriptPubKey\": \"hex\",   (string, required) script key\n"
            "         \"redeemScript\": \"hex\",   (string, required for P2SH or P2WSH) redeem script\n"
            "         \"amount\": value            (numeric, required) The amount spent\n"
            "       }\n"
            "       ,...\n"
            "    ]\n"
            "3. \"privkeys\"     (string, optional) A json array of base58-encoded private keys for signing\n"
            "    [                  (json array of strings, or 'null' if none provided)\n"
            "      \"privatekey\"   (string) private key in base58-encoding\n"
            "      ,...\n"
            "    ]\n"
            "4. \"sighashtype\"     (string, optional, default=ALL) The signature hash type. Must be one of\n"
            "       \"ALL\"\n"
            "       \"NONE\"\n"
            "       \"SINGLE\"\n"
            "       \"ALL|ANYONECANPAY\"\n"
            "       \"NONE|ANYONECANPAY\"\n"
            "       \"SINGLE|ANYONECANPAY\"\n"

            "\nResult:\n"
            "{\n"
            "  \"hex\" : \"value\",           (string) The hex-encoded raw transaction with signature(s)\n"
            "  \"complete\" : true|false,   (boolean) If the transaction has a complete set of signatures\n"
            "  \"errors\" : [                 (json array of objects) Script verification errors (if there are any)\n"
            "    {\n"
            "      \"txid\" : \"hash\",           (string) The hash of the referenced, previous transaction\n"
            "      \"vout\" : n,                (numeric) The index of the output to spent and used as input\n"
            "      \"scriptSig\" : \"hex\",       (string) The hex-encoded signature script\n"
            "      \"sequence\" : n,            (numeric) Script sequence number\n"
            "      \"error\" : \"text\"           (string) Verification or signing error related to the input\n"
            "    }\n"
            "    ,...\n"
            "  ]\n"
            "}\n"

            "\nExamples:\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"")
            + HelpExampleRpc("signrawtransaction", "\"myhex\"")
        );

    if (!IsDeprecatedRPCEnabled("signrawtransaction")) {
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction is deprecated and will be fully removed in v0.18. "
            "To use signrawtransaction in v0.17, restart bitcoind with -deprecatedrpc=signrawtransaction.\n"
            "Projects should transition to using signrawtransactionwithkey and signrawtransactionwithwallet before upgrading to v0.18");
    }

    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);

    // Make a JSONRPCRequest to pass on to the right signrawtransaction* command
    JSONRPCRequest new_request;
    new_request.id = request.id;
    new_request.params.setArray();

    // For signing with private keys
    if (!request.params[2].isNull()) {
        new_request.params.push_back(request.params[0]);
        // Note: the prevtxs and privkeys are reversed for signrawtransactionwithkey
        new_request.params.push_back(request.params[2]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithkey(new_request);
    } else {
#ifdef ENABLE_WALLET
        // Otherwise sign with the wallet which does not take a privkeys parameter
        new_request.params.push_back(request.params[0]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithwallet(new_request);
#else
        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.
        throw JSONRPCError(RPC_INVALID_PARAMETER, "No private keys available.");
#endif
    }
            "\nAlso see createrawtransaction and signrawtransaction calls.\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
                uint32_t fingerprint = entry.second.at(0);
                keypath.pushKV("master_fingerprint", strprintf("%08x", bswap_32(fingerprint)));

                entry.second.erase(entry.second.begin());
                keypath.pushKV("path", WriteHDKeypath(entry.second));

                uint32_t fingerprint = entry.second.at(0);
                keypath.pushKV("master_fingerprint", strprintf("%08x", bswap_32(fingerprint)));

                entry.second.erase(entry.second.begin());
                keypath.pushKV("path", WriteHDKeypath(entry.second));
        SignatureData sigdata;
        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, sigdata, i, 1);
                            "                              will be tried. If false, only non-witness deserialization wil be tried. Only has an effect if\n"
    { "rawtransactions",    "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,endif,ifdef,ENABLE_WALLET,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,endif,request,fHelp,request,params,size,request,params,size,throw,ifdef,ENABLE_WALLET,HelpRequiringPassphrase,pwallet,endif,HelpExampleCli,HelpExampleRpc,IsDeprecatedRPCEnabled,throw,JSONRPCError,RPC_METHOD_DEPRECATED,RPCTypeCheck,request,params,UniValue::VSTR,UniValue::VARR,UniValue::VARR,UniValue::VSTR,JSONRPCRequest,new_request,new_request,id,request,id,new_request,params,setArray,request,params,isNull,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithkey,new_request,ifdef,ENABLE_WALLET,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithwallet,new_request,throw,JSONRPCError,RPC_INVALID_PARAMETER,endif,HelpExampleCli,HelpExampleCli,uint32_t,fingerprint,entry,second,at,keypath,pushKV,strprintf,bswap_32,fingerprint,entry,second,erase,entry,second,begin,keypath,pushKV,WriteHDKeypath,entry,second,uint32_t,fingerprint,entry,second,at,keypath,pushKV,strprintf,bswap_32,fingerprint,entry,second,erase,entry,second,begin,keypath,pushKV,WriteHDKeypath,entry,second,SignatureData,sigdata,complete,SignPSBTInput,DUMMY_SIGNING_PROVIDER,psbtx,tx,input,sigdata,i,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
#include <boost/algorithm/string/case_conv.hpp> // for to_upper()
                    std::string firstLetter = category.substr(0,1);
                    boost::to_upper(firstLetter);
                    strRet += "== " + firstLetter + category.substr(1) + " ==\n";
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)

identifier:include,boost,algorithm,case_conv,hpp,firstLetter,category,substr,boost::to_upper,firstLetter,strRet,firstLetter,category,substr,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void (void)> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void(void)> Function;
    std::list<std::function<void (void)>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
     * Practially, this means that callbacks can behave as if they are executed
    void AddToProcessQueue(std::function<void (void)> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,Practially,this,means,that,callbacks,can,behave,as,they,are,executed,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */
/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.cpp
changed code snippet:
    if (provider.GetPubKey(address, pubkey)) {
        sigdata.misc_pubkeys.emplace(pubkey.GetID(), pubkey);
        return true;
    }
        pubkey = pk_it->second;
bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash)
        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);
        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair.first);
bool PublicOnlySigningProvider::GetCScript(const CScriptID &scriptid, CScript& script) const
bool PublicOnlySigningProvider::GetPubKey(const CKeyID &address, CPubKey& pubkey) const
    return m_provider->GetPubKey(address, pubkey);

identifier:provider,GetPubKey,address,pubkey,sigdata,misc_pubkeys,emplace,pubkey,GetID,pubkey,pubkey,pk_it,second,SignPSBTInput,SigningProvider,provider,CMutableTransaction,tx,PSBTInput,input,SignatureData,sigdata,index,sighash,sigdata,misc_pubkeys,emplace,key_pair,first,GetID,key_pair,first,sigdata,misc_pubkeys,emplace,key_pair,first,GetID,key_pair,first,PublicOnlySigningProvider::GetCScript,CScriptID,scriptid,CScript,script,PublicOnlySigningProvider::GetPubKey,CKeyID,address,CPubKey,pubkey,m_provider,GetPubKey,address,pubkey,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
class PublicOnlySigningProvider : public SigningProvider
    PublicOnlySigningProvider(const SigningProvider* provider) : m_provider(provider) {}
    bool GetCScript(const CScriptID &scriptid, CScript& script) const;
    bool GetPubKey(const CKeyID &address, CPubKey& pubkey) const;
    std::map<CKeyID, CPubKey> misc_pubkeys;
    WriteCompactSize(s, GetSerializeSizeMany(s, args...));
void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)
    std::vector<uint32_t> keypath;
    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {
        keypath.push_back(index);
    hd_keypaths.emplace(pubkey, keypath);
void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, uint8_t type)
        WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));
        for (auto& path : keypath_pair.second) {
    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;
    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;
bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, SignatureData& sigdata, int index, int sighash = 1);

identifier:class,PublicOnlySigningProvider,public,SigningProvider,PublicOnlySigningProvider,SigningProvider,provider,m_provider,provider,GetCScript,CScriptID,scriptid,CScript,script,GetPubKey,CKeyID,address,CPubKey,pubkey,CKeyID,CPubKey,misc_pubkeys,WriteCompactSize,s,GetSerializeSizeMany,s,args,DeserializeHDKeypaths,Stream,s,key,CPubKey,uint32_t,hd_keypaths,uint32_t,keypath,i,i,value_len,i,uint32_t,keypath,push_back,index,hd_keypaths,emplace,pubkey,keypath,SerializeHDKeypaths,Stream,s,CPubKey,uint32_t,hd_keypaths,uint8_t,type,WriteCompactSize,s,keypath_pair,second,size,uint32_t,path,keypath_pair,second,CPubKey,uint32_t,hd_keypaths,CPubKey,uint32_t,hd_keypaths,SignPSBTInput,SigningProvider,provider,CMutableTransaction,tx,PSBTInput,input,SignatureData,sigdata,index,sighash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    const int nType;
    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}
    int GetType() const { return nType; }
size_t GetSerializeSize(const T& t, int nType, int nVersion = 0)
    return (CSizeComputer(nType, nVersion) << t).size();
template <typename S, typename T>
size_t GetSerializeSize(const S& s, const T& t)
    return (CSizeComputer(s.GetType(), s.GetVersion()) << t).size();
}

template <typename S, typename... T>
size_t GetSerializeSizeMany(const S& s, const T&... t)
{
    CSizeComputer sc(s.GetType(), s.GetVersion());

identifier:nType,CSizeComputer,nTypeIn,nVersionIn,nSize,nType,nTypeIn,nVersion,nVersionIn,GetType,nType,size_t,GetSerializeSize,T,t,nType,nVersion,CSizeComputer,nType,nVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSize,S,s,T,t,CSizeComputer,s,GetType,s,GetVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSizeMany,S,s,T,t,CSizeComputer,sc,s,GetType,s,GetVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto alloced = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(alloced->first);

identifier:alloced,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,alloced,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    assert(false);

identifier:assert,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
 * Template mixin that adds -Wthread-safety locking
 * annotations to a subset of the mutex API.
};
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)
class CCriticalSection : public AnnotatedMixin<std::recursive_mutex>
{
public:
    ~CCriticalSection() {
        DeleteLock((void*)this);
    }
};
typedef AnnotatedMixin<std::mutex> CWaitableCriticalSection;

/** Just a typedef for std::condition_variable, can be wrapped later if desired */
typedef std::condition_variable CConditionVariable;

/** Just a typedef for std::unique_lock, can be wrapped later if desired */
typedef std::unique_lock<std::mutex> WaitableLock;
/** Wrapper around std::unique_lock<CCriticalSection> */
class SCOPED_LOCKABLE CCriticalBlock
    std::unique_lock<CCriticalSection> lock;

        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));
        if (!lock.try_lock()) {
            lock.lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);
        lock.try_lock();
        if (!lock.owns_lock())
        return lock.owns_lock();
    CCriticalBlock(CCriticalSection& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : lock(mutexIn, std::defer_lock)
    CCriticalBlock(CCriticalSection* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        lock = std::unique_lock<CCriticalSection>(*pmutexIn, std::defer_lock);
    ~CCriticalBlock() UNLOCK_FUNCTION()
        if (lock.owns_lock())
        return lock.owns_lock();
#define LOCK(cs) CCriticalBlock PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__), criticalblock2(cs2, #cs2, __FILE__, __LINE__)
#define TRY_LOCK(cs, name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)

identifier:Template,mixin,that,adds,Wthread,safety,locking,annotations,to,a,subset,of,the,mutex,API,ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,class,CCriticalSection,public,AnnotatedMixin,public,CCriticalSection,DeleteLock,this,AnnotatedMixin,CWaitableCriticalSection,CConditionVariable,WaitableLock,class,SCOPED_LOCKABLE,CCriticalBlock,CCriticalSection,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,owns_lock,lock,owns_lock,CCriticalBlock,CCriticalSection,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,lock,mutexIn,CCriticalBlock,CCriticalSection,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,lock,CCriticalSection,pmutexIn,CCriticalBlock,UNLOCK_FUNCTION,lock,owns_lock,lock,owns_lock,define,LOCK,cs,CCriticalBlock,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,CCriticalBlock,criticalblock1,cs1,cs1,__FILE__,__LINE__,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,CCriticalBlock,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockencodings_tests.cpp
changed code snippet:
    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(block.vtx[2]));
    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(block.vtx[2]));
    pool.addUnchecked(block.vtx[1]->GetHash(), entry.FromTx(block.vtx[1]));

identifier:pool,addUnchecked,block,vtx,GetHash,entry,FromTx,block,vtx,pool,addUnchecked,block,vtx,GetHash,entry,FromTx,block,vtx,pool,addUnchecked,block,vtx,GetHash,entry,FromTx,block,vtx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (auto i : range) {
        for (bool end_fails : {true, false}) {

identifier:i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure& e) {
    } catch (const std::ios_base::failure& e) {
    } catch (std::logic_error& e) {
    for (CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error& e) {
    for (CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:e,e,e,CAmount,base_value,ABSENT,PRUNED,VALUE1,e,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString(void) {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (uint256& h : hashes_insert_copy)
    for (uint256& h : hashes)
            for (auto h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure& e) {
    for (int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,e,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/denialofservice_tests.cpp
changed code snippet:
extern std::map<uint256, COrphanTx> mapOrphanTransactions;
    LOCK(cs_main);
    LOCK(cs_main);

identifier:uint256,COrphanTx,mapOrphanTransactions,LOCK,cs_main,LOCK,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/descriptor_tests.cpp
changed code snippet:
    std::string prv1, prv2;

identifier:prv1,prv2,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (auto chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/mempool_tests.cpp
changed code snippet:
    testPool.addUnchecked(txParent.GetHash(), entry.FromTx(txParent));
    testPool.addUnchecked(txParent.GetHash(), entry.FromTx(txParent));
        testPool.addUnchecked(txChild[i].GetHash(), entry.FromTx(txChild[i]));
        testPool.addUnchecked(txGrandChild[i].GetHash(), entry.FromTx(txGrandChild[i]));
        testPool.addUnchecked(txChild[i].GetHash(), entry.FromTx(txChild[i]));
        testPool.addUnchecked(txGrandChild[i].GetHash(), entry.FromTx(txGrandChild[i]));
    pool.addUnchecked(tx1.GetHash(), entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(tx2.GetHash(), entry.Fee(20000LL).FromTx(tx2));
    pool.addUnchecked(tx3.GetHash(), entry.Fee(0LL).FromTx(tx3));
    pool.addUnchecked(tx4.GetHash(), entry.Fee(15000LL).FromTx(tx4));
    pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));
    pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));
    pool.addUnchecked(tx7.GetHash(), entry.FromTx(tx7), setAncestors);
    pool.addUnchecked(tx8.GetHash(), entry.Fee(0LL).Time(2).FromTx(tx8), setAncestors);
    pool.addUnchecked(tx9.GetHash(), entry.Fee(0LL).Time(3).FromTx(tx9), setAncestors);
    pool.addUnchecked(tx10.GetHash(), entry.FromTx(tx10), setAncestors);
    pool.addUnchecked(tx1.GetHash(), entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(tx2.GetHash(), entry.Fee(20000LL).FromTx(tx2));
    pool.addUnchecked(tx3.GetHash(), entry.Fee(0LL).FromTx(tx3));
    pool.addUnchecked(tx4.GetHash(), entry.Fee(15000LL).FromTx(tx4));
    pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));
    pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));
    pool.addUnchecked(tx7.GetHash(), entry.Fee(fee).FromTx(tx7));
    pool.addUnchecked(tx8.GetHash(), entry.Fee(5000LL).FromTx(tx8));
    pool.addUnchecked(tx1.GetHash(), entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(tx2.GetHash(), entry.Fee(5000LL).FromTx(tx2));
    pool.addUnchecked(tx2.GetHash(), entry.FromTx(tx2));
    pool.addUnchecked(tx3.GetHash(), entry.Fee(20000LL).FromTx(tx3));
    pool.addUnchecked(tx4.GetHash(), entry.Fee(7000LL).FromTx(tx4));
    pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5));
    pool.addUnchecked(tx6.GetHash(), entry.Fee(1100LL).FromTx(tx6));
    pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7));
        pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5));
    pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7));
    pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5));
    pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7));
    pool.addUnchecked(tx1->GetHash(), entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(tx2->GetHash(), entry.Fee(10000LL).FromTx(tx2));
    pool.addUnchecked(tx3->GetHash(), entry.Fee(10000LL).FromTx(tx3));
    pool.addUnchecked(tx4->GetHash(), entry.Fee(10000LL).FromTx(tx4));
        pool.addUnchecked(tyi->GetHash(), entry.Fee(10000LL).FromTx(tyi));
    pool.addUnchecked(ty6->GetHash(), entry.Fee(10000LL).FromTx(ty6));

identifier:testPool,addUnchecked,txParent,GetHash,entry,FromTx,txParent,testPool,addUnchecked,txParent,GetHash,entry,FromTx,txParent,testPool,addUnchecked,txChild,i,GetHash,entry,FromTx,txChild,i,testPool,addUnchecked,txGrandChild,i,GetHash,entry,FromTx,txGrandChild,i,testPool,addUnchecked,txChild,i,GetHash,entry,FromTx,txChild,i,testPool,addUnchecked,txGrandChild,i,GetHash,entry,FromTx,txGrandChild,i,pool,addUnchecked,tx1,GetHash,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,tx2,GetHash,entry,Fee,20000LL,FromTx,tx2,pool,addUnchecked,tx3,GetHash,entry,Fee,0LL,FromTx,tx3,pool,addUnchecked,tx4,GetHash,entry,Fee,15000LL,FromTx,tx4,pool,addUnchecked,tx5,GetHash,entry,Fee,10000LL,FromTx,tx5,pool,addUnchecked,tx6,GetHash,entry,Fee,0LL,FromTx,tx6,pool,addUnchecked,tx7,GetHash,entry,FromTx,tx7,setAncestors,pool,addUnchecked,tx8,GetHash,entry,Fee,0LL,Time,FromTx,tx8,setAncestors,pool,addUnchecked,tx9,GetHash,entry,Fee,0LL,Time,FromTx,tx9,setAncestors,pool,addUnchecked,tx10,GetHash,entry,FromTx,tx10,setAncestors,pool,addUnchecked,tx1,GetHash,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,tx2,GetHash,entry,Fee,20000LL,FromTx,tx2,pool,addUnchecked,tx3,GetHash,entry,Fee,0LL,FromTx,tx3,pool,addUnchecked,tx4,GetHash,entry,Fee,15000LL,FromTx,tx4,pool,addUnchecked,tx5,GetHash,entry,Fee,10000LL,FromTx,tx5,pool,addUnchecked,tx6,GetHash,entry,Fee,0LL,FromTx,tx6,pool,addUnchecked,tx7,GetHash,entry,Fee,fee,FromTx,tx7,pool,addUnchecked,tx8,GetHash,entry,Fee,5000LL,FromTx,tx8,pool,addUnchecked,tx1,GetHash,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,tx2,GetHash,entry,Fee,5000LL,FromTx,tx2,pool,addUnchecked,tx2,GetHash,entry,FromTx,tx2,pool,addUnchecked,tx3,GetHash,entry,Fee,20000LL,FromTx,tx3,pool,addUnchecked,tx4,GetHash,entry,Fee,7000LL,FromTx,tx4,pool,addUnchecked,tx5,GetHash,entry,Fee,1000LL,FromTx,tx5,pool,addUnchecked,tx6,GetHash,entry,Fee,1100LL,FromTx,tx6,pool,addUnchecked,tx7,GetHash,entry,Fee,9000LL,FromTx,tx7,pool,addUnchecked,tx5,GetHash,entry,Fee,1000LL,FromTx,tx5,pool,addUnchecked,tx7,GetHash,entry,Fee,9000LL,FromTx,tx7,pool,addUnchecked,tx5,GetHash,entry,Fee,1000LL,FromTx,tx5,pool,addUnchecked,tx7,GetHash,entry,Fee,9000LL,FromTx,tx7,pool,addUnchecked,tx1,GetHash,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,tx2,GetHash,entry,Fee,10000LL,FromTx,tx2,pool,addUnchecked,tx3,GetHash,entry,Fee,10000LL,FromTx,tx3,pool,addUnchecked,tx4,GetHash,entry,Fee,10000LL,FromTx,tx4,pool,addUnchecked,tyi,GetHash,entry,Fee,10000LL,FromTx,tyi,pool,addUnchecked,ty6,GetHash,entry,Fee,10000LL,FromTx,ty6,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    HasReason(const std::string& reason) : m_reason(reason) {}
static bool TestSequenceLocks(const CTransaction &tx, int flags)
    mempool.addUnchecked(hashParentTx, entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hashMediumFeeTx, entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hashHighFeeTx, entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(hashFreeTx, entry.Fee(0).FromTx(tx));
    size_t freeTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
    mempool.addUnchecked(hashLowFeeTx, entry.Fee(feeToUse).FromTx(tx));
    mempool.addUnchecked(hashLowFeeTx, entry.Fee(feeToUse+2).FromTx(tx));
    mempool.addUnchecked(hashFreeTx2, entry.Fee(0).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hashLowFeeTx2, entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(tx.GetHash(), entry.Fee(10000).FromTx(tx));
        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));
        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));
        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(hash, entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));
    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));
    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));

identifier:HasReason,reason,m_reason,reason,TestSequenceLocks,CTransaction,tx,flags,mempool,addUnchecked,hashParentTx,entry,Fee,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hashMediumFeeTx,entry,Fee,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hashHighFeeTx,entry,Fee,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hashFreeTx,entry,Fee,FromTx,tx,size_t,freeTxSize,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,mempool,addUnchecked,hashLowFeeTx,entry,Fee,feeToUse,FromTx,tx,mempool,addUnchecked,hashLowFeeTx,entry,Fee,feeToUse,FromTx,tx,mempool,addUnchecked,hashFreeTx2,entry,Fee,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hashLowFeeTx2,entry,Fee,feeToUse,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,tx,GetHash,entry,Fee,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,spendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,spendsCoinbase,SigOpsCost,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,spendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,HIGHERFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,hash,entry,Time,GetTime,FromTx,tx,mempool,addUnchecked,hash,entry,Time,GetTime,FromTx,tx,mempool,addUnchecked,hash,entry,Time,GetTime,FromTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception& e) {
    } catch (const std::exception& e) {

identifier:e,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/netbase_tests.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/policyestimator_tests.cpp
changed code snippet:
                mpool.addUnchecked(hash, entry.Fee(feeV[j]).Time(GetTime()).Height(blocknum).FromTx(tx));
                mpool.addUnchecked(hash, entry.Fee(feeV[j]).Time(GetTime()).Height(blocknum).FromTx(tx));
                mpool.addUnchecked(hash, entry.Fee(feeV[j]).Time(GetTime()).Height(blocknum).FromTx(tx));

identifier:mpool,addUnchecked,hash,entry,Fee,feeV,j,Time,GetTime,Height,blocknum,FromTx,tx,mpool,addUnchecked,hash,entry,Fee,feeV,j,Time,GetTime,Height,blocknum,FromTx,tx,mpool,addUnchecked,hash,entry,Fee,feeV,j,Time,GetTime,Height,blocknum,FromTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/scheduler_tests.cpp
changed code snippet:
    FastRandomContext rng(42);
            BOOST_CHECK_EQUAL(i, counter1++);
            BOOST_CHECK_EQUAL(i, counter2++);

identifier:FastRandomContext,rng,BOOST_CHECK_EQUAL,i,counter1,BOOST_CHECK_EQUAL,i,counter2,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/script_tests.cpp
changed code snippet:

#ifndef UPDATE_JSON_TESTS
        strGen += str + ",\n";

identifier:ifndef,UPDATE_JSON_TESTS,strGen,str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0, 0);
        size += ::GetSerializeSize(VARINT(i), 0, 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/streams_tests.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (std::string word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/txindex_tests.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, 0, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, 0, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (char opt : "abcdef")
    for (bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/validation_block_tests.cpp
changed code snippet:
    TestSubscriber(uint256 tip) : m_expected_tip(tip) {}

identifier:TestSubscriber,uint256,tip,m_expected_tip,tip,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
        std::unique_lock<std::mutex> lock(mut);
    std::unique_lock<std::mutex> lock(mut);

identifier:lock,mut,lock,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
    std::mutex mut;

identifier:mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (int64_t nOffset : vSorted)
            for (int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
                                 bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp):
    tx(_tx), nFee(_nFee), nTime(_nTime), entryHeight(_entryHeight),
    nTxWeight = GetTransactionWeight(*tx);
    nUsageSize = RecursiveDynamicUsage(tx);

            txiter piter = mapTx.find(tx.vin[i].prevout.hash);
            if (piter != mapTx.end()) {
                parentHashes.insert(piter);
        for (const txiter &phash : setMemPoolParents) {
void CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate)
    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(hash);
    if (pos != mapDeltas.end()) {
        const CAmount &delta = pos->second;
        if (delta) {
        }
    for (const uint256 &phash : setParentTransactions) {
        txiter pit = mapTx.find(phash);
        if (pit != mapTx.end()) {
        }
        for (const txiter &childiter : setChildren) {
        int64_t parentSizes = 0;
        int64_t parentSigOpCost = 0;
                if (setParentCheck.insert(it2).second) {
                    parentSizes += it2->GetTxSize();
                    parentSigOpCost += it2->GetSigOpCost();
                }
    for (const txiter& it : stage) {
void CTxMemPool::addUnchecked(const uint256&hash, const CTxMemPoolEntry &entry, bool validFeeEstimate)
    return addUnchecked(hash, entry, setAncestors, validFeeEstimate);

identifier:_spendsCoinbase,int64_t,_sigOpsCost,LockPoints,lp,tx,_tx,nFee,_nFee,nTime,_nTime,entryHeight,_entryHeight,nTxWeight,GetTransactionWeight,tx,nUsageSize,RecursiveDynamicUsage,tx,txiter,piter,mapTx,find,tx,vin,i,prevout,hash,piter,mapTx,end,parentHashes,insert,piter,txiter,phash,setMemPoolParents,CTxMemPool::addUnchecked,uint256,hash,CTxMemPoolEntry,entry,setEntries,setAncestors,validFeeEstimate,uint256,CAmount,const_iterator,pos,mapDeltas,find,hash,pos,mapDeltas,end,CAmount,delta,pos,second,delta,uint256,phash,setParentTransactions,txiter,pit,mapTx,find,phash,pit,mapTx,end,txiter,childiter,setChildren,int64_t,parentSizes,int64_t,parentSigOpCost,setParentCheck,insert,it2,second,parentSizes,it2,GetTxSize,parentSigOpCost,it2,GetSigOpCost,txiter,it,stage,CTxMemPool::addUnchecked,uint256,hash,CTxMemPoolEntry,entry,validFeeEstimate,addUnchecked,hash,entry,setAncestors,validFeeEstimate,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    CTransactionRef tx;
    CAmount nFee;              //!< Cached to avoid expensive parent-transaction lookups
    size_t nTxWeight;          //!< ... and avoid recomputing tx weight (also used for GetTxSize())
    size_t nUsageSize;         //!< ... and total memory usage
    int64_t nTime;             //!< Local time when entering the mempool
    unsigned int entryHeight;  //!< Chain height when entering the mempool
    bool spendsCoinbase;       //!< keep track of transactions that spend a coinbase
    int64_t sigOpCost;         //!< Total sigop cost
    void addUnchecked(const uint256& hash, const CTxMemPoolEntry& entry, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs);
    void addUnchecked(const uint256& hash, const CTxMemPoolEntry& entry, setEntries& setAncestors, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs);
    void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags);
public:
    bool exists(uint256 hash) const

identifier:CTransactionRef,tx,CAmount,nFee,size_t,nTxWeight,size_t,nUsageSize,int64_t,nTime,entryHeight,spendsCoinbase,int64_t,sigOpCost,addUnchecked,uint256,hash,CTxMemPoolEntry,entry,validFeeEstimate,EXCLUSIVE_LOCKS_REQUIRED,cs,addUnchecked,uint256,hash,CTxMemPoolEntry,entry,setEntries,setAncestors,validFeeEstimate,EXCLUSIVE_LOCKS_REQUIRED,cs,removeForReorg,CCoinsViewCache,pcoins,nMemPoolHeight,flags,public,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:
using namespace std;


identifier:using,namespace,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:
#include <utility>        // std::pair
    bool push_back(std::pair<std::string,UniValue> pear) {
        return pushKV(pear.first, pear.second);
    }
static inline std::pair<std::string,UniValue> Pair(const char *cKey, const char *cVal)
{
    std::string key(cKey);
    UniValue uVal(cVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, std::string strVal)
{
    std::string key(cKey);
    UniValue uVal(strVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, uint64_t u64Val)
{
    std::string key(cKey);
    UniValue uVal(u64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int64_t i64Val)
{
    std::string key(cKey);
    UniValue uVal(i64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, bool iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, double dVal)
{
    std::string key(cKey);
    UniValue uVal(dVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, const UniValue& uVal)
{
    std::string key(cKey);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(std::string key, const UniValue& uVal)
{
    return std::make_pair(key, uVal);
}


identifier:include,utility,push_back,UniValue,pear,pushKV,pear,first,pear,second,inline,UniValue,Pair,cKey,cVal,key,cKey,UniValue,uVal,cVal,key,uVal,inline,UniValue,Pair,cKey,strVal,key,cKey,UniValue,uVal,strVal,key,uVal,inline,UniValue,Pair,cKey,uint64_t,u64Val,key,cKey,UniValue,uVal,u64Val,key,uVal,inline,UniValue,Pair,cKey,int64_t,i64Val,key,cKey,UniValue,uVal,i64Val,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,dVal,key,cKey,UniValue,uVal,dVal,key,uVal,inline,UniValue,Pair,cKey,UniValue,uVal,key,cKey,key,uVal,inline,UniValue,Pair,key,UniValue,uVal,key,uVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
using namespace std;

static bool validNumStr(const string& s)
    string tokenVal;
bool UniValue::setNumStr(const string& val_)
    ostringstream oss;
    ostringstream oss;
    ostringstream oss;
bool UniValue::setStr(const string& val_)

identifier:using,namespace,validNumStr,s,tokenVal,UniValue::setNumStr,val_,ostringstream,oss,ostringstream,oss,ostringstream,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
using namespace std;

enum jtokentype getJsonToken(string& tokenVal, unsigned int& consumed,
        string numStr;
        string valStr;
    vector<UniValue*> stack;
    string tokenVal;

identifier:using,namespace,jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
using namespace std;

static string json_escape(const string& inS)
    string outS;
string UniValue::write(unsigned int prettyIndent,
                       unsigned int indentLevel) const
    string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, string& s) const

identifier:using,namespace,json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
using namespace std;
string srcdir(JSON_TEST_SRC);
static void runtest(string filename, const string& jdata)
        string prefix = filename.substr(0, 4);
        string basename(filename_);
        string filename = srcdir + "/" + basename;
        string jdata;
                string s(buf, bread);

identifier:using,namespace,srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#include <boost/interprocess/sync/file_lock.hpp>
static std::map<std::string, std::unique_ptr<boost::interprocess::file_lock>> dir_locks;

    try {
        auto lock = MakeUnique<boost::interprocess::file_lock>(pathLockFile.string().c_str());
        if (!lock->try_lock()) {
            return false;
        }
        if (!probe_only) {
            // Lock successful and we're not just probing, put it into the map
            dir_locks.emplace(pathLockFile.string(), std::move(lock));
        }
    } catch (const boost::interprocess::interprocess_exception& e) {
        return error("Error while attempting to lock directory %s: %s", directory.string(), e.what());
    static inline bool UseDefaultSection(const ArgsManager& am, const std::string& arg)
    static inline bool GetNetBoolArg(const ArgsManager &am, const std::string& net_arg)
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");
static std::vector<std::pair<std::string, std::string>> GetConfigOptions(std::istream& stream)
    std::vector<std::pair<std::string, std::string>> options;
    return options;

    for (const std::pair<std::string, std::string>& option : GetConfigOptions(stream)) {
        if (m_override_args.count("-includeconf") == 0) {
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),
    char pszPath[MAX_PATH] = "";
    if(SHGetSpecialFolderPathA(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathA() failed, could not obtain requested path.\n");
int ScheduleBatchPriority(void)

identifier:include,boost,interprocess,sync,file_lock,hpp,boost::interprocess::file_lock,dir_locks,lock,MakeUnique,boost::interprocess::file_lock,pathLockFile,c_str,lock,try_lock,probe_only,dir_locks,emplace,pathLockFile,lock,boost::interprocess::interprocess_exception,e,error,directory,e,what,inline,UseDefaultSection,ArgsManager,am,arg,inline,GetNetBoolArg,ArgsManager,am,net_arg,args,IsArgSet,args,IsArgSet,args,IsArgSet,GetConfigOptions,stream,options,options,option,GetConfigOptions,stream,m_override_args,count,MoveFileExA,src,c_str,dest,c_str,pszPath,MAX_PATH,SHGetSpecialFolderPathA,nullptr,pszPath,nFolder,fCreate,LogPrintf,ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
    std::map<std::string, std::vector<std::string>> m_override_args;
    std::map<std::string, std::vector<std::string>> m_config_args;
    std::string m_network;
    std::set<std::string> m_network_only_args;
    std::map<OptionsCategory, std::map<std::string, Arg>> m_available_args;
    void ClearArgs() { m_available_args.clear(); }
int ScheduleBatchPriority(void);

identifier:m_override_args,m_config_args,m_network,m_network_only_args,OptionsCategory,Arg,m_available_args,ClearArgs,m_available_args,clear,ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (auto c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
                    CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false);
    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace);
    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool);
    void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state);
CWaitableCriticalSection g_best_block_mutex;
CConditionVariable g_best_block_cv;
            for (int height : prevheights) {
static bool IsCurrentForFeeEstimation()
static void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool fAddToMempool)
                 unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) {
                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept)
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        auto itConflicting = pool.mapNextTx.find(txin.prevout);
        if (itConflicting != pool.mapNextTx.end())
        {
            const CTransaction *ptxConflicting = itConflicting->second;
            CTxMemPool::setEntries setIterConflicting;
            for (const uint256 &hashConflicting : setConflicts)
            {
                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);
                if (mi == pool.mapTx.end())
                    continue;

                // Save these to avoid repeated lookups
                setIterConflicting.insert(mi);

                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())
        pool.addUnchecked(hash, entry, setAncestors, validForFeeEstimation);
                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept)
    unsigned int nSize = GetSerializeSize(fileout, block);
static void CheckForkWarningConditions()
static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)
void static InvalidChainFound(CBlockIndex* pindexNew)
bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)
    unsigned int nSize = GetSerializeSize(fileout, blockundo);
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))
static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) {
        WaitableLock lock(g_best_block_mutex);
            return error("ConnectTip(): ConnectBlock %s failed", pindexNew->GetBlockHash().ToString());
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
        if (!CheckTransaction(*tx, state, false))
    unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);
    for (BlockMap::value_type& entry : mapBlockIndex) {
    for (auto& entry : mapBlockIndex) {
bool LoadMempool(void)
bool DumpMempool(void)

identifier:CCoinsViewCache,view,CChainParams,chainparams,fJustCheck,ActivateBestChainStep,CValidationState,state,CChainParams,chainparams,CBlockIndex,pindexMostWork,CBlock,pblock,fInvalidFound,ConnectTrace,connectTrace,ConnectTip,CValidationState,state,CChainParams,chainparams,CBlockIndex,pindexNew,CBlock,pblock,ConnectTrace,connectTrace,DisconnectedBlockTransactions,disconnectpool,InvalidBlockFound,CBlockIndex,pindex,CValidationState,state,CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,height,prevheights,IsCurrentForFeeEstimation,UpdateMempoolForReorg,DisconnectedBlockTransactions,disconnectpool,fAddToMempool,flags,cacheSigStore,PrecomputedTransactionData,txdata,bypass_limits,CAmount,nAbsurdFee,COutPoint,coins_to_uncache,test_accept,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,itConflicting,pool,mapNextTx,find,txin,prevout,itConflicting,pool,mapNextTx,end,CTransaction,ptxConflicting,itConflicting,second,CTxMemPool::setEntries,setIterConflicting,uint256,hashConflicting,setConflicts,CTxMemPool::txiter,mi,pool,mapTx,find,hashConflicting,mi,pool,mapTx,end,setIterConflicting,insert,mi,pool,mapTx,find,tx,vin,j,prevout,hash,pool,mapTx,end,pool,addUnchecked,hash,entry,setAncestors,validForFeeEstimation,bypass_limits,CAmount,nAbsurdFee,test_accept,nSize,GetSerializeSize,fileout,block,CheckForkWarningConditions,CheckForkWarningConditionsOnNewFork,CBlockIndex,pindexNewForkTip,InvalidChainFound,CBlockIndex,pindexNew,CheckInputs,CTransaction,tx,CValidationState,state,CCoinsViewCache,inputs,fScriptChecks,flags,cacheSigStore,cacheFullScriptStore,PrecomputedTransactionData,txdata,CScriptCheck,pvChecks,nSize,GetSerializeSize,fileout,blockundo,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,SER_DISK,CLIENT_VERSION,GetBlockScriptFlags,CBlockIndex,pindex,Consensus::Params,consensusparams,WaitableLock,lock,g_best_block_mutex,error,pindexNew,GetBlockHash,ToString,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,CheckTransaction,tx,state,nBlockSize,GetSerializeSize,block,SER_DISK,CLIENT_VERSION,BlockMap::value_type,entry,mapBlockIndex,entry,mapBlockIndex,LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN;
extern CWaitableCriticalSection g_best_block_mutex;
extern CConditionVariable g_best_block_cv;
                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false);
bool CheckFinalTx(const CTransaction &tx, int flags = -1);
bool TestLockPointValidity(const LockPoints* lp);
bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false);

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,bypass_limits,CAmount,nAbsurdFee,test_accept,CheckFinalTx,CTransaction,tx,flags,TestLockPointValidity,LockPoints,lp,CheckSequenceLocks,CTransaction,tx,flags,LockPoints,lp,nullptr,useExistingLockPoints,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validationinterface.cpp
changed code snippet:
#include <sync.h>

identifier:include,sync,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validationinterface.h
changed code snippet:
void SyncWithValidationInterfaceQueue();

identifier:SyncWithValidationInterfaceQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An ununsed temporary BerkeleyEnvironment object may be created inside the
            for (auto& env : g_dbenvs) {
                g_dbenvs.erase(strPath);
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), e.what());
        if (shutdown) env = nullptr;

identifier:env,g_dbenvs,g_dbenvs,erase,strPath,LogPrintf,strFile,pathDest,e,what,shutdown,env,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/feebumper.cpp
changed code snippet:
static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet)
    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, oldWtx.strFromAccount, reservekey, g_connman.get(), state)) {

identifier:feebumper::Result,PreconditionChecks,CWallet,wallet,CWalletTx,wtx,errors,EXCLUSIVE_LOCKS_REQUIRED,wallet,cs_wallet,wallet,CommitTransaction,tx,mapValue,oldWtx,vOrderForm,oldWtx,strFromAccount,reservekey,g_connman,get,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
                               " (1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)", false, OptionsCategory::WALLET);

identifier:OptionsCategory::WALLET,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (unsigned char c : str) {
        // Not having Internal + Script
        if (!internal && isScript) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set for hex scriptPubKey");
        }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (scriptPubKey.getType() == UniValue::VOBJ) {
                    // add to address book or update label
                    if (IsValidDestination(dest)) {
                        pwallet->SetAddressBook(dest, label, "receive");
                    }
            "      \"label\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\n"

identifier:c,str,internal,isScript,throw,JSONRPCError,RPC_INVALID_PARAMETER,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,scriptPubKey,getType,UniValue::VOBJ,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
static void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)
CTxDestination GetLabelDestination(CWallet* const pwallet, const std::string& label, bool bForceNew=false)
{
    CTxDestination dest;
    if (!pwallet->GetLabelDestination(dest, label, bForceNew)) {
        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, "Error: Keypool ran out, please call keypoolrefill first");
    }

    return dest;
}

static UniValue getaccountaddress(const JSONRPCRequest& request)
{
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();

    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
        return NullUniValue;
    }

    if (!IsDeprecatedRPCEnabled("accounts")) {
        if (request.fHelp) {
            throw std::runtime_error("getaccountaddress (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "getaccountaddress is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaccountaddress \"account\"\n"
            "\n\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\n"
            "\nArguments:\n"
            "1. \"account\"       (string, required) The account for the address. It can also be set to the empty string \"\" to represent the default account. The account does not need to exist, it will be created and a new address created  if there is no account by the given name.\n"
            "\nResult:\n"
            "\"address\"          (string) The account bitcoin address\n"
            "\nExamples:\n"
            + HelpExampleCli("getaccountaddress", "")
            + HelpExampleCli("getaccountaddress", "\"\"")
            + HelpExampleCli("getaccountaddress", "\"myaccount\"")
            + HelpExampleRpc("getaccountaddress", "\"myaccount\"")
        );

    LOCK2(cs_main, pwallet->cs_wallet);

    // Parse the account first so we don't generate a key if there's an error
    std::string account = LabelFromValue(request.params[0]);

    UniValue ret(UniValue::VSTR);

    ret = EncodeDestination(GetLabelDestination(pwallet, account));
    return ret;
}


    if (!IsDeprecatedRPCEnabled("accounts") && request.strMethod == "setaccount") {
        if (request.fHelp) {
            throw std::runtime_error("setaccount (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "setaccount is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

    std::string old_label = pwallet->mapAddressBook[dest].name;
        if (request.strMethod == "setaccount" && old_label != label && dest == GetLabelDestination(pwallet, old_label)) {
            // for setaccount, call GetLabelDestination so a new receive address is created for the old account
            GetLabelDestination(pwallet, old_label, true);
        }
    // Detect when there are no addresses using this label.
    // If so, delete the account record for it. Labels, unlike addresses, can be deleted,
    // and if we wouldn't do this, the record would stick around forever.
    bool found_address = false;
    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {
        if (item.second.name == label) {
            found_address = true;
            break;
        }
    }
    if (!found_address) {
        pwallet->DeleteLabel(old_label);
    }

static UniValue getaccount(const JSONRPCRequest& request)
{
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();

    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
        return NullUniValue;
    }

    if (!IsDeprecatedRPCEnabled("accounts")) {
        if (request.fHelp) {
            throw std::runtime_error("getaccount (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "getaccount is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaccount \"address\"\n"
            "\nDEPRECATED. Returns the account associated with the given address.\n"
            "\nArguments:\n"
            "1. \"address\"         (string, required) The bitcoin address for account lookup.\n"
            "\nResult:\n"
            "\"accountname\"        (string) the account address\n"
            "\nExamples:\n"
            + HelpExampleCli("getaccount", "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\"")
            + HelpExampleRpc("getaccount", "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\"")
        );

    LOCK2(cs_main, pwallet->cs_wallet);

    CTxDestination dest = DecodeDestination(request.params[0].get_str());
    if (!IsValidDestination(dest)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Bitcoin address");
    }

    std::string strAccount;
    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(dest);
    if (mi != pwallet->mapAddressBook.end() && !(*mi).second.name.empty()) {
        strAccount = (*mi).second.name;
    }
    return strAccount;
}


static UniValue getaddressesbyaccount(const JSONRPCRequest& request)
{
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();

    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
        return NullUniValue;
    }

    if (!IsDeprecatedRPCEnabled("accounts")) {
        if (request.fHelp) {
            throw std::runtime_error("getaddressbyaccount (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "getaddressesbyaccount is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaddressesbyaccount \"account\"\n"
            "\nDEPRECATED. Returns the list of addresses for the given account.\n"
            "\nArguments:\n"
            "1. \"account\"        (string, required) The account name.\n"
            "\nResult:\n"
            "[                     (json array of string)\n"
            "  \"address\"         (string) a bitcoin address associated with the given account\n"
            "  ,...\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getaddressesbyaccount", "\"tabby\"")
            + HelpExampleRpc("getaddressesbyaccount", "\"tabby\"")
        );

    LOCK2(cs_main, pwallet->cs_wallet);

    std::string strAccount = LabelFromValue(request.params[0]);

    // Find all addresses that have the given account
    UniValue ret(UniValue::VARR);
    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {
        const CTxDestination& dest = item.first;
        const std::string& strName = item.second.name;
        if (strName == strAccount) {
            ret.push_back(EncodeDestination(dest));
        }
    }
    return ret;
}

static CTransactionRef SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue, std::string fromAccount)
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, std::move(fromAccount), reservekey, g_connman.get(), state)) {
    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue), {} /* fromAccount */);
    if (!IsDeprecatedRPCEnabled("accounts") && request.strMethod == "getreceivedbyaccount") {
        if (request.fHelp) {
            throw std::runtime_error("getreceivedbyaccount (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "getreceivedbyaccount is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

           (IsDeprecatedRPCEnabled("accounts") ? std::string(
            "getbalance ( \"account\" minconf include_watchonly )\n"
            "\nIf account is not specified, returns the server's total available balance.\n"
            "The available balance is what the wallet considers currently spendable, and is\n"
            "thus affected by options which limit spendability such as -spendzeroconfchange.\n"
            "If account is specified (DEPRECATED), returns the balance in the account.\n"
            "Note that the account \"\" is not the same as leaving the parameter out.\n"
            "The server total may be different to the balance in the default \"\" account.\n"
            "\nArguments:\n"
            "1. \"account\"         (string, optional) DEPRECATED. This argument will be removed in V0.18. \n"
            "                     To use this deprecated argument, start bitcoind with -deprecatedrpc=accounts. The account string may be given as a\n"
            "                     specific account name to find the balance associated with wallet keys in\n"
            "                     a named account, or as the empty string (\"\") to find the balance\n"
            "                     associated with wallet keys not in any named account, or as \"*\" to find\n"
            "                     the balance associated with all wallet keys regardless of account.\n"
            "                     When this option is specified, it calculates the balance in a different\n"
            "                     way than when it is not specified, and which can count spends twice when\n"
            "                     there are conflicting pending transactions (such as those created by\n"
            "                     the bumpfee command), temporarily resulting in low or even negative\n"
            "                     balances. In general, account balance calculation is not considered\n"
            "                     reliable and has resulted in confusing outcomes, so it is recommended to\n"
            "                     avoid passing this argument.\n"
            "2. minconf           (numeric, optional) Only include transactions confirmed at least this many times. \n"
            "                     The default is 1 if an account is provided or 0 if no account is provided\n")
            : std::string(
            "2. minconf           (numeric, optional, default=0) Only include transactions confirmed at least this many times.\n")) +
            "amount              (numeric) The total amount in " + CURRENCY_UNIT + " received for this account.\n"
    const UniValue& account_value = request.params[0];
    if (IsDeprecatedRPCEnabled("accounts") && !account_value.isNull()) {
        // Default min_depth to 1 when an account is provided.
        min_depth = 1;
    }
    if (!account_value.isNull()) {

        const std::string& account_param = account_value.get_str();
        const std::string* account = account_param != "*" ? &account_param : nullptr;

        if (!IsDeprecatedRPCEnabled("accounts") && account_param != "*") {
            throw JSONRPCError(RPC_METHOD_DEPRECATED, "dummy first argument must be excluded or set to \"*\".");
        } else if (IsDeprecatedRPCEnabled("accounts")) {
            return ValueFromAmount(pwallet->GetLegacyBalance(filter, min_depth, account));
        }
    }

static UniValue movecmd(const JSONRPCRequest& request)
{
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();

    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
        return NullUniValue;
    }

    if (!IsDeprecatedRPCEnabled("accounts")) {
        if (request.fHelp) {
            throw std::runtime_error("move (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "move is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

    if (request.fHelp || request.params.size() < 3 || request.params.size() > 5)
        throw std::runtime_error(
            "move \"fromaccount\" \"toaccount\" amount ( minconf \"comment\" )\n"
            "\nDEPRECATED. Move a specified amount from one account in your wallet to another.\n"
            "\nArguments:\n"
            "1. \"fromaccount\"   (string, required) The name of the account to move funds from. May be the default account using \"\".\n"
            "2. \"toaccount\"     (string, required) The name of the account to move funds to. May be the default account using \"\".\n"
            "3. amount            (numeric) Quantity of " + CURRENCY_UNIT + " to move between accounts.\n"
            "4. (dummy)           (numeric, optional) Ignored. Remains for backward compatibility.\n"
            "5. \"comment\"       (string, optional) An optional comment, stored in the wallet only.\n"
            "\nResult:\n"
            "true|false           (boolean) true if successful.\n"
            "\nExamples:\n"
            "\nMove 0.01 " + CURRENCY_UNIT + " from the default account to the account named tabby\n"
            + HelpExampleCli("move", "\"\" \"tabby\" 0.01") +
            "\nMove 0.01 " + CURRENCY_UNIT + " timotei to akiko with a comment and funds have 6 confirmations\n"
            + HelpExampleCli("move", "\"timotei\" \"akiko\" 0.01 6 \"happy birthday!\"") +
            "\nAs a json rpc call\n"
            + HelpExampleRpc("move", "\"timotei\", \"akiko\", 0.01, 6, \"happy birthday!\"")
        );

    LOCK2(cs_main, pwallet->cs_wallet);

    std::string strFrom = LabelFromValue(request.params[0]);
    std::string strTo = LabelFromValue(request.params[1]);
    CAmount nAmount = AmountFromValue(request.params[2]);
    if (nAmount <= 0)
        throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
    if (!request.params[3].isNull())
        // unused parameter, used to be nMinDepth, keep type-checking it though
        (void)request.params[3].get_int();
    std::string strComment;
    if (!request.params[4].isNull())
        strComment = request.params[4].get_str();

    if (!pwallet->AccountMove(strFrom, strTo, nAmount, strComment)) {
        throw JSONRPCError(RPC_DATABASE_ERROR, "database error");
    }

    return true;
}


static UniValue sendfrom(const JSONRPCRequest& request)
{
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();

    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
        return NullUniValue;
    }

    if (!IsDeprecatedRPCEnabled("accounts")) {
        if (request.fHelp) {
            throw std::runtime_error("sendfrom (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "sendfrom is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }


    if (request.fHelp || request.params.size() < 3 || request.params.size() > 6)
        throw std::runtime_error(
            "sendfrom \"fromaccount\" \"toaddress\" amount ( minconf \"comment\" \"comment_to\" )\n"
            "\nDEPRECATED (use sendtoaddress). Sent an amount from an account to a bitcoin address."
            + HelpRequiringPassphrase(pwallet) + "\n"
            "\nArguments:\n"
            "1. \"fromaccount\"       (string, required) The name of the account to send funds from. May be the default account using \"\".\n"
            "                       Specifying an account does not influence coin selection, but it does associate the newly created\n"
            "                       transaction with the account, so the account's balance computation and transaction history can reflect\n"
            "                       the spend.\n"
            "2. \"toaddress\"         (string, required) The bitcoin address to send funds to.\n"
            "3. amount                (numeric or string, required) The amount in " + CURRENCY_UNIT + " (transaction fee is added on top).\n"
            "4. minconf               (numeric, optional, default=1) Only use funds with at least this many confirmations.\n"
            "5. \"comment\"           (string, optional) A comment used to store what the transaction is for. \n"
            "                                     This is not part of the transaction, just kept in your wallet.\n"
            "6. \"comment_to\"        (string, optional) An optional comment to store the name of the person or organization \n"
            "                                     to which you're sending the transaction. This is not part of the transaction, \n"
            "                                     it is just kept in your wallet.\n"
            "\nResult:\n"
            "\"txid\"                 (string) The transaction id.\n"
            "\nExamples:\n"
            "\nSend 0.01 " + CURRENCY_UNIT + " from the default account to the address, must have at least 1 confirmation\n"
            + HelpExampleCli("sendfrom", "\"\" \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.01") +
            "\nSend 0.01 from the tabby account to the given address, funds must have at least 6 confirmations\n"
            + HelpExampleCli("sendfrom", "\"tabby\" \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" 0.01 6 \"donation\" \"seans outpost\"") +
            "\nAs a json rpc call\n"
            + HelpExampleRpc("sendfrom", "\"tabby\", \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\", 0.01, 6, \"donation\", \"seans outpost\"")
        );

    // Make sure the results are valid at least up to the most recent block
    // the user could have gotten from another RPC command prior to now
    pwallet->BlockUntilSyncedToCurrentChain();

    LOCK2(cs_main, pwallet->cs_wallet);

    std::string strAccount = LabelFromValue(request.params[0]);
    CTxDestination dest = DecodeDestination(request.params[1].get_str());
    if (!IsValidDestination(dest)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid Bitcoin address");
    }
    CAmount nAmount = AmountFromValue(request.params[2]);
    if (nAmount <= 0)
        throw JSONRPCError(RPC_TYPE_ERROR, "Invalid amount for send");
    int nMinDepth = 1;
    if (!request.params[3].isNull())
        nMinDepth = request.params[3].get_int();

    mapValue_t mapValue;
    if (!request.params[4].isNull() && !request.params[4].get_str().empty())
        mapValue["comment"] = request.params[4].get_str();
    if (!request.params[5].isNull() && !request.params[5].get_str().empty())
        mapValue["to"] = request.params[5].get_str();

    EnsureWalletIsUnlocked(pwallet);

    // Check funds
    CAmount nBalance = pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount);
    if (nAmount > nBalance)
        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Account has insufficient funds");

    CCoinControl no_coin_control; // This is a deprecated API
    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, false, no_coin_control, std::move(mapValue), std::move(strAccount));
    return tx->GetHash().GetHex();
}


    std::string help_text;
    if (!IsDeprecatedRPCEnabled("accounts")) {
        help_text = "sendmany \"\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] replaceable conf_target \"estimate_mode\")\n"
            "Note that the \"fromaccount\" argument has been removed in V0.17. To use this RPC with a \"fromaccount\" argument, restart\n"
            "bitcoind with -deprecatedrpc=accounts\n"
            + HelpExampleRpc("sendmany", "\"\", {\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\":0.01,\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\":0.02}, 6, \"testing\"");
    } else {
        help_text = "sendmany \"\" \"fromaccount\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] replaceable conf_target \"estimate_mode\")\n"
            "\nSend multiple times. Amounts are double-precision floating point numbers."
            + HelpRequiringPassphrase(pwallet) + "\n"
            "\nArguments:\n"
            "1. \"fromaccount\"         (string, required) DEPRECATED. The account to send the funds from. Should be \"\" for the default account\n"
            "2. \"amounts\"             (string, required) A json object with addresses and amounts\n"
            "    {\n"
            "      \"address\":amount   (numeric or string) The bitcoin address is the key, the numeric amount (can be string) in " + CURRENCY_UNIT + " is the value\n"
            "      ,...\n"
            "    }\n"
            "3. minconf                 (numeric, optional, default=1) Only use the balance confirmed at least this many times.\n"
            "4. \"comment\"             (string, optional) A comment\n"
            "5. subtractfeefrom         (array, optional) A json array with addresses.\n"
            "                           The fee will be equally deducted from the amount of each selected address.\n"
            "                           Those recipients will receive less bitcoins than you enter in their corresponding amount field.\n"
            "                           If no addresses are specified here, the sender pays the fee.\n"
            "    [\n"
            "      \"address\"          (string) Subtract fee from this address\n"
            "      ,...\n"
            "    ]\n"
            "6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125\n"
            "7. conf_target            (numeric, optional) Confirmation target (in blocks)\n"
            "8. \"estimate_mode\"      (string, optional, default=UNSET) The fee estimate mode, must be one of:\n"
            "       \"UNSET\"\n"
            "       \"ECONOMICAL\"\n"
            "       \"CONSERVATIVE\"\n"
             "\nResult:\n"
            "\"txid\"                   (string) The transaction id for the send. Only 1 transaction is created regardless of \n"
            "                                    the number of addresses.\n"
            "\nExamples:\n"
            "\nSend two amounts to two different addresses:\n"
            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\"") +
            "\nSend two amounts to two different addresses setting the confirmation and comment:\n"
            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\" 6 \"testing\"") +
            "\nSend two amounts to two different addresses, subtract fee from amount:\n"
            + HelpExampleCli("sendmany", "\"\" \"{\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\":0.01,\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\":0.02}\" 1 \"\" \"[\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\\\",\\\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\\\"]\"") +
            "\nAs a json rpc call\n"
            + HelpExampleRpc("sendmany", "\"\", {\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\":0.01,\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\":0.02}, 6, \"testing\"");
    }

    if (request.fHelp || request.params.size() < 2 || request.params.size() > 8) throw std::runtime_error(help_text);
    if (!IsDeprecatedRPCEnabled("accounts") && !request.params[0].get_str().empty()) {
    std::string strAccount = LabelFromValue(request.params[0]);
    if (IsDeprecatedRPCEnabled("accounts") && totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, &strAccount)) {
        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, "Account has insufficient funds");
    } else if (!IsDeprecatedRPCEnabled("accounts") && totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, nullptr)) {
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, std::move(strAccount), keyChange, g_connman.get(), state)) {
static UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool by_label)
            obj.pushKV("account",       label);
            obj.pushKV("account",       entry.first);
            "    \"account\" : \"accountname\",       (string) DEPRECATED. Backwards compatible alias for label.\n"
    if (!IsDeprecatedRPCEnabled("accounts") && request.strMethod == "listreceivedbyaccount") {
        if (request.fHelp) {
            throw std::runtime_error("listreceivedbyaccount (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "listreceivedbyaccount is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

            "    \"account\" : \"accountname\",  (string) DEPRECATED. Backwards compatible alias for label.\n"
 * @param  strAccount The account, if any, or "*" for all.
static void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, const std::string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)
    std::string strSentAccount;
    wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, filter);
    bool fAllAccounts = (strAccount == std::string("*"));
    if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))
            if (IsDeprecatedRPCEnabled("accounts")) entry.pushKV("account", strSentAccount);
            std::string account;
                account = pwallet->mapAddressBook[r.destination].name;
            if (fAllAccounts || (account == strAccount))
                UniValue entry(UniValue::VOBJ);
                if (involvesWatchonly || (::IsMine(*pwallet, r.destination) & ISMINE_WATCH_ONLY)) {
                    entry.pushKV("involvesWatchonly", true);
                }
                if (IsDeprecatedRPCEnabled("accounts")) entry.pushKV("account", account);
                MaybePushAddress(entry, r.destination);
                if (wtx.IsCoinBase())
                {
                    if (wtx.GetDepthInMainChain() < 1)
                        entry.pushKV("category", "orphan");
                    else if (wtx.IsImmatureCoinBase())
                        entry.pushKV("category", "immature");
                    else
                        entry.pushKV("category", "generate");
                }
                {
                    entry.pushKV("category", "receive");
                }
                entry.pushKV("amount", ValueFromAmount(r.amount));
                if (pwallet->mapAddressBook.count(r.destination)) {
                    entry.pushKV("label", account);
                }
                entry.pushKV("vout", r.vout);
                if (fLong)
                    WalletTxToJSON(wtx, entry);
                ret.push_back(entry);
static void AcentryToJSON(const CAccountingEntry& acentry, const std::string& strAccount, UniValue& ret)
{
    bool fAllAccounts = (strAccount == std::string("*"));

    if (fAllAccounts || acentry.strAccount == strAccount)
    {
        UniValue entry(UniValue::VOBJ);
        entry.pushKV("account", acentry.strAccount);
        entry.pushKV("category", "move");
        entry.pushKV("time", acentry.nTime);
        entry.pushKV("amount", ValueFromAmount(acentry.nCreditDebit));
        if (IsDeprecatedRPCEnabled("accounts")) entry.pushKV("otheraccount", acentry.strOtherAccount);
        entry.pushKV("comment", acentry.strComment);
        ret.push_back(entry);
    }
}

    std::string help_text {};
    if (!IsDeprecatedRPCEnabled("accounts")) {
        help_text = "listtransactions (dummy count skip include_watchonly)\n"
            "\nReturns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.\n"
            "Note that the \"account\" argument and \"otheraccount\" return value have been removed in V0.17. To use this RPC with an \"account\" argument, restart\n"
            "bitcoind with -deprecatedrpc=accounts\n"
            + HelpExampleRpc("listtransactions", "\"*\", 20, 100");
    } else {
        help_text = "listtransactions ( \"account\" count skip include_watchonly)\n"
            "\nReturns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.\n"
            "\nArguments:\n"
            "1. \"account\"    (string, optional) DEPRECATED. This argument will be removed in V0.18. The account name. Should be \"*\".\n"
            "2. count          (numeric, optional, default=10) The number of transactions to return\n"
            "3. skip           (numeric, optional, default=0) The number of transactions to skip\n"
            "4. include_watchonly (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"account\":\"accountname\",       (string) DEPRECATED. This field will be removed in V0.18. The account name associated with the transaction. \n"
            "                                                It will be \"\" for the default account.\n"
            "    \"address\":\"address\",    (string) The bitcoin address of the transaction. Not present for \n"
            "                                                move transactions (category = move).\n"
            "    \"category\":\"send|receive|move\", (string) The transaction category. 'move' is a local (off blockchain)\n"
            "                                                transaction between accounts, and not associated with an address,\n"
            "                                                transaction id or block. 'send' and 'receive' transactions are \n"
            "                                                associated with an address, transaction id and block details\n"
            "    \"amount\": x.xxx,          (numeric) The amount in " + CURRENCY_UNIT + ". This is negative for the 'send' category, and for the\n"
            "                                         'move' category for moves outbound. It is positive for the 'receive' category,\n"
            "                                         and for the 'move' category for inbound funds.\n"
            "    \"label\": \"label\",       (string) A comment for the address/transaction, if any\n"
            "    \"vout\": n,                (numeric) the vout value\n"
            "    \"fee\": x.xxx,             (numeric) The amount of the fee in " + CURRENCY_UNIT + ". This is negative and only available for the \n"
            "                                         'send' category of transactions.\n"
            "    \"confirmations\": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and \n"
            "                                         'receive' category of transactions. Negative confirmations indicate the\n"
            "                                         transaction conflicts with the block chain\n"
            "    \"trusted\": xxx,           (bool) Whether we consider the outputs of this unconfirmed transaction safe to spend.\n"
            "    \"blockhash\": \"hashvalue\", (string) The block hash containing the transaction. Available for 'send' and 'receive'\n"
            "                                          category of transactions.\n"
            "    \"blockindex\": n,          (numeric) The index of the transaction in the block that includes it. Available for 'send' and 'receive'\n"
            "                                          category of transactions.\n"
            "    \"blocktime\": xxx,         (numeric) The block time in seconds since epoch (1 Jan 1970 GMT).\n"
            "    \"txid\": \"transactionid\", (string) The transaction id. Available for 'send' and 'receive' category of transactions.\n"
            "    \"time\": xxx,              (numeric) The transaction time in seconds since epoch (midnight Jan 1 1970 GMT).\n"
            "    \"timereceived\": xxx,      (numeric) The time received in seconds since epoch (midnight Jan 1 1970 GMT). Available \n"
            "                                          for 'send' and 'receive' category of transactions.\n"
            "    \"comment\": \"...\",       (string) If a comment is associated with the transaction.\n"
            "    \"otheraccount\": \"accountname\",  (string) DEPRECATED. This field will be removed in V0.18. For the 'move' category of transactions, the account the funds came \n"
            "                                          from (for receiving funds, positive amounts), or went to (for sending funds,\n"
            "                                          negative amounts).\n"
            "    \"bip125-replaceable\": \"yes|no|unknown\",  (string) Whether this transaction could be replaced due to BIP125 (replace-by-fee);\n"
            "                                                     may be unknown for unconfirmed transactions not in the mempool\n"
            "    \"abandoned\": xxx          (bool) 'true' if the transaction has been abandoned (inputs are respendable). Only available for the \n"
            "                                         'send' category of transactions.\n"
            "  }\n"
            "]\n"

            "\nExamples:\n"
            "\nList the most recent 10 transactions in the systems\n"
            + HelpExampleCli("listtransactions", "") +
            "\nList transactions 100 to 120\n"
            + HelpExampleCli("listtransactions", "\"*\" 20 100") +
            "\nAs a json rpc call\n"
            + HelpExampleRpc("listtransactions", "\"*\", 20, 100");
    }
    if (request.fHelp || request.params.size() > 4) throw std::runtime_error(help_text);
    std::string strAccount = "*";
    if (!request.params[0].isNull()) {
        strAccount = request.params[0].get_str();
        if (!IsDeprecatedRPCEnabled("accounts") && strAccount != "*") {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Dummy value must be set to \"*\"");
        }
            CWalletTx *const pwtx = (*it).second.first;
            if (pwtx != nullptr)
                ListTransactions(pwallet, *pwtx, strAccount, 0, true, ret, filter);
            if (IsDeprecatedRPCEnabled("accounts")) {
                CAccountingEntry *const pacentry = (*it).second.second;
                if (pacentry != nullptr) AcentryToJSON(*pacentry, strAccount, ret);
            }

static UniValue listaccounts(const JSONRPCRequest& request)
{
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();

    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {
        return NullUniValue;
    }

    if (!IsDeprecatedRPCEnabled("accounts")) {
        if (request.fHelp) {
            throw std::runtime_error("listaccounts (Deprecated, will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts)");
        }
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "listaccounts is deprecated and will be removed in V0.18. To use this command, start bitcoind with -deprecatedrpc=accounts.");
    }

    if (request.fHelp || request.params.size() > 2)
        throw std::runtime_error(
            "listaccounts ( minconf include_watchonly)\n"
            "\nDEPRECATED. Returns Object that has account names as keys, account balances as values.\n"
            "\nArguments:\n"
            "1. minconf             (numeric, optional, default=1) Only include transactions with at least this many confirmations\n"
            "2. include_watchonly   (bool, optional, default=false) Include balances in watch-only addresses (see 'importaddress')\n"
            "\nResult:\n"
            "{                      (json object where keys are account names, and values are numeric balances\n"
            "  \"account\": x.xxx,  (numeric) The property name is the account name, and the value is the total balance for the account.\n"
            "  ...\n"
            "}\n"
            "\nExamples:\n"
            "\nList account balances where there at least 1 confirmation\n"
            + HelpExampleCli("listaccounts", "") +
            "\nList account balances including zero confirmation transactions\n"
            + HelpExampleCli("listaccounts", "0") +
            "\nList account balances for 6 or more confirmations\n"
            + HelpExampleCli("listaccounts", "6") +
            "\nAs json rpc call\n"
            + HelpExampleRpc("listaccounts", "6")
        );

    // Make sure the results are valid at least up to the most recent block
    // the user could have gotten from another RPC command prior to now
    pwallet->BlockUntilSyncedToCurrentChain();

    LOCK2(cs_main, pwallet->cs_wallet);

    int nMinDepth = 1;
    if (!request.params[0].isNull())
        nMinDepth = request.params[0].get_int();
    isminefilter includeWatchonly = ISMINE_SPENDABLE;
    if(!request.params[1].isNull())
        if(request.params[1].get_bool())
            includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;

    std::map<std::string, CAmount> mapAccountBalances;
    for (const std::pair<const CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {
        if (IsMine(*pwallet, entry.first) & includeWatchonly) {  // This address belongs to me
            mapAccountBalances[entry.second.name] = 0;
        }
    }

    for (const std::pair<const uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {
        const CWalletTx& wtx = pairWtx.second;
        CAmount nFee;
        std::string strSentAccount;
        std::list<COutputEntry> listReceived;
        std::list<COutputEntry> listSent;
        int nDepth = wtx.GetDepthInMainChain();
        if (wtx.IsImmatureCoinBase() || nDepth < 0)
            continue;
        wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, includeWatchonly);
        mapAccountBalances[strSentAccount] -= nFee;
        for (const COutputEntry& s : listSent)
            mapAccountBalances[strSentAccount] -= s.amount;
        if (nDepth >= nMinDepth)
        {
            for (const COutputEntry& r : listReceived)
                if (pwallet->mapAddressBook.count(r.destination)) {
                    mapAccountBalances[pwallet->mapAddressBook[r.destination].name] += r.amount;
                }
                else
                    mapAccountBalances[""] += r.amount;
        }
    }

    const std::list<CAccountingEntry>& acentries = pwallet->laccentries;
    for (const CAccountingEntry& entry : acentries)
        mapAccountBalances[entry.strAccount] += entry.nCreditDebit;

    UniValue ret(UniValue::VOBJ);
    for (const std::pair<const std::string, CAmount>& accountBalance : mapAccountBalances) {
        ret.pushKV(accountBalance.first, ValueFromAmount(accountBalance.second));
    }
    return ret;
}

            "    \"account\":\"accountname\",       (string) DEPRECATED. This field will be removed in V0.18. To see this deprecated field, start bitcoind with -deprecatedrpc=accounts. The account name associated with the transaction. Will be \"\" for the default account.\n"
            ListTransactions(pwallet, tx, "*", 0, true, transactions, filter);
                ListTransactions(pwallet, it->second, "*", -100000000, true, removed, filter);
            "      \"account\" : \"accountname\",      (string) DEPRECATED. This field will be removed in a V0.18. To see this deprecated field, start bitcoind with -deprecatedrpc=accounts. The account name involved in the transaction, can be \"\" for the default account.\n"
    ListTransactions(pwallet, wtx, "*", 0, false, details, filter);
            "Note that this will shutdown the server.\n"
    // BDB seems to have a bad habit of writing old data into
    // slack space in .dat files; that is bad if the old data is
    // unencrypted private keys. So:
    StartShutdown();
    return "wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";
    for (COutPoint &outpt : vOutpts) {
            "    \"account\" : \"account\",    (string) DEPRECATED. This field will be removed in V0.18. To see this deprecated field, start bitcoind with -deprecatedrpc=accounts. The associated account, or \"\" for the default account\n"
                if (IsDeprecatedRPCEnabled("accounts")) {
                    entry.pushKV("account", i->second.name);
                }
            "  \"embedded\" : {...},           (object, optional) Information about the address embedded in P2SH or P2WSH, if relevant and known. It includes all getaddressinfo output fields for the embedded address, excluding metadata (\"timestamp\", \"hdkeypath\", \"hdseedid\") and relation to the wallet (\"ismine\", \"iswatchonly\", \"account\").\n"
            "  \"label\" :  \"label\"         (string) The label associated with the address, \"\" is the default account\n"
            "  \"account\" : \"account\"         (string) DEPRECATED. This field will be removed in V0.18. To see this deprecated field, start bitcoind with -deprecatedrpc=accounts. The account associated with the address, \"\" is the default account\n"
        if (IsDeprecatedRPCEnabled("accounts")) {
            ret.pushKV("account", pwallet->mapAddressBook[dest].name);
        }
bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath)
{
    std::stringstream ss(keypath_str);
    std::string item;
    bool first = true;
    while (std::getline(ss, item, '/')) {
        if (item.compare("m") == 0) {
            if (first) {
                first = false;
                continue;
            }
            return false;
        }
        // Finds whether it is hardened
        uint32_t path = 0;
        size_t pos = item.find("'");
        if (pos != std::string::npos) {
            // The hardened tick can only be in the last index of the string
            if (pos != item.size() - 1) {
                return false;
            }
            path |= 0x80000000;
            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick
        }

        // Ensure this is only numbers
        if (item.find_first_not_of( "0123456789" ) != std::string::npos) {
            return false;
        }
        uint32_t number;
        if (!ParseUInt32(item, &number)) {
            return false;
        }
        path |= number;

        keypath.push_back(path);
        first = false;
    }
    return true;
}

void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths)
    CKeyMetadata meta;
    auto it = pwallet->mapKeyMetadata.find(keyID);
    if (it != pwallet->mapKeyMetadata.end()) {
        meta = it->second;
    std::vector<uint32_t> keypath;
    if (!meta.hdKeypath.empty()) {
        if (!ParseHDKeypath(meta.hdKeypath, keypath)) {
            throw JSONRPCError(RPC_INTERNAL_ERROR, "Internal keypath is broken");
        }
        // Get the proper master key id
        CKey key;
        pwallet->GetKey(meta.hd_seed_id, key);
        CExtKey masterKey;
        masterKey.SetSeed(key.begin(), key.size());
        // Add to map
        keypath.insert(keypath.begin(), ReadLE32(masterKey.key.GetPubKey().GetID().begin()));
    } else { // Single pubkeys get the master fingerprint of themselves
        keypath.insert(keypath.begin(), ReadLE32(vchPubKey.GetID().begin()));
    }
    hd_keypaths.emplace(vchPubKey, keypath);
        SignatureData sigdata;
        if (sign) {
            complete &= SignPSBTInput(*pwallet, *psbtx.tx, input, sigdata, i, sighash_type);
        } else {
            complete &= SignPSBTInput(PublicOnlySigningProvider(pwallet), *psbtx.tx, input, sigdata, i, sighash_type);
        }

        if (it != pwallet->mapWallet.end()) {
            // Drop the unnecessary UTXO if we added both from the wallet.
            if (sigdata.witness) {
                input.non_witness_utxo = nullptr;
            } else {
                input.witness_utxo.SetNull();
            }
        }

        // Get public key paths
        if (bip32derivs) {
            for (const auto& pubkey_it : sigdata.misc_pubkeys) {
                AddKeypathToMap(pwallet, pubkey_it.first, input.hd_keypaths);
            }
        }
        ProduceSignature(*pwallet, creator, out.scriptPubKey, sigdata);

        // Get public key paths
        if (bip32derivs) {
            for (const auto& pubkey_it : sigdata.misc_pubkeys) {
                AddKeypathToMap(pwallet, pubkey_it.first, psbt_out.hd_keypaths);
            }
        }
            "4. bip32derivs                    (boolean, optiona, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\n"
                            "5. bip32derivs                    (boolean, optiona, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\n"
    bool bip32derivs = request.params[4].isNull() ? false : request.params[5].get_bool();
    { "rawtransactions",    "fundrawtransaction",               &fundrawtransaction,            {"hexstring","options","iswitness"} },
    { "wallet",             "walletprocesspsbt",                &walletprocesspsbt,             {"psbt","sign","sighashtype","bip32derivs"} },
    { "wallet",             "walletcreatefundedpsbt",           &walletcreatefundedpsbt,        {"inputs","outputs","locktime","options","bip32derivs"} },
    { "wallet",             "addmultisigaddress",               &addmultisigaddress,            {"nrequired","keys","label|account","address_type"} },
    { "hidden",             "addwitnessaddress",                &addwitnessaddress,             {"address","p2sh"} },
    { "wallet",             "getbalance",                       &getbalance,                    {"account|dummy","minconf","include_watchonly"} },
    { "wallet",             "getnewaddress",                    &getnewaddress,                 {"label|account","address_type"} },
    { "wallet",             "importwallet",                     &importwallet,                  {"filename"} },
    { "wallet",             "importaddress",                    &importaddress,                 {"address","label","rescan","p2sh"} },
    { "wallet",             "listtransactions",                 &listtransactions,              {"account|dummy","count","skip","include_watchonly"} },
    { "wallet",             "sendmany",                         &sendmany,                      {"fromaccount|dummy","amounts","minconf","comment","subtractfeefrom","replaceable","conf_target","estimate_mode"} },
    { "wallet",             "walletpassphrasechange",           &walletpassphrasechange,        {"oldpassphrase","newpassphrase"} },
    { "wallet",             "removeprunedfunds",                &removeprunedfunds,             {"txid"} },
    { "wallet",             "rescanblockchain",                 &rescanblockchain,              {"start_height", "stop_height"} },
    { "wallet",             "sethdseed",                        &sethdseed,                     {"newkeypool","seed"} },

    /** Account functions (deprecated) */
    { "wallet",             "getaccountaddress",                &getaccountaddress,             {"account"} },
    { "wallet",             "getaccount",                       &getaccount,                    {"address"} },
    { "wallet",             "getaddressesbyaccount",            &getaddressesbyaccount,         {"account"} },
    { "wallet",             "getreceivedbyaccount",             &getreceivedbylabel,            {"account","minconf"} },
    { "wallet",             "listaccounts",                     &listaccounts,                  {"minconf","include_watchonly"} },
    { "wallet",             "listreceivedbyaccount",            &listreceivedbylabel,           {"minconf","include_empty","include_watchonly"} },
    { "wallet",             "setaccount",                       &setlabel,                      {"address","account"} },
    { "wallet",             "sendfrom",                         &sendfrom,                      {"fromaccount","toaddress","amount","minconf","comment","comment_to"} },
    { "wallet",             "move",                             &movecmd,                       {"fromaccount","toaccount","amount","minconf","comment"} },

    /** Label functions (to replace non-balance account functions) */
    { "wallet",             "getaddressesbylabel",              &getaddressesbylabel,           {"label"} },
    { "wallet",             "getreceivedbylabel",               &getreceivedbylabel,            {"label","minconf"} },
    { "wallet",             "listlabels",                       &listlabels,                    {"purpose"} },
    { "wallet",             "listreceivedbylabel",              &listreceivedbylabel,           {"minconf","include_empty","include_watchonly"} },
    { "wallet",             "setlabel",                         &setlabel,                      {"address","label"} },

    { "generating",         "generate",                         &generate,                      {"nblocks","maxtries"} },

identifier:WalletTxToJSON,CWalletTx,wtx,UniValue,entry,CTxDestination,GetLabelDestination,CWallet,pwallet,label,bForceNew,CTxDestination,dest,pwallet,GetLabelDestination,dest,label,bForceNew,throw,JSONRPCError,RPC_WALLET_KEYPOOL_RAN_OUT,dest,UniValue,getaccountaddress,JSONRPCRequest,request,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,EnsureWalletIsAvailable,pwallet,request,fHelp,NullUniValue,IsDeprecatedRPCEnabled,request,fHelp,throw,throw,JSONRPCError,RPC_METHOD_DEPRECATED,request,fHelp,request,params,size,throw,HelpExampleCli,HelpExampleCli,HelpExampleCli,HelpExampleRpc,LOCK2,cs_main,pwallet,cs_wallet,account,LabelFromValue,request,params,UniValue,ret,UniValue::VSTR,ret,EncodeDestination,GetLabelDestination,pwallet,account,ret,IsDeprecatedRPCEnabled,request,strMethod,request,fHelp,throw,throw,JSONRPCError,RPC_METHOD_DEPRECATED,old_label,pwallet,mapAddressBook,dest,name,request,strMethod,old_label,label,dest,GetLabelDestination,pwallet,old_label,GetLabelDestination,pwallet,old_label,found_address,CTxDestination,CAddressBookData,item,pwallet,mapAddressBook,item,second,name,label,found_address,found_address,pwallet,DeleteLabel,old_label,UniValue,getaccount,JSONRPCRequest,request,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,EnsureWalletIsAvailable,pwallet,request,fHelp,NullUniValue,IsDeprecatedRPCEnabled,request,fHelp,throw,throw,JSONRPCError,RPC_METHOD_DEPRECATED,request,fHelp,request,params,size,throw,HelpExampleCli,HelpExampleRpc,LOCK2,cs_main,pwallet,cs_wallet,CTxDestination,dest,DecodeDestination,request,params,get_str,IsValidDestination,dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strAccount,CTxDestination,CAddressBookData,iterator,mi,pwallet,mapAddressBook,find,dest,mi,pwallet,mapAddressBook,end,mi,second,name,empty,strAccount,mi,second,name,strAccount,UniValue,getaddressesbyaccount,JSONRPCRequest,request,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,EnsureWalletIsAvailable,pwallet,request,fHelp,NullUniValue,IsDeprecatedRPCEnabled,request,fHelp,throw,throw,JSONRPCError,RPC_METHOD_DEPRECATED,request,fHelp,request,params,size,throw,HelpExampleCli,HelpExampleRpc,LOCK2,cs_main,pwallet,cs_wallet,strAccount,LabelFromValue,request,params,UniValue,ret,UniValue::VARR,CTxDestination,CAddressBookData,item,pwallet,mapAddressBook,CTxDestination,dest,item,first,strName,item,second,name,strName,strAccount,ret,push_back,EncodeDestination,dest,ret,CTransactionRef,SendMoney,CWallet,pwallet,CTxDestination,address,CAmount,nValue,fSubtractFeeFromAmount,CCoinControl,coin_control,mapValue_t,mapValue,fromAccount,pwallet,CommitTransaction,tx,mapValue,fromAccount,reservekey,g_connman,get,state,CTransactionRef,tx,SendMoney,pwallet,dest,nAmount,fSubtractFeeFromAmount,coin_control,mapValue,IsDeprecatedRPCEnabled,request,strMethod,request,fHelp,throw,throw,JSONRPCError,RPC_METHOD_DEPRECATED,IsDeprecatedRPCEnabled,CURRENCY_UNIT,pos,pos,item,size,path,0x80000000,item,item,substr,item,size,item,find_first_not_of,uint32_t,number,ParseUInt32,item,number,path,number,keypath,push_back,path,first,AddKeypathToMap,CWallet,pwallet,CKeyID,keyID,CPubKey,uint32_t,hd_keypaths,CKeyMetadata,meta,it,pwallet,mapKeyMetadata,find,keyID,it,pwallet,mapKeyMetadata,end,meta,it,second,uint32_t,keypath,meta,hdKeypath,empty,ParseHDKeypath,meta,hdKeypath,keypath,throw,JSONRPCError,RPC_INTERNAL_ERROR,CKey,key,pwallet,GetKey,meta,hd_seed_id,key,CExtKey,masterKey,masterKey,SetSeed,key,begin,key,size,keypath,insert,keypath,begin,ReadLE32,masterKey,key,GetPubKey,GetID,begin,keypath,insert,keypath,begin,ReadLE32,vchPubKey,GetID,begin,hd_keypaths,emplace,vchPubKey,keypath,SignatureData,sigdata,sign,complete,SignPSBTInput,pwallet,psbtx,tx,input,sigdata,i,sighash_type,complete,SignPSBTInput,PublicOnlySigningProvider,pwallet,psbtx,tx,input,sigdata,i,sighash_type,it,pwallet,mapWallet,end,sigdata,witness,input,non_witness_utxo,nullptr,input,witness_utxo,SetNull,bip32derivs,pubkey_it,sigdata,misc_pubkeys,AddKeypathToMap,pwallet,pubkey_it,first,input,hd_keypaths,ProduceSignature,pwallet,creator,out,scriptPubKey,sigdata,bip32derivs,pubkey_it,sigdata,misc_pubkeys,AddKeypathToMap,pwallet,pubkey_it,first,psbt_out,hd_keypaths,bip32derivs,request,params,isNull,request,params,get_bool,fundrawtransaction,walletprocesspsbt,walletcreatefundedpsbt,addmultisigaddress,addwitnessaddress,getbalance,getnewaddress,importwallet,importaddress,listtransactions,sendmany,walletpassphrasechange,removeprunedfunds,rescanblockchain,sethdseed,getaccountaddress,getaccount,getaddressesbyaccount,getreceivedbylabel,listaccounts,listreceivedbylabel,setlabel,sendfrom,movecmd,getaddressesbylabel,getreceivedbylabel,listlabels,listreceivedbylabel,setlabel,generate,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/accounting_tests.cpp
changed code snippet:

#include <wallet/wallet.h>

#include <wallet/test/wallet_test_fixture.h>

#include <stdint.h>

#include <boost/test/unit_test.hpp>

BOOST_FIXTURE_TEST_SUITE(accounting_tests, WalletTestingSetup)

static void
GetResults(CWallet& wallet, std::map<CAmount, CAccountingEntry>& results)
{
    std::list<CAccountingEntry> aes;

    results.clear();
    BOOST_CHECK(wallet.ReorderTransactions() == DBErrors::LOAD_OK);
    wallet.ListAccountCreditDebit("", aes);
    for (CAccountingEntry& ae : aes)
    {
        results[ae.nOrderPos] = ae;
    }
}

BOOST_AUTO_TEST_CASE(acc_orderupgrade)
{
    std::vector<CWalletTx*> vpwtx;
    CWalletTx wtx(nullptr /* pwallet */, MakeTransactionRef());
    CAccountingEntry ae;
    std::map<CAmount, CAccountingEntry> results;

    LOCK(m_wallet.cs_wallet);

    ae.strAccount = "";
    ae.nCreditDebit = 1;
    ae.nTime = 1333333333;
    ae.strOtherAccount = "b";
    ae.strComment = "";
    m_wallet.AddAccountingEntry(ae);

    wtx.mapValue["comment"] = "z";
    m_wallet.AddToWallet(wtx);
    vpwtx.push_back(&m_wallet.mapWallet.at(wtx.GetHash()));
    vpwtx[0]->nTimeReceived = (unsigned int)1333333335;
    vpwtx[0]->nOrderPos = -1;

    ae.nTime = 1333333336;
    ae.strOtherAccount = "c";
    m_wallet.AddAccountingEntry(ae);

    GetResults(m_wallet, results);

    BOOST_CHECK(m_wallet.nOrderPosNext == 3);
    BOOST_CHECK(2 == results.size());
    BOOST_CHECK(results[0].nTime == 1333333333);
    BOOST_CHECK(results[0].strComment.empty());
    BOOST_CHECK(1 == vpwtx[0]->nOrderPos);
    BOOST_CHECK(results[2].nTime == 1333333336);
    BOOST_CHECK(results[2].strOtherAccount == "c");


    ae.nTime = 1333333330;
    ae.strOtherAccount = "d";
    ae.nOrderPos = m_wallet.IncOrderPosNext();
    m_wallet.AddAccountingEntry(ae);

    GetResults(m_wallet, results);

    BOOST_CHECK(results.size() == 3);
    BOOST_CHECK(m_wallet.nOrderPosNext == 4);
    BOOST_CHECK(results[0].nTime == 1333333333);
    BOOST_CHECK(1 == vpwtx[0]->nOrderPos);
    BOOST_CHECK(results[2].nTime == 1333333336);
    BOOST_CHECK(results[3].nTime == 1333333330);
    BOOST_CHECK(results[3].strComment.empty());


    wtx.mapValue["comment"] = "y";
    {
        CMutableTransaction tx(*wtx.tx);
        ++tx.nLockTime;  // Just to change the hash :)
        wtx.SetTx(MakeTransactionRef(std::move(tx)));
    }
    m_wallet.AddToWallet(wtx);
    vpwtx.push_back(&m_wallet.mapWallet.at(wtx.GetHash()));
    vpwtx[1]->nTimeReceived = (unsigned int)1333333336;

    wtx.mapValue["comment"] = "x";
    {
        CMutableTransaction tx(*wtx.tx);
        ++tx.nLockTime;  // Just to change the hash :)
        wtx.SetTx(MakeTransactionRef(std::move(tx)));
    }
    m_wallet.AddToWallet(wtx);
    vpwtx.push_back(&m_wallet.mapWallet.at(wtx.GetHash()));
    vpwtx[2]->nTimeReceived = (unsigned int)1333333329;
    vpwtx[2]->nOrderPos = -1;

    GetResults(m_wallet, results);

    BOOST_CHECK(results.size() == 3);
    BOOST_CHECK(m_wallet.nOrderPosNext == 6);
    BOOST_CHECK(0 == vpwtx[2]->nOrderPos);
    BOOST_CHECK(results[1].nTime == 1333333333);
    BOOST_CHECK(2 == vpwtx[0]->nOrderPos);
    BOOST_CHECK(results[3].nTime == 1333333336);
    BOOST_CHECK(results[4].nTime == 1333333330);
    BOOST_CHECK(results[4].strComment.empty());
    BOOST_CHECK(5 == vpwtx[1]->nOrderPos);


    ae.nTime = 1333333334;
    ae.strOtherAccount = "e";
    ae.nOrderPos = -1;
    m_wallet.AddAccountingEntry(ae);

    GetResults(m_wallet, results);

    BOOST_CHECK(results.size() == 4);
    BOOST_CHECK(m_wallet.nOrderPosNext == 7);
    BOOST_CHECK(0 == vpwtx[2]->nOrderPos);
    BOOST_CHECK(results[1].nTime == 1333333333);
    BOOST_CHECK(2 == vpwtx[0]->nOrderPos);
    BOOST_CHECK(results[3].nTime == 1333333336);
    BOOST_CHECK(results[3].strComment.empty());
    BOOST_CHECK(results[4].nTime == 1333333330);
    BOOST_CHECK(results[4].strComment.empty());
    BOOST_CHECK(results[5].nTime == 1333333334);
    BOOST_CHECK(6 == vpwtx[1]->nOrderPos);
}

BOOST_AUTO_TEST_SUITE_END()

identifier:include,wallet,wallet,h,include,wallet,test,wallet_test_fixture,h,include,stdint,h,include,boost,test,unit_test,hpp,BOOST_FIXTURE_TEST_SUITE,accounting_tests,WalletTestingSetup,GetResults,CWallet,wallet,CAmount,CAccountingEntry,results,CAccountingEntry,aes,results,clear,BOOST_CHECK,wallet,ReorderTransactions,DBErrors::LOAD_OK,wallet,ListAccountCreditDebit,aes,CAccountingEntry,ae,aes,results,ae,nOrderPos,ae,BOOST_AUTO_TEST_CASE,acc_orderupgrade,CWalletTx,vpwtx,CWalletTx,wtx,nullptr,MakeTransactionRef,CAccountingEntry,ae,CAmount,CAccountingEntry,results,LOCK,m_wallet,cs_wallet,ae,strAccount,ae,nCreditDebit,ae,nTime,ae,strOtherAccount,ae,strComment,m_wallet,AddAccountingEntry,ae,wtx,mapValue,m_wallet,AddToWallet,wtx,vpwtx,push_back,m_wallet,mapWallet,at,wtx,GetHash,vpwtx,nTimeReceived,vpwtx,nOrderPos,ae,nTime,ae,strOtherAccount,m_wallet,AddAccountingEntry,ae,GetResults,m_wallet,results,BOOST_CHECK,m_wallet,nOrderPosNext,BOOST_CHECK,results,size,BOOST_CHECK,results,nTime,BOOST_CHECK,results,strComment,empty,BOOST_CHECK,vpwtx,nOrderPos,BOOST_CHECK,results,nTime,BOOST_CHECK,results,strOtherAccount,ae,nTime,ae,strOtherAccount,ae,nOrderPos,m_wallet,IncOrderPosNext,m_wallet,AddAccountingEntry,ae,GetResults,m_wallet,results,BOOST_CHECK,results,size,BOOST_CHECK,m_wallet,nOrderPosNext,BOOST_CHECK,results,nTime,BOOST_CHECK,vpwtx,nOrderPos,BOOST_CHECK,results,nTime,BOOST_CHECK,results,nTime,BOOST_CHECK,results,strComment,empty,wtx,mapValue,CMutableTransaction,tx,wtx,tx,tx,nLockTime,wtx,SetTx,MakeTransactionRef,tx,m_wallet,AddToWallet,wtx,vpwtx,push_back,m_wallet,mapWallet,at,wtx,GetHash,vpwtx,nTimeReceived,wtx,mapValue,CMutableTransaction,tx,wtx,tx,tx,nLockTime,wtx,SetTx,MakeTransactionRef,tx,m_wallet,AddToWallet,wtx,vpwtx,push_back,m_wallet,mapWallet,at,wtx,GetHash,vpwtx,nTimeReceived,vpwtx,nOrderPos,GetResults,m_wallet,results,BOOST_CHECK,results,size,BOOST_CHECK,m_wallet,nOrderPosNext,BOOST_CHECK,vpwtx,nOrderPos,BOOST_CHECK,results,nTime,BOOST_CHECK,vpwtx,nOrderPos,BOOST_CHECK,results,nTime,BOOST_CHECK,results,nTime,BOOST_CHECK,results,strComment,empty,BOOST_CHECK,vpwtx,nOrderPos,ae,nTime,ae,strOtherAccount,ae,nOrderPos,m_wallet,AddAccountingEntry,ae,GetResults,m_wallet,results,BOOST_CHECK,results,size,BOOST_CHECK,m_wallet,nOrderPosNext,BOOST_CHECK,vpwtx,nOrderPos,BOOST_CHECK,results,nTime,BOOST_CHECK,vpwtx,nOrderPos,BOOST_CHECK,results,nTime,BOOST_CHECK,results,strComment,empty,BOOST_CHECK,results,nTime,BOOST_CHECK,results,strComment,empty,BOOST_CHECK,results,nTime,BOOST_CHECK,vpwtx,nOrderPos,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
        // test with many inputs
        for (CAmount amt=1500; amt < COIN; amt*=10) {
             empty_wallet();
             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
             for (uint16_t j = 0; j < 676; j++)
                 add_coin(amt);
        }
        // test randomness
        {
            empty_wallet();
            for (int i2 = 0; i2 < 100; i2++)
                add_coin(COIN);
            // add 75 cents in small change.  not enough to make 90 cents,
            // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
            // one of which should be picked at random
            add_coin(5 * CENT);
            add_coin(10 * CENT);
            add_coin(15 * CENT);
            add_coin(20 * CENT);
            add_coin(25 * CENT);
            fails = 0;
        }
    }

identifier:CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,empty_wallet,i2,i2,i2,add_coin,COIN,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/psbt_wallet_tests.cpp
changed code snippet:
extern bool ParseHDKeypath(std::string keypath_str, std::vector<uint32_t>& keypath);


identifier:ParseHDKeypath,keypath_str,uint32_t,keypath,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/wallet_tests.cpp
changed code snippet:
        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, {}, reservekey, nullptr, state));
    auto list = wallet->ListCoins();
    list = wallet->ListCoins();
    list = wallet->ListCoins();

identifier:BOOST_CHECK,wallet,CommitTransaction,tx,reservekey,nullptr,state,list,wallet,ListCoins,list,wallet,ListCoins,list,wallet,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        copyTo->strFromAccount = copyFrom->strFromAccount;
    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.
    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;
    typedef std::multimap<int64_t, TxPair > TxItems;
        txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, nullptr)));
    }
    std::list<CAccountingEntry> acentries;
    batch.ListAccountCreditDebit("", acentries);
    for (CAccountingEntry& entry : acentries)
    {
        txByTime.insert(std::make_pair(entry.nTime, TxPair(nullptr, &entry)));
        CWalletTx *const pwtx = (*it).second.first;
        CAccountingEntry *const pacentry = (*it).second.second;
        int64_t& nOrderPos = (pwtx != nullptr) ? pwtx->nOrderPos : pacentry->nOrderPos;
            if (pwtx)
            {
                if (!batch.WriteTx(*pwtx))
                    return DBErrors::LOAD_FAIL;
            }
            else
                if (!batch.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))
                    return DBErrors::LOAD_FAIL;
            if (pwtx)
            {
                if (!batch.WriteTx(*pwtx))
                    return DBErrors::LOAD_FAIL;
            }
            else
                if (!batch.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))
                    return DBErrors::LOAD_FAIL;
bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment)
{
    WalletBatch batch(*database);
    if (!batch.TxnBegin())
        return false;

    int64_t nNow = GetAdjustedTime();

    // Debit
    CAccountingEntry debit;
    debit.nOrderPos = IncOrderPosNext(&batch);
    debit.strAccount = strFrom;
    debit.nCreditDebit = -nAmount;
    debit.nTime = nNow;
    debit.strOtherAccount = strTo;
    debit.strComment = strComment;
    AddAccountingEntry(debit, &batch);

    // Credit
    CAccountingEntry credit;
    credit.nOrderPos = IncOrderPosNext(&batch);
    credit.strAccount = strTo;
    credit.nCreditDebit = nAmount;
    credit.nTime = nNow;
    credit.strOtherAccount = strFrom;
    credit.strComment = strComment;
    AddAccountingEntry(credit, &batch);

    if (!batch.TxnCommit())
        return false;

    return true;
}

bool CWallet::GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew)
{
    WalletBatch batch(*database);

    CAccount account;
    batch.ReadAccount(label, account);

    if (!bForceNew) {
        if (!account.vchPubKey.IsValid())
            bForceNew = true;
        else {
            // Check if the current key has been used (TODO: check other addresses with the same key)
            CScript scriptPubKey = GetScriptForDestination(GetDestinationForKey(account.vchPubKey, m_default_address_type));
            for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();
                 it != mapWallet.end() && account.vchPubKey.IsValid();
                 ++it)
                for (const CTxOut& txout : (*it).second.tx->vout)
                    if (txout.scriptPubKey == scriptPubKey) {
                        bForceNew = true;
                        break;
                    }
        }
    }

    // Generate a new key
    if (bForceNew) {
        if (!GetKeyFromPool(account.vchPubKey, false))
            return false;

        LearnRelatedScripts(account.vchPubKey, m_default_address_type);
        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);
        SetAddressBook(dest, label, "receive");
        batch.WriteAccount(label, account);
    } else {
        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);
    }

    return true;
}

        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));
        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));
    for (auto& input : tx.vin) {
                           std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const
    strSentAccount = strFromAccount;
    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const
            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetLabelName(out.scriptPubKey))) {
        if (outgoing && (!account || *account == wtx.strFromAccount)) {
    if (account) {
        balance += WalletBatch(*database).GetAccountCreditDebit(*account);
    }

    // TODO: Add AssertLockHeld(cs_wallet) here.
    //
    // Because the return value from this function contains pointers to
    // CWalletTx objects, callers to this function really should acquire the
    // cs_wallet lock before calling it. However, the current caller doesn't
    // acquire this lock yet. There was an attempt to add the missing lock in
    // https://github.com/bitcoin/bitcoin/pull/10340, but that change has been
    // postponed until after https://github.com/bitcoin/bitcoin/pull/10244 to
    // avoid adding some extra complexity to the Qt code.
    LOCK2(cs_main, cs_wallet);
    for (auto& coin : availableCoins) {
    for (const auto& output : lockedCoins) {
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);
                } else {
                    bnb_used = false;
bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state)
        wtxNew.strFromAccount = std::move(fromAccount);
void CWallet::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries) {
    WalletBatch batch(*database);
    return batch.ListAccountCreditDebit(strAccount, entries);
}

bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)
{
    WalletBatch batch(*database);

    return AddAccountingEntry(acentry, &batch);
}

bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, WalletBatch *batch)
{
    if (!batch->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {
        return false;
    }

    laccentries.push_back(acentry);
    CAccountingEntry & entry = laccentries.back();
    wtxOrdered.insert(std::make_pair(entry.nOrderPos, TxPair(nullptr, &entry)));

    return true;
}

        for (int64_t nIndex : setInternalKeyPool) {
        for (int64_t nIndex : setExternalKeyPool) {
        for (int64_t nIndex : set_pre_split_keypool) {
            for (CTxIn txin : pcoin->tx->vin)
               for (CTxOut txout : pcoin->tx->vout)
        for (CTxDestination address : _grouping)
        for (CTxDestination element : *merged)
    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)
void CWallet::DeleteLabel(const std::string& label)
{
    WalletBatch batch(*database);
    batch.EraseAccount(label);
}

                CWalletTx* const pwtx = it->second.first;
                CAccountingEntry* const pacentry = it->second.second;
                if (pwtx) {
                    nSmartTime = pwtx->nTimeSmart;
                    if (!nSmartTime) {
                        nSmartTime = pwtx->nTimeReceived;
                    }
                } else {
                    nSmartTime = pacentry->nTime;
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, e.what());
                    copyTo->strFromAccount = copyFrom->strFromAccount;

identifier:copyTo,strFromAccount,copyFrom,strFromAccount,CWalletTx,CAccountingEntry,TxPair,int64_t,TxPair,TxItems,txByTime,insert,wtx,nTimeReceived,TxPair,wtx,nullptr,CAccountingEntry,acentries,batch,ListAccountCreditDebit,acentries,CAccountingEntry,entry,acentries,txByTime,insert,entry,nTime,TxPair,nullptr,entry,CWalletTx,pwtx,it,second,first,CAccountingEntry,pacentry,it,second,second,int64_t,nOrderPos,pwtx,nullptr,pwtx,nOrderPos,pacentry,nOrderPos,pwtx,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,batch,WriteAccountingEntry,pacentry,nEntryNo,pacentry,DBErrors::LOAD_FAIL,pwtx,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,batch,WriteAccountingEntry,pacentry,nEntryNo,pacentry,DBErrors::LOAD_FAIL,CWallet::AccountMove,strFrom,strTo,CAmount,nAmount,strComment,WalletBatch,batch,database,batch,TxnBegin,int64_t,nNow,GetAdjustedTime,CAccountingEntry,debit,debit,nOrderPos,IncOrderPosNext,batch,debit,strAccount,strFrom,debit,nCreditDebit,nAmount,debit,nTime,nNow,debit,strOtherAccount,strTo,debit,strComment,strComment,AddAccountingEntry,debit,batch,CAccountingEntry,credit,credit,nOrderPos,IncOrderPosNext,batch,credit,strAccount,strTo,credit,nCreditDebit,nAmount,credit,nTime,nNow,credit,strOtherAccount,strFrom,credit,strComment,strComment,AddAccountingEntry,credit,batch,batch,TxnCommit,CWallet::GetLabelDestination,CTxDestination,dest,label,bForceNew,WalletBatch,batch,database,CAccount,account,batch,ReadAccount,label,account,bForceNew,account,vchPubKey,IsValid,bForceNew,CScript,scriptPubKey,GetScriptForDestination,GetDestinationForKey,account,vchPubKey,m_default_address_type,uint256,CWalletTx,iterator,it,mapWallet,begin,it,mapWallet,end,account,vchPubKey,IsValid,it,CTxOut,txout,it,second,tx,vout,txout,scriptPubKey,scriptPubKey,bForceNew,bForceNew,GetKeyFromPool,account,vchPubKey,LearnRelatedScripts,account,vchPubKey,m_default_address_type,dest,GetDestinationForKey,account,vchPubKey,m_default_address_type,SetAddressBook,dest,label,batch,WriteAccount,label,account,dest,GetDestinationForKey,account,vchPubKey,m_default_address_type,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,TxPair,wtx,nullptr,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,TxPair,wtx,nullptr,input,tx,vin,COutputEntry,listSent,CAmount,nFee,strSentAccount,isminefilter,filter,strSentAccount,strFromAccount,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,CAmount,CWallet::GetLegacyBalance,isminefilter,filter,minDepth,account,IsMine,out,filter,depth,minDepth,account,account,GetLabelName,out,scriptPubKey,outgoing,account,account,wtx,strFromAccount,account,balance,WalletBatch,database,GetAccountCreditDebit,account,LOCK2,cs_main,cs_wallet,coin,availableCoins,output,lockedCoins,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,SER_DISK,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,SER_NETWORK,PROTOCOL_VERSION,bnb_used,CWallet::CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,fromAccount,CReserveKey,reservekey,CConnman,connman,CValidationState,state,wtxNew,strFromAccount,fromAccount,CWallet::ListAccountCreditDebit,strAccount,CAccountingEntry,entries,WalletBatch,batch,database,batch,ListAccountCreditDebit,strAccount,entries,CWallet::AddAccountingEntry,CAccountingEntry,acentry,WalletBatch,batch,database,AddAccountingEntry,acentry,batch,CWallet::AddAccountingEntry,CAccountingEntry,acentry,WalletBatch,batch,batch,WriteAccountingEntry,nAccountingEntryNumber,acentry,laccentries,push_back,acentry,CAccountingEntry,entry,laccentries,back,wtxOrdered,insert,entry,nOrderPos,TxPair,nullptr,entry,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,CWallet::DeleteLabel,label,WalletBatch,batch,database,batch,EraseAccount,label,CWalletTx,pwtx,it,second,first,CAccountingEntry,pacentry,it,second,second,pwtx,nSmartTime,pwtx,nTimeSmart,nSmartTime,nSmartTime,pwtx,nTimeReceived,nSmartTime,pacentry,nTime,error_string,strprintf,wallet_file,e,what,copyTo,strFromAccount,copyFrom,strFromAccount,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.h
changed code snippet:
    int GetDepthInMainChain() const;
    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }
    int GetBlocksToMaturity() const;
    bool IsImmatureCoinBase() const;
     *                         sendfrom, sendmany wallet RPCs
    std::string strFromAccount;
    std::multimap<int64_t, std::pair<CWalletTx*, CAccountingEntry*>>::const_iterator m_it_wtxOrdered;
        strFromAccount.clear();
        mapValueCopy["fromaccount"] = strFromAccount;
        strFromAccount = std::move(mapValue["fromaccount"]);
    CAmount GetCredit(const isminefilter& filter) const;
    CAmount GetImmatureCredit(bool fUseCache=true) const;
    CAmount GetAvailableCredit(bool fUseCache=true, const isminefilter& filter=ISMINE_SPENDABLE) const;
    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache=true) const;
                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;
    bool IsTrusted() const;
    bool RelayWalletTransaction(CConnman* connman);
    bool AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state);
/**
 * DEPRECATED Internal transfers.
 * Database key is acentry<account><counter>.
 */
class CAccountingEntry
{
public:
    std::string strAccount;
    CAmount nCreditDebit;
    int64_t nTime;
    std::string strOtherAccount;
    std::string strComment;
    mapValue_t mapValue;
    int64_t nOrderPos; //!< position in ordered transaction list
    uint64_t nEntryNo;

    CAccountingEntry()
    {
        SetNull();
    }

    void SetNull()
    {
        nCreditDebit = 0;
        nTime = 0;
        strAccount.clear();
        strOtherAccount.clear();
        strComment.clear();
        nOrderPos = -1;
        nEntryNo = 0;
    }

    template <typename Stream>
    void Serialize(Stream& s) const {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH)) {
            s << nVersion;
        }
        //! Note: strAccount is serialized as part of the key, not here.
        s << nCreditDebit << nTime << strOtherAccount;

        mapValue_t mapValueCopy = mapValue;
        WriteOrderPos(nOrderPos, mapValueCopy);

        std::string strCommentCopy = strComment;
        if (!mapValueCopy.empty() || !_ssExtra.empty()) {
            CDataStream ss(s.GetType(), s.GetVersion());
            ss.insert(ss.begin(), '\0');
            ss << mapValueCopy;
            ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());
            strCommentCopy.append(ss.str());
        }
        s << strCommentCopy;
    }

    template <typename Stream>
    void Unserialize(Stream& s) {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH)) {
            s >> nVersion;
        }
        //! Note: strAccount is serialized as part of the key, not here.
        s >> nCreditDebit >> nTime >> LIMITED_STRING(strOtherAccount, 65536) >> LIMITED_STRING(strComment, 65536);

        size_t nSepPos = strComment.find("\0", 0, 1);
        mapValue.clear();
        if (std::string::npos != nSepPos) {
            CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), s.GetType(), s.GetVersion());
            ss >> mapValue;
            _ssExtra = std::vector<char>(ss.begin(), ss.end());
        }
        ReadOrderPos(nOrderPos, mapValue);
        if (std::string::npos != nSepPos) {
            strComment.erase(nSepPos);
        }

        mapValue.erase("n");
    }

private:
    std::vector<char> _ssExtra;
};

    std::list<CAccountingEntry> laccentries;
    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;
    typedef std::multimap<int64_t, TxPair > TxItems;
    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0, const int nMinDepth = 0, const int nMaxDepth = 9999999) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
    std::map<CTxDestination, std::vector<COutput>> ListCoins() const;
    bool IsSpent(const uint256& hash, unsigned int n) const;
    bool AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment = "") EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
    bool GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew = false);
    void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override;
    std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman);
    CAmount GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const;
    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state);
    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);
    bool AddAccountingEntry(const CAccountingEntry&);
    bool AddAccountingEntry(const CAccountingEntry&, WalletBatch *batch);
    bool m_allow_fallback_fee{true}; //<! will be defined via chainparams
    std::map<CTxDestination, CAmount> GetAddressBalances();
    void DeleteLabel(const std::string& label);
    void BlockUntilSyncedToCurrentChain() LOCKS_EXCLUDED(cs_wallet);

/**
 * DEPRECATED Account information.
 * Stored in wallet with key "acc"+string account name.
 */
class CAccount
{
public:
    CPubKey vchPubKey;

    CAccount()
    {
        SetNull();
    }

    void SetNull()
    {
        vchPubKey = CPubKey();
    }

    ADD_SERIALIZE_METHODS;

    template <typename Stream, typename Operation>
    inline void SerializationOp(Stream& s, Operation ser_action) {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH))
            READWRITE(nVersion);
        READWRITE(vchPubKey);
    }
};


identifier:GetDepthInMainChain,IsInMainChain,GetDepthInMainChain,GetBlocksToMaturity,IsImmatureCoinBase,sendfrom,sendmany,wallet,RPCs,strFromAccount,int64_t,CWalletTx,CAccountingEntry,const_iterator,m_it_wtxOrdered,strFromAccount,clear,mapValueCopy,strFromAccount,strFromAccount,mapValue,CAmount,GetCredit,isminefilter,filter,CAmount,GetImmatureCredit,fUseCache,CAmount,GetAvailableCredit,fUseCache,isminefilter,filter,ISMINE_SPENDABLE,CAmount,GetImmatureWatchOnlyCredit,fUseCache,COutputEntry,listSent,CAmount,nFee,strSentAccount,isminefilter,filter,IsTrusted,RelayWalletTransaction,CConnman,connman,AcceptToMemoryPool,CAmount,nAbsurdFee,CValidationState,state,class,CAccountingEntry,public,strAccount,CAmount,nCreditDebit,int64_t,nTime,strOtherAccount,strComment,mapValue_t,mapValue,int64_t,nOrderPos,uint64_t,nEntryNo,CAccountingEntry,SetNull,SetNull,nCreditDebit,nTime,strAccount,clear,strOtherAccount,clear,strComment,clear,nOrderPos,nEntryNo,template,typename,Stream,Serialize,Stream,s,nVersion,s,GetVersion,s,GetType,SER_GETHASH,s,nVersion,s,nCreditDebit,nTime,strOtherAccount,mapValue_t,mapValueCopy,mapValue,WriteOrderPos,nOrderPos,mapValueCopy,strCommentCopy,strComment,mapValueCopy,empty,_ssExtra,empty,CDataStream,ss,s,GetType,s,GetVersion,ss,insert,ss,begin,ss,mapValueCopy,ss,insert,ss,end,_ssExtra,begin,_ssExtra,end,strCommentCopy,append,ss,str,s,strCommentCopy,template,typename,Stream,Unserialize,Stream,s,nVersion,s,GetVersion,s,GetType,SER_GETHASH,s,nVersion,s,nCreditDebit,nTime,LIMITED_STRING,strOtherAccount,LIMITED_STRING,strComment,size_t,nSepPos,strComment,find,mapValue,clear,nSepPos,CDataStream,ss,strComment,begin,nSepPos,strComment,end,s,GetType,s,GetVersion,ss,mapValue,_ssExtra,ss,begin,ss,end,ReadOrderPos,nOrderPos,mapValue,nSepPos,strComment,erase,nSepPos,mapValue,erase,private,_ssExtra,CAccountingEntry,laccentries,CWalletTx,CAccountingEntry,TxPair,int64_t,TxPair,TxItems,AvailableCoins,COutput,vCoins,fOnlySafe,CCoinControl,coinControl,nullptr,CAmount,nMinimumAmount,CAmount,nMaximumAmount,MAX_MONEY,CAmount,nMinimumSumAmount,MAX_MONEY,uint64_t,nMaximumCount,nMinDepth,nMaxDepth,EXCLUSIVE_LOCKS_REQUIRED,cs_wallet,CTxDestination,COutput,ListCoins,IsSpent,uint256,hash,n,AccountMove,strFrom,strTo,CAmount,nAmount,strComment,EXCLUSIVE_LOCKS_REQUIRED,cs_wallet,GetLabelDestination,CTxDestination,dest,label,bForceNew,ResendWalletTransactions,int64_t,nBestBlockTime,CConnman,connman,override,uint256,ResendWalletTransactionsBefore,int64_t,nTime,CConnman,connman,CAmount,GetLegacyBalance,isminefilter,filter,minDepth,account,CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,fromAccount,CReserveKey,reservekey,CConnman,connman,CValidationState,state,ListAccountCreditDebit,strAccount,CAccountingEntry,entries,AddAccountingEntry,CAccountingEntry,AddAccountingEntry,CAccountingEntry,WalletBatch,batch,m_allow_fallback_fee,CTxDestination,CAmount,GetAddressBalances,DeleteLabel,label,BlockUntilSyncedToCurrentChain,LOCKS_EXCLUDED,cs_wallet,class,CAccount,public,CPubKey,vchPubKey,CAccount,SetNull,SetNull,vchPubKey,CPubKey,ADD_SERIALIZE_METHODS,template,typename,Stream,typename,Operation,inline,SerializationOp,Stream,s,Operation,ser_action,nVersion,s,GetVersion,s,GetType,SER_GETHASH,READWRITE,nVersion,READWRITE,vchPubKey,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
bool WalletBatch::ReadAccount(const std::string& strAccount, CAccount& account)
{
    account.SetNull();
    return m_batch.Read(std::make_pair(std::string("acc"), strAccount), account);
}

bool WalletBatch::WriteAccount(const std::string& strAccount, const CAccount& account)
{
    return WriteIC(std::make_pair(std::string("acc"), strAccount), account);
}

bool WalletBatch::EraseAccount(const std::string& strAccount)
{
    return EraseIC(std::make_pair(std::string("acc"), strAccount));
}

bool WalletBatch::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)
{
    return WriteIC(std::make_pair(std::string("acentry"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);
}

CAmount WalletBatch::GetAccountCreditDebit(const std::string& strAccount)
{
    std::list<CAccountingEntry> entries;
    ListAccountCreditDebit(strAccount, entries);

    CAmount nCreditDebit = 0;
    for (const CAccountingEntry& entry : entries)
        nCreditDebit += entry.nCreditDebit;

    return nCreditDebit;
}

void WalletBatch::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries)
{
    bool fAllAccounts = (strAccount == "*");

    Dbc* pcursor = m_batch.GetCursor();
    if (!pcursor)
        throw std::runtime_error(std::string(__func__) + ": cannot create DB cursor");
    bool setRange = true;
    while (true)
    {
        // Read next record
        CDataStream ssKey(SER_DISK, CLIENT_VERSION);
        if (setRange)
            ssKey << std::make_pair(std::string("acentry"), std::make_pair((fAllAccounts ? std::string("") : strAccount), uint64_t(0)));
        CDataStream ssValue(SER_DISK, CLIENT_VERSION);
        int ret = m_batch.ReadAtCursor(pcursor, ssKey, ssValue, setRange);
        setRange = false;
        if (ret == DB_NOTFOUND)
            break;
        else if (ret != 0)
        {
            pcursor->close();
            throw std::runtime_error(std::string(__func__) + ": error scanning DB");
        }

        // Unserialize
        std::string strType;
        ssKey >> strType;
        if (strType != "acentry")
            break;
        CAccountingEntry acentry;
        ssKey >> acentry.strAccount;
        if (!fAllAccounts && acentry.strAccount != strAccount)
            break;

        ssValue >> acentry;
        ssKey >> acentry.nEntryNo;
        entries.push_back(acentry);
    }

    pcursor->close();
}

                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;
                    strErr = strprintf("LoadWallet() upgrading tx ver=%d %d '%s' %s",
                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount, hash.ToString());
        else if (strType == "acentry")
        {
            std::string strAccount;
            ssKey >> strAccount;
            uint64_t nNumber;
            ssKey >> nNumber;
            if (nNumber > pwallet->nAccountingEntryNumber) {
                pwallet->nAccountingEntryNumber = nNumber;
            }

            if (!wss.fAnyUnordered)
            {
                CAccountingEntry acentry;
                ssValue >> acentry;
                if (acentry.nOrderPos == -1)
                    wss.fAnyUnordered = true;
            }
        }
                strType != "minversion") {
    for (uint256 hash : wss.vWalletUpgrade)
    pwallet->laccentries.clear();
    ListAccountCreditDebit("*", pwallet->laccentries);
    for (CAccountingEntry& entry : pwallet->laccentries) {
        pwallet->wtxOrdered.insert(make_pair(entry.nOrderPos, CWallet::TxPair(nullptr, &entry)));
    }

    for (uint256 hash : vTxHash) {
    for (uint256& hash : vTxHash) {

identifier:WalletBatch::ReadAccount,strAccount,CAccount,account,account,SetNull,m_batch,Read,strAccount,account,WalletBatch::WriteAccount,strAccount,CAccount,account,WriteIC,strAccount,account,WalletBatch::EraseAccount,strAccount,EraseIC,strAccount,WalletBatch::WriteAccountingEntry,uint64_t,nAccEntryNum,CAccountingEntry,acentry,WriteIC,acentry,strAccount,nAccEntryNum,acentry,CAmount,WalletBatch::GetAccountCreditDebit,strAccount,CAccountingEntry,entries,ListAccountCreditDebit,strAccount,entries,CAmount,nCreditDebit,CAccountingEntry,entry,entries,nCreditDebit,entry,nCreditDebit,nCreditDebit,WalletBatch::ListAccountCreditDebit,strAccount,CAccountingEntry,entries,fAllAccounts,strAccount,Dbc,pcursor,m_batch,GetCursor,pcursor,throw,__func__,setRange,CDataStream,ssKey,SER_DISK,CLIENT_VERSION,setRange,ssKey,fAllAccounts,strAccount,uint64_t,CDataStream,ssValue,SER_DISK,CLIENT_VERSION,ret,m_batch,ReadAtCursor,pcursor,ssKey,ssValue,setRange,setRange,ret,DB_NOTFOUND,ret,pcursor,close,throw,__func__,strType,ssKey,strType,strType,CAccountingEntry,acentry,ssKey,acentry,strAccount,fAllAccounts,acentry,strAccount,strAccount,ssValue,acentry,ssKey,acentry,nEntryNo,entries,push_back,acentry,pcursor,close,ssValue,fTmp,fUnused,wtx,strFromAccount,strErr,strprintf,wtx,fTimeReceivedIsTxTime,fTmp,wtx,strFromAccount,hash,ToString,strType,strAccount,ssKey,strAccount,uint64_t,nNumber,ssKey,nNumber,nNumber,pwallet,nAccountingEntryNumber,pwallet,nAccountingEntryNumber,nNumber,wss,fAnyUnordered,CAccountingEntry,acentry,ssValue,acentry,acentry,nOrderPos,wss,fAnyUnordered,strType,uint256,hash,wss,vWalletUpgrade,pwallet,laccentries,clear,ListAccountCreditDebit,pwallet,laccentries,CAccountingEntry,entry,pwallet,laccentries,pwallet,wtxOrdered,insert,make_pair,entry,nOrderPos,CWallet::TxPair,nullptr,entry,uint256,hash,vTxHash,uint256,hash,vTxHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.h
changed code snippet:
class CAccount;
class CAccountingEntry;
    /// This writes directly to the database, and will not update the CWallet's cached accounting entries!
    /// Use wallet.AddAccountingEntry instead, to write *and* update its caches.
    bool WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry);
    bool ReadAccount(const std::string& strAccount, CAccount& account);
    bool WriteAccount(const std::string& strAccount, const CAccount& account);
    bool EraseAccount(const std::string& strAccount);

    CAmount GetAccountCreditDebit(const std::string& strAccount);
    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);


identifier:class,CAccount,class,CAccountingEntry,WriteAccountingEntry,uint64_t,nAccEntryNum,CAccountingEntry,acentry,ReadAccount,strAccount,CAccount,account,WriteAccount,strAccount,CAccount,account,EraseAccount,strAccount,CAmount,GetAccountCreditDebit,strAccount,ListAccountCreditDebit,strAccount,CAccountingEntry,acentries,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    pcontext = zmq_init(1);
        zmq_ctx_destroy(pcontext);

identifier:pcontext,zmq_init,zmq_ctx_destroy,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:a23a7f60aa07de52d23ff1f2034fc43926ec3520
commit B:d26278988fbfc71dc558f7b2c60a184e8091450b
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (const auto v_i : v) {
    for (const auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/crypto_hash.cpp
changed code snippet:
        rng.rand32();
        rng.randbool();

identifier:rng,rand32,rng,randbool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/gcs_filter.cpp
changed code snippet:

#include <bench/bench.h>
#include <blockfilter.h>

static void ConstructGCSFilter(benchmark::State& state)
{
    GCSFilter::ElementSet elements;
    for (int i = 0; i < 10000; ++i) {
        GCSFilter::Element element(32);
        element[0] = static_cast<unsigned char>(i);
        element[1] = static_cast<unsigned char>(i >> 8);
        elements.insert(std::move(element));
    }

    uint64_t siphash_k0 = 0;
    while (state.KeepRunning()) {
        GCSFilter filter(siphash_k0, 0, 20, 1 << 20, elements);

        siphash_k0++;
    }
}

static void MatchGCSFilter(benchmark::State& state)
{
    GCSFilter::ElementSet elements;
    for (int i = 0; i < 10000; ++i) {
        GCSFilter::Element element(32);
        element[0] = static_cast<unsigned char>(i);
        element[1] = static_cast<unsigned char>(i >> 8);
        elements.insert(std::move(element));
    }
    GCSFilter filter(0, 0, 20, 1 << 20, elements);

    while (state.KeepRunning()) {
        filter.Match(GCSFilter::Element());
    }
}

BENCHMARK(ConstructGCSFilter, 1000);
BENCHMARK(MatchGCSFilter, 50 * 1000);

identifier:include,bench,bench,h,include,blockfilter,h,ConstructGCSFilter,benchmark::State,state,GCSFilter::ElementSet,elements,i,i,i,GCSFilter::Element,element,element,static_cast,i,element,static_cast,i,elements,insert,element,uint64_t,siphash_k0,state,KeepRunning,GCSFilter,filter,siphash_k0,elements,siphash_k0,MatchGCSFilter,benchmark::State,state,GCSFilter::ElementSet,elements,i,i,i,GCSFilter::Element,element,element,static_cast,i,element,static_cast,i,elements,insert,element,GCSFilter,filter,elements,state,KeepRunning,filter,Match,GCSFilter::Element,BENCHMARK,ConstructGCSFilter,BENCHMARK,MatchGCSFilter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/mempool_eviction.cpp
changed code snippet:
    pool.addUnchecked(CTxMemPoolEntry(

identifier:pool,addUnchecked,CTxMemPoolEntry,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/rollingbloom.cpp
changed code snippet:
        filter.contains(data);

identifier:filter,contains,data,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-rpccookiefile=<loc>", "Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (const CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockfilter.cpp
changed code snippet:

#include <blockfilter.h>
#include <hash.h>
#include <primitives/transaction.h>
#include <script/script.h>
#include <streams.h>

static constexpr int GCS_SER_TYPE = SER_NETWORK;

static constexpr int GCS_SER_VERSION = 0;

template <typename OStream>
static void GolombRiceEncode(BitStreamWriter<OStream>& bitwriter, uint8_t P, uint64_t x)
{
    // Write quotient as unary-encoded: q 1's followed by one 0.
    uint64_t q = x >> P;
    while (q > 0) {
        int nbits = q <= 64 ? static_cast<int>(q) : 64;
        bitwriter.Write(~0ULL, nbits);
        q -= nbits;
    }
    bitwriter.Write(0, 1);

    // Write the remainder in P bits. Since the remainder is just the bottom
    // P bits of x, there is no need to mask first.
    bitwriter.Write(x, P);
}

template <typename IStream>
static uint64_t GolombRiceDecode(BitStreamReader<IStream>& bitreader, uint8_t P)
{
    // Read unary-encoded quotient: q 1's followed by one 0.
    uint64_t q = 0;
    while (bitreader.Read(1) == 1) {
        ++q;
    }

    uint64_t r = bitreader.Read(P);

    return (q << P) + r;
}

static uint64_t MapIntoRange(uint64_t x, uint64_t n)
{
#ifdef __SIZEOF_INT128__
    return (static_cast<unsigned __int128>(x) * static_cast<unsigned __int128>(n)) >> 64;
#else
    // To perform the calculation on 64-bit numbers without losing the
    // result to overflow, split the numbers into the most significant and
    // least significant 32 bits and perform multiplication piece-wise.
    //
    // See: https://stackoverflow.com/a/26855440
    uint64_t x_hi = x >> 32;
    uint64_t x_lo = x & 0xFFFFFFFF;
    uint64_t n_hi = n >> 32;
    uint64_t n_lo = n & 0xFFFFFFFF;

    uint64_t ac = x_hi * n_hi;
    uint64_t ad = x_hi * n_lo;
    uint64_t bc = x_lo * n_hi;
    uint64_t bd = x_lo * n_lo;

    uint64_t mid34 = (bd >> 32) + (bc & 0xFFFFFFFF) + (ad & 0xFFFFFFFF);
    uint64_t upper64 = ac + (bc >> 32) + (ad >> 32) + (mid34 >> 32);
    return upper64;
#endif
}

uint64_t GCSFilter::HashToRange(const Element& element) const
{
    uint64_t hash = CSipHasher(m_siphash_k0, m_siphash_k1)
        .Write(element.data(), element.size())
        .Finalize();
    return MapIntoRange(hash, m_F);
}

std::vector<uint64_t> GCSFilter::BuildHashedSet(const ElementSet& elements) const
{
    std::vector<uint64_t> hashed_elements;
    hashed_elements.reserve(elements.size());
    for (const Element& element : elements) {
        hashed_elements.push_back(HashToRange(element));
    }
    std::sort(hashed_elements.begin(), hashed_elements.end());
    return hashed_elements;
}

GCSFilter::GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M)
    : m_siphash_k0(siphash_k0), m_siphash_k1(siphash_k1), m_P(P), m_M(M), m_N(0), m_F(0)
{}

GCSFilter::GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,
                     std::vector<unsigned char> encoded_filter)
    : GCSFilter(siphash_k0, siphash_k1, P, M)
{
    m_encoded = std::move(encoded_filter);

    VectorReader stream(GCS_SER_TYPE, GCS_SER_VERSION, m_encoded, 0);

    uint64_t N = ReadCompactSize(stream);
    m_N = static_cast<uint32_t>(N);
    if (m_N != N) {
        throw std::ios_base::failure("N must be <2^32");
    }
    m_F = static_cast<uint64_t>(m_N) * static_cast<uint64_t>(m_M);

    // Verify that the encoded filter contains exactly N elements. If it has too much or too little
    // data, a std::ios_base::failure exception will be raised.
    BitStreamReader<VectorReader> bitreader(stream);
    for (uint64_t i = 0; i < m_N; ++i) {
        GolombRiceDecode(bitreader, m_P);
    }
    if (!stream.empty()) {
        throw std::ios_base::failure("encoded_filter contains excess data");
    }
}

GCSFilter::GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,
                     const ElementSet& elements)
    : GCSFilter(siphash_k0, siphash_k1, P, M)
{
    size_t N = elements.size();
    m_N = static_cast<uint32_t>(N);
    if (m_N != N) {
        throw std::invalid_argument("N must be <2^32");
    }
    m_F = static_cast<uint64_t>(m_N) * static_cast<uint64_t>(m_M);

    CVectorWriter stream(GCS_SER_TYPE, GCS_SER_VERSION, m_encoded, 0);

    WriteCompactSize(stream, m_N);

    if (elements.empty()) {
        return;
    }

    BitStreamWriter<CVectorWriter> bitwriter(stream);

    uint64_t last_value = 0;
    for (uint64_t value : BuildHashedSet(elements)) {
        uint64_t delta = value - last_value;
        GolombRiceEncode(bitwriter, m_P, delta);
        last_value = value;
    }

    bitwriter.Flush();
}

bool GCSFilter::MatchInternal(const uint64_t* element_hashes, size_t size) const
{
    VectorReader stream(GCS_SER_TYPE, GCS_SER_VERSION, m_encoded, 0);

    // Seek forward by size of N
    uint64_t N = ReadCompactSize(stream);
    assert(N == m_N);

    BitStreamReader<VectorReader> bitreader(stream);

    uint64_t value = 0;
    size_t hashes_index = 0;
    for (uint32_t i = 0; i < m_N; ++i) {
        uint64_t delta = GolombRiceDecode(bitreader, m_P);
        value += delta;

        while (true) {
            if (hashes_index == size) {
                return false;
            } else if (element_hashes[hashes_index] == value) {
                return true;
            } else if (element_hashes[hashes_index] > value) {
                break;
            }

            hashes_index++;
        }
    }

    return false;
}

bool GCSFilter::Match(const Element& element) const
{
    uint64_t query = HashToRange(element);
    return MatchInternal(&query, 1);
}

bool GCSFilter::MatchAny(const ElementSet& elements) const
{
    const std::vector<uint64_t> queries = BuildHashedSet(elements);
    return MatchInternal(queries.data(), queries.size());
}

static GCSFilter::ElementSet BasicFilterElements(const CBlock& block,
                                                 const CBlockUndo& block_undo)
{
    GCSFilter::ElementSet elements;

    for (const CTransactionRef& tx : block.vtx) {
        for (const CTxOut& txout : tx->vout) {
            const CScript& script = txout.scriptPubKey;
            if (script.empty() || script[0] == OP_RETURN) continue;
            elements.emplace(script.begin(), script.end());
        }
    }

    for (const CTxUndo& tx_undo : block_undo.vtxundo) {
        for (const Coin& prevout : tx_undo.vprevout) {
            const CScript& script = prevout.out.scriptPubKey;
            if (script.empty()) continue;
            elements.emplace(script.begin(), script.end());
        }
    }

    return elements;
}

BlockFilter::BlockFilter(BlockFilterType filter_type, const CBlock& block, const CBlockUndo& block_undo)
    : m_filter_type(filter_type), m_block_hash(block.GetHash())
{
    switch (m_filter_type) {
    case BlockFilterType::BASIC:
        m_filter = GCSFilter(m_block_hash.GetUint64(0), m_block_hash.GetUint64(1),
                             BASIC_FILTER_P, BASIC_FILTER_M,
                             BasicFilterElements(block, block_undo));
        break;

    default:
        throw std::invalid_argument("unknown filter_type");
    }
}

uint256 BlockFilter::GetHash() const
{
    const std::vector<unsigned char>& data = GetEncodedFilter();

    uint256 result;
    CHash256().Write(data.data(), data.size()).Finalize(result.begin());
    return result;
}

uint256 BlockFilter::ComputeHeader(const uint256& prev_header) const
{
    const uint256& filter_hash = GetHash();

    uint256 result;
    CHash256()
        .Write(filter_hash.begin(), filter_hash.size())
        .Write(prev_header.begin(), prev_header.size())
        .Finalize(result.begin());
    return result;
}

identifier:include,blockfilter,h,include,hash,h,include,primitives,transaction,h,include,script,script,h,include,streams,h,constexpr,GCS_SER_TYPE,SER_NETWORK,constexpr,GCS_SER_VERSION,template,typename,OStream,GolombRiceEncode,BitStreamWriter,OStream,bitwriter,uint8_t,P,uint64_t,x,uint64_t,q,x,P,q,nbits,q,static_cast,q,bitwriter,Write,0ULL,nbits,q,nbits,bitwriter,Write,bitwriter,Write,x,P,template,typename,IStream,uint64_t,GolombRiceDecode,BitStreamReader,IStream,bitreader,uint8_t,P,uint64_t,q,bitreader,Read,q,uint64_t,r,bitreader,Read,P,q,P,r,uint64_t,MapIntoRange,uint64_t,x,uint64_t,n,ifdef,__SIZEOF_INT128__,static_cast,__int128,x,static_cast,__int128,n,uint64_t,x_hi,x,uint64_t,x_lo,x,0xFFFFFFFF,uint64_t,n_hi,n,uint64_t,n_lo,n,0xFFFFFFFF,uint64_t,ac,x_hi,n_hi,uint64_t,ad,x_hi,n_lo,uint64_t,bc,x_lo,n_hi,uint64_t,bd,x_lo,n_lo,uint64_t,mid34,bd,bc,0xFFFFFFFF,ad,0xFFFFFFFF,uint64_t,upper64,ac,bc,ad,mid34,upper64,endif,uint64_t,GCSFilter::HashToRange,Element,element,uint64_t,hash,CSipHasher,m_siphash_k0,m_siphash_k1,Write,element,data,element,size,Finalize,MapIntoRange,hash,m_F,uint64_t,GCSFilter::BuildHashedSet,ElementSet,elements,uint64_t,hashed_elements,hashed_elements,reserve,elements,size,Element,element,elements,hashed_elements,push_back,HashToRange,element,hashed_elements,begin,hashed_elements,end,hashed_elements,GCSFilter::GCSFilter,uint64_t,siphash_k0,uint64_t,siphash_k1,uint8_t,P,uint32_t,M,m_siphash_k0,siphash_k0,m_siphash_k1,siphash_k1,m_P,P,m_M,M,m_N,m_F,GCSFilter::GCSFilter,uint64_t,siphash_k0,uint64_t,siphash_k1,uint8_t,P,uint32_t,M,encoded_filter,GCSFilter,siphash_k0,siphash_k1,P,M,m_encoded,encoded_filter,VectorReader,stream,GCS_SER_TYPE,GCS_SER_VERSION,m_encoded,uint64_t,N,ReadCompactSize,stream,m_N,static_cast,uint32_t,N,m_N,N,throw,m_F,static_cast,uint64_t,m_N,static_cast,uint64_t,m_M,BitStreamReader,VectorReader,bitreader,stream,uint64_t,i,i,m_N,i,GolombRiceDecode,bitreader,m_P,stream,empty,throw,GCSFilter::GCSFilter,uint64_t,siphash_k0,uint64_t,siphash_k1,uint8_t,P,uint32_t,M,ElementSet,elements,GCSFilter,siphash_k0,siphash_k1,P,M,size_t,N,elements,size,m_N,static_cast,uint32_t,N,m_N,N,throw,m_F,static_cast,uint64_t,m_N,static_cast,uint64_t,m_M,CVectorWriter,stream,GCS_SER_TYPE,GCS_SER_VERSION,m_encoded,WriteCompactSize,stream,m_N,elements,empty,BitStreamWriter,CVectorWriter,bitwriter,stream,uint64_t,last_value,uint64_t,value,BuildHashedSet,elements,uint64_t,delta,value,last_value,GolombRiceEncode,bitwriter,m_P,delta,last_value,value,bitwriter,Flush,GCSFilter::MatchInternal,uint64_t,element_hashes,size_t,size,VectorReader,stream,GCS_SER_TYPE,GCS_SER_VERSION,m_encoded,uint64_t,N,ReadCompactSize,stream,assert,N,m_N,BitStreamReader,VectorReader,bitreader,stream,uint64_t,value,size_t,hashes_index,uint32_t,i,i,m_N,i,uint64_t,delta,GolombRiceDecode,bitreader,m_P,value,delta,hashes_index,size,element_hashes,hashes_index,value,element_hashes,hashes_index,value,hashes_index,GCSFilter::Match,Element,element,uint64_t,query,HashToRange,element,MatchInternal,query,GCSFilter::MatchAny,ElementSet,elements,uint64_t,queries,BuildHashedSet,elements,MatchInternal,queries,data,queries,size,GCSFilter::ElementSet,BasicFilterElements,CBlock,block,CBlockUndo,block_undo,GCSFilter::ElementSet,elements,CTransactionRef,tx,block,vtx,CTxOut,txout,tx,vout,CScript,script,txout,scriptPubKey,script,empty,script,OP_RETURN,elements,emplace,script,begin,script,end,CTxUndo,tx_undo,block_undo,vtxundo,Coin,prevout,tx_undo,vprevout,CScript,script,prevout,out,scriptPubKey,script,empty,elements,emplace,script,begin,script,end,elements,BlockFilter::BlockFilter,BlockFilterType,filter_type,CBlock,block,CBlockUndo,block_undo,m_filter_type,filter_type,m_block_hash,block,GetHash,m_filter_type,BlockFilterType::BASIC,m_filter,GCSFilter,m_block_hash,GetUint64,m_block_hash,GetUint64,BASIC_FILTER_P,BASIC_FILTER_M,BasicFilterElements,block,block_undo,throw,uint256,BlockFilter::GetHash,data,GetEncodedFilter,uint256,result,CHash256,Write,data,data,data,size,Finalize,result,begin,result,uint256,BlockFilter::ComputeHeader,uint256,prev_header,uint256,filter_hash,GetHash,uint256,result,CHash256,Write,filter_hash,begin,filter_hash,size,Write,prev_header,begin,prev_header,size,Finalize,result,begin,result,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockfilter.h
changed code snippet:

#ifndef BITCOIN_BLOCKFILTER_H
#define BITCOIN_BLOCKFILTER_H

#include <set>
#include <stdint.h>
#include <vector>

#include <primitives/block.h>
#include <serialize.h>
#include <uint256.h>
#include <undo.h>

/**
 * This implements a Golomb-coded set as defined in BIP 158. It is a
 * compact, probabilistic data structure for testing set membership.
 */
class GCSFilter
{
public:
    typedef std::vector<unsigned char> Element;
    typedef std::set<Element> ElementSet;

private:
    uint64_t m_siphash_k0;
    uint64_t m_siphash_k1;
    uint8_t m_P;  //!< Golomb-Rice coding parameter
    uint32_t m_M;  //!< Inverse false positive rate
    uint32_t m_N;  //!< Number of elements in the filter
    uint64_t m_F;  //!< Range of element hashes, F = N * M
    std::vector<unsigned char> m_encoded;

    /** Hash a data element to an integer in the range [0, N * M). */
    uint64_t HashToRange(const Element& element) const;

    std::vector<uint64_t> BuildHashedSet(const ElementSet& elements) const;

    /** Helper method used to implement Match and MatchAny */
    bool MatchInternal(const uint64_t* sorted_element_hashes, size_t size) const;

public:

    /** Constructs an empty filter. */
    GCSFilter(uint64_t siphash_k0 = 0, uint64_t siphash_k1 = 0, uint8_t P = 0, uint32_t M = 0);

    /** Reconstructs an already-created filter from an encoding. */
    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,
              std::vector<unsigned char> encoded_filter);

    /** Builds a new filter from the params and set of elements. */
    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,
              const ElementSet& elements);

    uint8_t GetP() const { return m_P; }
    uint32_t GetN() const { return m_N; }
    uint32_t GetM() const { return m_M; }
    const std::vector<unsigned char>& GetEncoded() const { return m_encoded; }

    /**
     * Checks if the element may be in the set. False positives are possible
     * with probability 1/M.
     */
    bool Match(const Element& element) const;

    /**
     * Checks if any of the given elements may be in the set. False positives
     * are possible with probability 1/M per element checked. This is more
     * efficient that checking Match on multiple elements separately.
     */
    bool MatchAny(const ElementSet& elements) const;
};

constexpr uint8_t BASIC_FILTER_P = 19;
constexpr uint32_t BASIC_FILTER_M = 784931;

enum BlockFilterType : uint8_t
{
    BASIC = 0,
};

/**
 * Complete block filter struct as defined in BIP 157. Serialization matches
 * payload of "cfilter" messages.
 */
class BlockFilter
{
private:
    BlockFilterType m_filter_type;
    uint256 m_block_hash;
    GCSFilter m_filter;

public:

    // Construct a new BlockFilter of the specified type from a block.
    BlockFilter(BlockFilterType filter_type, const CBlock& block, const CBlockUndo& block_undo);

    BlockFilterType GetFilterType() const { return m_filter_type; }

    const GCSFilter& GetFilter() const { return m_filter; }

    const std::vector<unsigned char>& GetEncodedFilter() const
    {
        return m_filter.GetEncoded();
    }

    // Compute the filter hash.
    uint256 GetHash() const;

    // Compute the filter header given the previous one.
    uint256 ComputeHeader(const uint256& prev_header) const;

    template <typename Stream>
    void Serialize(Stream& s) const {
        s << m_block_hash
          << static_cast<uint8_t>(m_filter_type)
          << m_filter.GetEncoded();
    }

    template <typename Stream>
    void Unserialize(Stream& s) {
        std::vector<unsigned char> encoded_filter;
        uint8_t filter_type;

        s >> m_block_hash
          >> filter_type
          >> encoded_filter;

        m_filter_type = static_cast<BlockFilterType>(filter_type);

        switch (m_filter_type) {
        case BlockFilterType::BASIC:
            m_filter = GCSFilter(m_block_hash.GetUint64(0), m_block_hash.GetUint64(1),
                                 BASIC_FILTER_P, BASIC_FILTER_M, std::move(encoded_filter));
            break;

        default:
            throw std::ios_base::failure("unknown filter_type");
        }
    }
};

#endif // BITCOIN_BLOCKFILTER_H

identifier:ifndef,BITCOIN_BLOCKFILTER_H,define,BITCOIN_BLOCKFILTER_H,include,set,include,stdint,h,include,include,primitives,block,h,include,serialize,h,include,uint256,h,include,undo,h,class,GCSFilter,public,Element,Element,ElementSet,private,uint64_t,m_siphash_k0,uint64_t,m_siphash_k1,uint8_t,m_P,uint32_t,m_M,uint32_t,m_N,uint64_t,m_F,m_encoded,uint64_t,HashToRange,Element,element,uint64_t,BuildHashedSet,ElementSet,elements,MatchInternal,uint64_t,sorted_element_hashes,size_t,size,public,GCSFilter,uint64_t,siphash_k0,uint64_t,siphash_k1,uint8_t,P,uint32_t,M,GCSFilter,uint64_t,siphash_k0,uint64_t,siphash_k1,uint8_t,P,uint32_t,M,encoded_filter,GCSFilter,uint64_t,siphash_k0,uint64_t,siphash_k1,uint8_t,P,uint32_t,M,ElementSet,elements,uint8_t,GetP,m_P,uint32_t,GetN,m_N,uint32_t,GetM,m_M,GetEncoded,m_encoded,Match,Element,element,MatchAny,ElementSet,elements,constexpr,uint8_t,BASIC_FILTER_P,constexpr,uint32_t,BASIC_FILTER_M,BlockFilterType,uint8_t,BASIC,class,BlockFilter,private,BlockFilterType,m_filter_type,uint256,m_block_hash,GCSFilter,m_filter,public,BlockFilter,BlockFilterType,filter_type,CBlock,block,CBlockUndo,block_undo,BlockFilterType,GetFilterType,m_filter_type,GCSFilter,GetFilter,m_filter,GetEncodedFilter,m_filter,GetEncoded,uint256,GetHash,uint256,ComputeHeader,uint256,prev_header,template,typename,Stream,Serialize,Stream,s,s,m_block_hash,static_cast,uint8_t,m_filter_type,m_filter,GetEncoded,template,typename,Stream,Unserialize,Stream,s,encoded_filter,uint8_t,filter_type,s,m_block_hash,filter_type,encoded_filter,m_filter_type,static_cast,BlockFilterType,filter_type,m_filter_type,BlockFilterType::BASIC,m_filter,GCSFilter,m_block_hash,GetUint64,m_block_hash,GetUint64,BASIC_FILTER_P,BASIC_FILTER_M,encoded_filter,throw,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:

#include <chainparamsseeds.h>

identifier:include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx    transaction for which we are checking input total
     * @return  Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/compat.h
changed code snippet:
#if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 5
#define IS_TRIVIALLY_CONSTRUCTIBLE std::has_trivial_default_constructor
#define IS_TRIVIALLY_CONSTRUCTIBLE std::is_trivially_default_constructible

identifier:defined,__GNUC__,defined,__clang__,__GNUC__,define,IS_TRIVIALLY_CONSTRUCTIBLE,define,IS_TRIVIALLY_CONSTRUCTIBLE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,PROTOCOL_VERSION,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,PROTOCOL_VERSION,GetSerializeSize,txin,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (const uint32_t loc : locs)
            for (const uint32_t loc : locs) {
        for (const uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmap'ed).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

#include <stdio.h>
#include <util.h>
#include <walletinitinterface.h>

class CWallet;

class DummyWalletInit : public WalletInitInterface {
public:

    bool HasWalletSupport() const override {return false;}
    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();

std::vector<std::shared_ptr<CWallet>> GetWallets()
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

namespace interfaces {

class Wallet;

std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

} // namespace interfaces

identifier:include,stdio,h,include,util,h,include,walletinitinterface,h,class,CWallet,class,DummyWalletInit,public,WalletInitInterface,public,HasWalletSupport,override,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,CWallet,GetWallets,throw,namespace,interfaces,class,Wallet,Wallet,MakeWallet,CWallet,wallet,throw,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
#ifndef WIN32
#include <fcntl.h>
#else
#include <codecvt>
#include <windows.h>
#endif

#ifndef WIN32
#else
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t> utf8_cvt;
    return ::_wfopen(p.wstring().c_str(), utf8_cvt.from_bytes(mode).c_str());
#endif
#ifndef WIN32

static std::string GetErrorReason() {
    return std::strerror(errno);
}

FileLock::FileLock(const fs::path& file)
    fd = open(file.string().c_str(), O_RDWR);
    if (fd == -1) {
        reason = GetErrorReason();
    }
}

FileLock::~FileLock()
{
    if (fd != -1) {
        close(fd);
    }
}

bool FileLock::TryLock()
{
    if (fd == -1) {
        return false;
    }
    struct flock lock;
    lock.l_type = F_WRLCK;
    lock.l_whence = SEEK_SET;
    lock.l_start = 0;
    lock.l_len = 0;
    if (fcntl(fd, F_SETLK, &lock) == -1) {
        reason = GetErrorReason();
        return false;
    }
    return true;
}
#else

static std::string GetErrorReason() {
    wchar_t* err;
    FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        nullptr, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<WCHAR*>(&err), 0, nullptr);
    std::wstring err_str(err);
    LocalFree(err);
    return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>>().to_bytes(err_str);
}

FileLock::FileLock(const fs::path& file)
{
    hFile = CreateFileW(file.wstring().c_str(),  GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (hFile == INVALID_HANDLE_VALUE) {
        reason = GetErrorReason();
    }
}

FileLock::~FileLock()
{
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}

bool FileLock::TryLock()
{
    if (hFile == INVALID_HANDLE_VALUE) {
        return false;
    }
    _OVERLAPPED overlapped = {0};
    if (!LockFileEx(hFile, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY, 0, 0, 0, &overlapped)) {
        reason = GetErrorReason();
        return false;
    }
    return true;
}
#endif

std::string get_filesystem_error_message(const fs::filesystem_error& e)
{
#ifndef WIN32
    return e.what();
#else
    // Convert from Multi Byte to utf-16
    std::string mb_string(e.what());
    int size = MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), nullptr, 0);

    std::wstring utf16_string(size, L'\0');
    MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), &*utf16_string.begin(), size);
    // Convert from utf-16 to utf-8
    return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>().to_bytes(utf16_string);
#endif

identifier:ifndef,WIN32,include,fcntl,h,include,codecvt,include,windows,h,endif,ifndef,WIN32,wchar_t,wchar_t,utf8_cvt,_wfopen,p,wstring,c_str,utf8_cvt,from_bytes,mode,c_str,endif,ifndef,WIN32,GetErrorReason,errno,FileLock::FileLock,fs::path,file,fd,open,file,c_str,O_RDWR,fd,reason,GetErrorReason,FileLock,FileLock,fd,close,fd,FileLock::TryLock,fd,flock,lock,lock,l_type,F_WRLCK,lock,l_whence,SEEK_SET,lock,l_start,lock,l_len,fcntl,fd,F_SETLK,lock,reason,GetErrorReason,GetErrorReason,wchar_t,err,FormatMessageW,FORMAT_MESSAGE_ALLOCATE_BUFFER,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,nullptr,GetLastError,MAKELANGID,LANG_NEUTRAL,SUBLANG_DEFAULT,reinterpret_cast,WCHAR,err,nullptr,err_str,err,LocalFree,err,wchar_t,to_bytes,err_str,FileLock::FileLock,fs::path,file,hFile,CreateFileW,file,wstring,c_str,GENERIC_READ,GENERIC_WRITE,FILE_SHARE_READ,FILE_SHARE_WRITE,FILE_SHARE_DELETE,nullptr,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,nullptr,hFile,INVALID_HANDLE_VALUE,reason,GetErrorReason,FileLock,FileLock,hFile,INVALID_HANDLE_VALUE,CloseHandle,hFile,FileLock::TryLock,hFile,INVALID_HANDLE_VALUE,_OVERLAPPED,overlapped,LockFileEx,hFile,LOCKFILE_EXCLUSIVE_LOCK,LOCKFILE_FAIL_IMMEDIATELY,overlapped,reason,GetErrorReason,endif,get_filesystem_error_message,fs::filesystem_error,e,ifndef,WIN32,e,what,mb_string,e,what,size,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,nullptr,utf16_string,size,L,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,utf16_string,begin,size,wchar_t,wchar_t,to_bytes,utf16_string,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

    class FileLock
    {
    public:
        FileLock() = delete;
        FileLock(const FileLock&) = delete;
        FileLock(FileLock&&) = delete;
        explicit FileLock(const fs::path& file);
        ~FileLock();
        bool TryLock();
        std::string GetReason() { return reason; }

    private:
        std::string reason;
#ifndef WIN32
        int fd = -1;
#else
        void* hFile = (void*)-1; // INVALID_HANDLE_VALUE
#endif
    };

    std::string get_filesystem_error_message(const fs::filesystem_error& e);

identifier:class,FileLock,public,FileLock,delete,FileLock,FileLock,delete,FileLock,FileLock,delete,explicit,FileLock,fs::path,file,FileLock,TryLock,GetReason,reason,private,reason,ifndef,WIN32,fd,hFile,endif,get_filesystem_error_message,fs::filesystem_error,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#include <walletinitinterface.h>
    if (g_wallet_init_interface.HasWalletSupport()) {
        RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
    }
    if (g_wallet_init_interface.HasWalletSupport()) {
        UnregisterHTTPHandler("/wallet/", false);
    }

identifier:include,walletinitinterface,h,g_wallet_init_interface,HasWalletSupport,RegisterHTTPHandler,HTTPReq_JSONRPC,g_wallet_init_interface,HasWalletSupport,UnregisterHTTPHandler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    Mutex cs;
        LOCK(cs);
                WAIT_LOCK(cs, lock);
        LOCK(cs);

identifier:Mutex,cs,LOCK,cs,WAIT_LOCK,cs,lock,LOCK,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#include <sys/stat.h>
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    const auto regtestChainParams = CreateChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -noconnect disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services, set -noonion to disable (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort(), regtestChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy, set -noproxy to disable (default: disabled)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is: "
        "level 0 reads the blocks from disk, "
        "level 1 verifies block validity, "
        "level 2 verifies undo data, "
        "level 3 checks disconnection of tip blocks, "
        "and level 4 tries to reconnect the blocks, "
        "each level includes the checks of the previous levels "
        "(0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", "Output debugging information (default: -nodebug, supplying <category> is optional). "
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::RPC);
static Mutex g_genesis_wait_mutex;
static std::condition_variable g_genesis_wait_cv;
            LOCK(g_genesis_wait_mutex);
        g_genesis_wait_cv.notify_all();

    // Only log conf file usage message if conf file actually exists.
    fs::path config_file_path = GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME));
    if (fs::exists(config_file_path)) {
        LogPrintf("Config file: %s\n", config_file_path.string());
    } else if (gArgs.IsArgSet("-conf")) {
        // Warn if no conf file exists at path provided by user
        InitWarning(strprintf(_("The specified config file %s does not exist\n"), config_file_path.string()));
    } else {
        // Not categorizing as "Warning" because it's the default behavior
        LogPrintf("Config file: %s (not found, skipping)\n", config_file_path.string());
    }

        WAIT_LOCK(g_genesis_wait_mutex, lock);
            g_genesis_wait_cv.wait_for(lock, std::chrono::milliseconds(500));

identifier:include,sys,stat,h,regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,regtestChainParams,CreateChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,regtestChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::RPC,Mutex,g_genesis_wait_mutex,g_genesis_wait_cv,LOCK,g_genesis_wait_mutex,g_genesis_wait_cv,notify_all,fs::path,config_file_path,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,fs::exists,config_file_path,LogPrintf,config_file_path,gArgs,IsArgSet,InitWarning,strprintf,_,config_file_path,LogPrintf,config_file_path,WAIT_LOCK,g_genesis_wait_mutex,lock,g_genesis_wait_cv,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/handler.cpp
changed code snippet:
    explicit HandlerImpl(boost::signals2::connection connection) : m_connection(std::move(connection)) {}

identifier:explicit,HandlerImpl,boost::signals2::connection,connection,m_connection,connection,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
class CWallet;
std::vector<std::shared_ptr<CWallet>> GetWallets();


class Wallet;

        return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); }));

identifier:class,CWallet,CWallet,GetWallets,class,Wallet,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.cpp
changed code snippet:
    explicit PendingWalletTxImpl(CWallet& wallet) : m_wallet(wallet), m_key(&wallet) {}
        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), m_key, g_connman.get(), state)) {
static WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static WalletTxStatus MakeWalletTxStatus(const CWalletTx& wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static WalletTxOut MakeWalletTxOut(CWallet& wallet, const CWalletTx& wtx, int n, int depth) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
    explicit WalletImpl(const std::shared_ptr<CWallet>& wallet) : m_shared_wallet(wallet), m_wallet(*wallet.get()) {}

identifier:explicit,PendingWalletTxImpl,CWallet,wallet,m_wallet,wallet,m_key,wallet,m_wallet,CommitTransaction,m_tx,value_map,order_form,m_key,g_connman,get,state,WalletTx,MakeWalletTx,CWallet,wallet,CWalletTx,wtx,EXCLUSIVE_LOCKS_REQUIRED,cs_main,WalletTxStatus,MakeWalletTxStatus,CWalletTx,wtx,EXCLUSIVE_LOCKS_REQUIRED,cs_main,WalletTxOut,MakeWalletTxOut,CWallet,wallet,CWalletTx,wtx,n,depth,EXCLUSIVE_LOCKS_REQUIRED,cs_main,explicit,WalletImpl,CWallet,wallet,m_shared_wallet,wallet,m_wallet,wallet,get,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key_io.cpp
changed code snippet:
    explicit DestinationEncoder(const CChainParams& params) : m_params(params) {}

identifier:explicit,DestinationEncoder,CChainParams,params,m_params,params,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.cpp
changed code snippet:
                FILE* new_fileout = fsbridge::fopen(m_file_path, "a");
                if (new_fileout) {
                    setbuf(new_fileout, nullptr); // unbuffered
                    fclose(m_fileout);
                    m_fileout = new_fileout;

identifier:FILE,new_fileout,fsbridge::fopen,m_file_path,new_fileout,setbuf,new_fileout,nullptr,fclose,m_fileout,m_fileout,new_fileout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (const CNode* pnode : vNodes) {
    X(minFeeFilter);
                clientInterface->NotifyNumConnectionsChanged(vNodesSize);
        for (const CNode* pnode : vNodes) {
        for (const CNode* pnode : vNodes) {
            for (const CNode* pnode : vNodes) {
        WAIT_LOCK(mutexMsgProc, lock);
#elif (HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS)
        LOCK(mutexMsgProc);

identifier:CNode,pnode,vNodes,X,minFeeFilter,clientInterface,NotifyNumConnectionsChanged,vNodesSize,CNode,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,WAIT_LOCK,mutexMsgProc,lock,elif,HAVE_DECL_GETIFADDRS,HAVE_DECL_FREEIFADDRS,LOCK,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    Mutex mutexMsgProc;
    CAmount minFeeFilter;

identifier:Mutex,mutexMsgProc,CAmount,minFeeFilter,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
CCriticalSection g_cs_orphans;
static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
        for (const uint256& orphanHash : vOrphanErase) {
void static ProcessGetData(CNode* pfrom, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc) LOCKS_EXCLUDED(cs_main)
            for (const uint256& hash : vEraseQueue)
static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman* connman, bool enable_bip61) EXCLUSIVE_LOCKS_REQUIRED(cs_main)

identifier:CCriticalSection,g_cs_orphans,MaybeSetPeerAsAnnouncingHeaderAndIDs,NodeId,nodeid,CConnman,connman,EXCLUSIVE_LOCKS_REQUIRED,cs_main,BlockRequestAllowed,CBlockIndex,pindex,Consensus::Params,consensusParams,EXCLUSIVE_LOCKS_REQUIRED,cs_main,uint256,orphanHash,vOrphanErase,ProcessGetData,CNode,pfrom,CChainParams,chainparams,CConnman,connman,interruptMsgProc,LOCKS_EXCLUDED,cs_main,uint256,hash,vEraseQueue,SendRejectsAndCheckIfBanned,CNode,pnode,CConnman,connman,enable_bip61,EXCLUSIVE_LOCKS_REQUIRED,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61{false};
    void ConsiderEviction(CNode *pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);

identifier:constexpr,DEFAULT_ENABLE_BIP61,ConsiderEviction,CNode,pto,int64_t,time_in_seconds,EXCLUSIVE_LOCKS_REQUIRED,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    Downcase(net);
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,Downcase,net,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
void noui_InitMessage(const std::string& message)

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
#include <string>

/** Non-GUI handler, which logs and prints messages. */
bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style);
/** Non-GUI handler, which logs and prints questions. */
bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style);
/** Non-GUI handler, which only logs a message. */
void noui_InitMessage(const std::string& message);

/** Connect all bitcoind signal handlers */
void noui_connect();

identifier:include,noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
/** \class CBlockPolicyEstimator
 * The BlockPolicyEstimator is used for estimating the feerate needed
 * for a transaction to be included in a block within a certain number of
 * blocks.
 *
 * At a high level the algorithm works by grouping transactions into buckets
 * based on having similar feerates and then tracking how long it
 * takes transactions in the various buckets to be mined.  It operates under
 * the assumption that in general transactions of higher feerate will be
 * included in blocks before transactions of lower feerate.   So for
 * example if you wanted to know what feerate you should put on a transaction to
 * be included in a block within the next 5 blocks, you would start by looking
 * at the bucket with the highest feerate transactions and verifying that a
 * sufficiently high percentage of them were confirmed within 5 blocks and
 * then you would look at the next highest feerate bucket, and so on, stopping at
 * the last bucket to pass the test.   The average feerate of transactions in this
 * bucket will give you an indication of the lowest feerate you can put on a
 * transaction and still have a sufficiently high chance of being confirmed
 * within your desired 5 blocks.
 *
 * Here is a brief description of the implementation:
 * When a transaction enters the mempool, we track the height of the block chain
 * at entry.  All further calculations are conducted only on this set of "seen"
 * transactions. Whenever a block comes in, we count the number of transactions
 * in each bucket and the total amount of feerate paid in each bucket. Then we
 * calculate how many blocks Y it took each transaction to be mined.  We convert
 * from a number of blocks to a number of periods Y' each encompassing "scale"
 * blocks.  This is tracked in 3 different data sets each up to a maximum
 * number of periods. Within each data set we have an array of counters in each
 * feerate bucket and we increment all the counters from Y' up to max periods
 * representing that a tx was successfully confirmed in less than or equal to
 * that many periods. We want to save a history of this information, so at any
 * time we have a counter of the total number of transactions that happened in a
 * given feerate bucket and the total number that were confirmed in each of the
 * periods or less for any bucket.  We save this history by keeping an
 * exponentially decaying moving average of each one of these stats.  This is
 * done for a different decay in each of the 3 data sets to keep relevant data
 * from different time horizons.  Furthermore we also keep track of the number
 * unmined (in mempool or left mempool without being included in a block)
 * transactions in each bucket and for how many blocks they have been
 * outstanding and use both of these numbers to increase the number of transactions
 * we've seen in that feerate bucket when calculating an estimate for any number
 * of confirmations below the number of blocks they've been outstanding.
 *

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout);

identifier:size_t,nSize,GetSerializeSize,txout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/prevector.h
changed code snippet:
    explicit prevector(size_type n) : prevector() {
    explicit prevector(size_type n, const T& val) : prevector() {
    prevector(InputIterator first, InputIterator last) : prevector() {
    prevector(const prevector<N, T, Size, Diff>& other) : prevector() {
    prevector(prevector<N, T, Size, Diff>&& other) : prevector() {

identifier:explicit,prevector,size_type,n,prevector,explicit,prevector,size_type,n,T,val,prevector,prevector,InputIterator,first,InputIterator,last,prevector,prevector,prevector,N,T,Size,Diff,other,prevector,prevector,prevector,N,T,Size,Diff,other,prevector,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/addresstablemodel.cpp
changed code snippet:
    explicit AddressTablePriv(AddressTableModel *_parent):

identifier:explicit,AddressTablePriv,AddressTableModel,_parent,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("Your wallet is now encrypted. "
                                         "your bitcoins from being stolen by malware infecting your computer.") +

identifier:tr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
#include <noui.h>
static void InitMessage(const std::string& message)
    noui_InitMessage(message);
    for (const WalletModel* walletModel : m_wallet_models) {

identifier:include,noui,h,InitMessage,message,noui_InitMessage,message,WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
#include <noui.h>
#ifndef Q_OS_MAC
    // Note: On Mac, the dock icon's menu already has show / hide action.
#endif
static bool ThreadSafeMessageBox(BitcoinGUI* gui, const std::string& message, const std::string& caption, unsigned int style)
    // Redundantly log and print message in non-gui fashion
    noui_ThreadSafeMessageBox(message, caption, style);

    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:include,noui,h,ifndef,Q_OS_MAC,endif,ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,noui_ThreadSafeMessageBox,message,caption,style,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.h
changed code snippet:
     @param[in] hdEnabled         current hd enabled status

identifier:param,in,hdEnabled,current,hd,enabled,status,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
        IShellLinkW* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLinkW,
            WCHAR pszExePath[MAX_PATH];
            GetModuleFileNameW(nullptr, pszExePath, ARRAYSIZE(pszExePath));
            PathRemoveFileSpecW(pszExePath);
            psl->SetArguments(strArgs.toStdWString().c_str());
                hres = ppf->Save(StartupShortcutPath().wstring().c_str(), TRUE);

identifier:IShellLinkW,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLinkW,WCHAR,pszExePath,MAX_PATH,GetModuleFileNameW,nullptr,pszExePath,ARRAYSIZE,pszExePath,PathRemoveFileSpecW,pszExePath,psl,SetArguments,strArgs,toStdWString,c_str,hres,ppf,Save,StartupShortcutPath,wstring,c_str,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (const auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    explicit RPCExecutor(interfaces::Node& node) : m_node(node) {}
 * @param[out]   strResult   stringified result from the executed command(chain)

identifier:explicit,RPCExecutor,interfaces::Node,node,m_node,node,param,out,strResult,stringified,result,from,the,executed,command,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (const auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of milliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,milliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (const float f : vSamplesIn) {
    for (const float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiontablemodel.cpp
changed code snippet:
    explicit TransactionTablePriv(TransactionTableModel *_parent) :

identifier:explicit,TransactionTablePriv,TransactionTableModel,_parent,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/walletmodel.cpp
changed code snippet:
        if (!newTx->commit({} /* mapValue */, std::move(vOrderForm), rejectReason))

identifier:newTx,commit,vOrderForm,rejectReason,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
#include <sync.h>     // for WAIT_LOCK
static Mutex cs_rng_state;
        WAIT_LOCK(cs_rng_state, lock);
        WAIT_LOCK(cs_rng_state, lock);

identifier:include,sync,h,Mutex,cs_rng_state,WAIT_LOCK,cs_rng_state,lock,WAIT_LOCK,cs_rng_state,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
#include <policy/rbf.h>
static Mutex cs_blockchange;
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, PROTOCOL_VERSION));
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
           "       ... ]\n"
           "    \"bip125-replaceable\" : true|false,  (boolean) Whether this transaction could be replaced due to BIP125 (replace-by-fee)\n";
    for (CTxMemPool::txiter childiter : setChildren) {

    // Add opt-in RBF status
    bool rbfStatus = false;
    RBFTransactionState rbfState = IsRBFOptIn(tx, mempool);
    if (rbfState == RBFTransactionState::UNKNOWN) {
        throw JSONRPCError(RPC_MISC_ERROR, "Transaction is not in mempool");
    } else if (rbfState == RBFTransactionState::REPLACEABLE_BIP125) {
        rbfStatus = true;
    }

    info.pushKV("bip125-replaceable", rbfStatus);
                utxo_size_inc += GetSerializeSize(out, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
            "For more information on output descriptors, see the documentation in the doc/descriptors.md file.\n"

identifier:include,policy,rbf,h,Mutex,cs_blockchange,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,CTxMemPool::txiter,childiter,setChildren,rbfStatus,RBFTransactionState,rbfState,IsRBFOptIn,tx,mempool,rbfState,RBFTransactionState::UNKNOWN,throw,JSONRPCError,RPC_MISC_ERROR,rbfState,RBFTransactionState::REPLACEABLE_BIP125,rbfStatus,info,pushKV,rbfStatus,utxo_size_inc,GetSerializeSize,out,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:
    { "getnodeaddresses", 0, "count"},

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WAIT_LOCK(g_best_block_mutex, lock);
    if (!new_block && accepted) {
    for (const FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WAIT_LOCK,g_best_block_mutex,lock,new_block,accepted,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
        std::string currentAddress = EncodeDestination(dest);
        ret.pushKV("address", currentAddress);
        CScript scriptPubKey = GetScriptForDestination(dest);
        ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));
        UniValue detail = DescribeAddress(dest);
        ret.pushKVs(detail);
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\n.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} },

identifier:currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            "    \"minfeefilter\": n,         (numeric) The minimum fee rate for transactions this peer accepts\n"
            for (const int height : statestats.vHeightInFlight) {
        obj.pushKV("minfeefilter", ValueFromAmount(stats.minFeeFilter));
static UniValue getnodeaddresses(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() > 1) {
        throw std::runtime_error(
            "getnodeaddresses ( count )\n"
            "\nReturn known addresses which can potentially be used to find new nodes in the network\n"
            "\nArguments:\n"
            "1. \"count\"    (numeric, optional) How many addresses to return. Limited to the smaller of " + std::to_string(ADDRMAN_GETADDR_MAX) +
                " or " + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + "% of all known addresses. (default = 1)\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"time\": ttt,                (numeric) Timestamp in seconds since epoch (Jan 1 1970 GMT) keeping track of when the node was last seen\n"
            "    \"services\": n,              (numeric) The services offered\n"
            "    \"address\": \"host\",          (string) The address of the node\n"
            "    \"port\": n                   (numeric) The port of the node\n"
            "  }\n"
            "  ,....\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getnodeaddresses", "8")
            + HelpExampleRpc("getnodeaddresses", "8")
        );
    }
    if (!g_connman) {
        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, "Error: Peer-to-peer functionality missing or disabled");
    }

    int count = 1;
    if (!request.params[0].isNull()) {
        count = request.params[0].get_int();
        if (count <= 0) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Address count out of range");
        }
    }
    // returns a shuffled list of CAddress
    std::vector<CAddress> vAddr = g_connman->GetAddresses();
    UniValue ret(UniValue::VARR);

    int address_return_count = std::min<int>(count, vAddr.size());
    for (int i = 0; i < address_return_count; ++i) {
        UniValue obj(UniValue::VOBJ);
        const CAddress& addr = vAddr[i];
        obj.pushKV("time", (int)addr.nTime);
        obj.pushKV("services", (uint64_t)addr.nServices);
        obj.pushKV("address", addr.ToStringIP());
        obj.pushKV("port", addr.GetPort());
        ret.push_back(obj);
    }
    return ret;
}

    { "network",            "getnodeaddresses",       &getnodeaddresses,       {"count"} },

identifier:height,statestats,vHeightInFlight,obj,pushKV,ValueFromAmount,stats,minFeeFilter,UniValue,getnodeaddresses,JSONRPCRequest,request,request,fHelp,request,params,size,throw,ADDRMAN_GETADDR_MAX,ADDRMAN_GETADDR_MAX_PCT,HelpExampleCli,HelpExampleRpc,g_connman,throw,JSONRPCError,RPC_CLIENT_P2P_DISABLED,count,request,params,isNull,count,request,params,get_int,count,throw,JSONRPCError,RPC_INVALID_PARAMETER,CAddress,vAddr,g_connman,GetAddresses,UniValue,ret,UniValue::VARR,address_return_count,count,vAddr,size,i,i,address_return_count,i,UniValue,obj,UniValue::VOBJ,CAddress,addr,vAddr,i,obj,pushKV,addr,nTime,obj,pushKV,uint64_t,addr,nServices,obj,pushKV,addr,ToStringIP,obj,pushKV,addr,GetPort,ret,push_back,obj,ret,getnodeaddresses,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,__func__,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
            // if redeemScript and private keys were given, add redeemScript to the keystore so it can be signed
    // This method should be removed entirely in V0.19, along with the entries in the
    // CRPCCommand table and rpc/client.cpp.
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction was removed in v0.18.\n"
        "Clients should transition to using signrawtransactionwithkey and signrawtransactionwithwallet");
            "\nAlso see createrawtransaction and signrawtransactionwithkey calls.\n"
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
                keypath.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(entry.second.fingerprint)));
                keypath.pushKV("path", WriteHDKeypath(entry.second.path));
                keypath.pushKV("master_fingerprint", strprintf("%08x", ReadBE32(entry.second.fingerprint)));
                keypath.pushKV("path", WriteHDKeypath(entry.second.path));
        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, *psbtx.tx, input, i, 1);
                            "                              will be tried. If false, only non-witness deserialization will be tried. Only has an effect if\n"
    { "hidden",             "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} },

identifier:throw,JSONRPCError,RPC_METHOD_DEPRECATED,HelpExampleCli,HelpExampleCli,keypath,pushKV,strprintf,ReadBE32,entry,second,fingerprint,keypath,pushKV,WriteHDKeypath,entry,second,path,keypath,pushKV,strprintf,ReadBE32,entry,second,fingerprint,keypath,pushKV,WriteHDKeypath,entry,second,path,complete,SignPSBTInput,DUMMY_SIGNING_PROVIDER,psbtx,tx,input,i,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
                    strRet += "== " + Capitalize(category) + " ==\n";

identifier:strRet,Capitalize,category,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practically, this means that callbacks can behave as if they are executed

identifier:Practically,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If successful, sp is updated to skip the constant and return true. */
/** Parse a function call. If successful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.cpp
changed code snippet:
        pubkey = pk_it->second.first;
        return true;
    }
    // Query the underlying provider
    if (provider.GetPubKey(address, pubkey)) {
        KeyOriginInfo info;
        if (provider.GetKeyOrigin(address, info)) {
            sigdata.misc_pubkeys.emplace(address, std::make_pair(pubkey, std::move(info)));
        }
bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, int index, int sighash)
    SignatureData sigdata;

    // If both UTXO types are present, drop the unnecessary one.
    if (input.non_witness_utxo && !input.witness_utxo.IsNull()) {
        if (sigdata.witness) {
            input.non_witness_utxo = nullptr;
        } else {
            input.witness_utxo.SetNull();
        }
    }

        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);
    for (const auto& entry : sigdata.misc_pubkeys) {
        hd_keypaths.emplace(entry.second);
    }
        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);
    for (const auto& entry : sigdata.misc_pubkeys) {
        hd_keypaths.emplace(entry.second);
    }
bool HidingSigningProvider::GetCScript(const CScriptID& scriptid, CScript& script) const
bool HidingSigningProvider::GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const
    return m_provider->GetPubKey(keyid, pubkey);
}

bool HidingSigningProvider::GetKey(const CKeyID& keyid, CKey& key) const
{
    if (m_hide_secret) return false;
    return m_provider->GetKey(keyid, key);
}

bool HidingSigningProvider::GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const
{
    if (m_hide_origin) return false;
    return m_provider->GetKeyOrigin(keyid, info);

identifier:pubkey,pk_it,second,first,provider,GetPubKey,address,pubkey,KeyOriginInfo,info,provider,GetKeyOrigin,address,info,sigdata,misc_pubkeys,emplace,address,pubkey,info,SignPSBTInput,SigningProvider,provider,CMutableTransaction,tx,PSBTInput,input,index,sighash,SignatureData,sigdata,input,non_witness_utxo,input,witness_utxo,IsNull,sigdata,witness,input,non_witness_utxo,nullptr,input,witness_utxo,SetNull,sigdata,misc_pubkeys,emplace,key_pair,first,GetID,key_pair,entry,sigdata,misc_pubkeys,hd_keypaths,emplace,entry,second,sigdata,misc_pubkeys,emplace,key_pair,first,GetID,key_pair,entry,sigdata,misc_pubkeys,hd_keypaths,emplace,entry,second,HidingSigningProvider::GetCScript,CScriptID,scriptid,CScript,script,HidingSigningProvider::GetPubKey,CKeyID,keyid,CPubKey,pubkey,m_provider,GetPubKey,keyid,pubkey,HidingSigningProvider::GetKey,CKeyID,keyid,CKey,key,m_hide_secret,m_provider,GetKey,keyid,key,HidingSigningProvider::GetKeyOrigin,CKeyID,keyid,KeyOriginInfo,info,m_hide_origin,m_provider,GetKeyOrigin,keyid,info,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
struct KeyOriginInfo
{
    unsigned char fingerprint[4];
    std::vector<uint32_t> path;
};

    virtual bool GetKeyOrigin(const CKeyID& id, KeyOriginInfo& info) const { return false; }
class HidingSigningProvider : public SigningProvider
    const bool m_hide_secret;
    const bool m_hide_origin;
    HidingSigningProvider(const SigningProvider* provider, bool hide_secret, bool hide_origin) : m_hide_secret(hide_secret), m_hide_origin(hide_origin), m_provider(provider) {}
    bool GetCScript(const CScriptID& scriptid, CScript& script) const override;
    bool GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const override;
    bool GetKey(const CKeyID& keyid, CKey& key) const override;
    bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const override;
    std::map<CKeyID, std::pair<CPubKey, KeyOriginInfo>> misc_pubkeys;
    WriteCompactSize(s, GetSerializeSizeMany(s.GetVersion(), args...));
void DeserializeHDKeypaths(Stream& s, const std::vector<unsigned char>& key, std::map<CPubKey, KeyOriginInfo>& hd_keypaths)
    if (value_len % 4 || value_len == 0) {
        throw std::ios_base::failure("Invalid length for HD key path");
    }

    KeyOriginInfo keypath;
    s >> keypath.fingerprint;
    for (unsigned int i = 4; i < value_len; i += sizeof(uint32_t)) {
        keypath.path.push_back(index);
    hd_keypaths.emplace(pubkey, std::move(keypath));
void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, KeyOriginInfo>& hd_keypaths, uint8_t type)
        WriteCompactSize(s, (keypath_pair.second.path.size() + 1) * sizeof(uint32_t));
        s << keypath_pair.second.fingerprint;
        for (const auto& path : keypath_pair.second.path) {
    std::map<CPubKey, KeyOriginInfo> hd_keypaths;
    std::map<CPubKey, KeyOriginInfo> hd_keypaths;
bool SignPSBTInput(const SigningProvider& provider, const CMutableTransaction& tx, PSBTInput& input, int index, int sighash = SIGHASH_ALL);

identifier:KeyOriginInfo,fingerprint,uint32_t,path,virtual,GetKeyOrigin,CKeyID,id,KeyOriginInfo,info,class,HidingSigningProvider,public,SigningProvider,m_hide_secret,m_hide_origin,HidingSigningProvider,SigningProvider,provider,hide_secret,hide_origin,m_hide_secret,hide_secret,m_hide_origin,hide_origin,m_provider,provider,GetCScript,CScriptID,scriptid,CScript,script,override,GetPubKey,CKeyID,keyid,CPubKey,pubkey,override,GetKey,CKeyID,keyid,CKey,key,override,GetKeyOrigin,CKeyID,keyid,KeyOriginInfo,info,override,CKeyID,CPubKey,KeyOriginInfo,misc_pubkeys,WriteCompactSize,s,GetSerializeSizeMany,s,GetVersion,args,DeserializeHDKeypaths,Stream,s,key,CPubKey,KeyOriginInfo,hd_keypaths,value_len,value_len,throw,KeyOriginInfo,keypath,s,keypath,fingerprint,i,i,value_len,i,uint32_t,keypath,path,push_back,index,hd_keypaths,emplace,pubkey,keypath,SerializeHDKeypaths,Stream,s,CPubKey,KeyOriginInfo,hd_keypaths,uint8_t,type,WriteCompactSize,s,keypath_pair,second,path,size,uint32_t,s,keypath_pair,second,fingerprint,path,keypath_pair,second,path,CPubKey,KeyOriginInfo,hd_keypaths,CPubKey,KeyOriginInfo,hd_keypaths,SignPSBTInput,SigningProvider,provider,CMutableTransaction,tx,PSBTInput,input,index,sighash,SIGHASH_ALL,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    explicit CSizeComputer(int nVersionIn) : nSize(0), nVersion(nVersionIn) {}
size_t GetSerializeSize(const T& t, int nVersion = 0)
    return (CSizeComputer(nVersion) << t).size();
template <typename... T>
size_t GetSerializeSizeMany(int nVersion, const T&... t)
    CSizeComputer sc(nVersion);

identifier:explicit,CSizeComputer,nVersionIn,nSize,nVersion,nVersionIn,size_t,GetSerializeSize,T,t,nVersion,CSizeComputer,nVersion,t,size,template,typename,T,size_t,GetSerializeSizeMany,nVersion,T,t,CSizeComputer,sc,nVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
/** Minimal stream for reading from an existing vector by reference
 */
class VectorReader
{
private:
    const int m_type;
    const int m_version;
    const std::vector<unsigned char>& m_data;
    size_t m_pos = 0;

public:

    /*
     * @param[in]  type Serialization Type
     * @param[in]  version Serialization Version (including any flags)
     * @param[in]  data Referenced byte vector to overwrite/append
     * @param[in]  pos Starting position. Vector index where reads should start.
     */
    VectorReader(int type, int version, const std::vector<unsigned char>& data, size_t pos)
        : m_type(type), m_version(version), m_data(data)
    {
        seek(pos);
    }

    /*
     * (other params same as above)
     * @param[in]  args  A list of items to deserialize starting at pos.
     */
    template <typename... Args>
    VectorReader(int type, int version, const std::vector<unsigned char>& data, size_t pos,
                  Args&&... args)
        : VectorReader(type, version, data, pos)
    {
        ::UnserializeMany(*this, std::forward<Args>(args)...);
    }

    template<typename T>
    VectorReader& operator>>(T& obj)
    {
        // Unserialize from this stream
        ::Unserialize(*this, obj);
        return (*this);
    }

    int GetVersion() const { return m_version; }
    int GetType() const { return m_type; }

    size_t size() const { return m_data.size() - m_pos; }
    bool empty() const { return m_data.size() == m_pos; }

    void read(char* dst, size_t n)
    {
        if (n == 0) {
            return;
        }

        // Read from the beginning of the buffer
        size_t pos_next = m_pos + n;
        if (pos_next > m_data.size()) {
            throw std::ios_base::failure("VectorReader::read(): end of data");
        }
        memcpy(dst, m_data.data() + m_pos, n);
        m_pos = pos_next;
    }

    void seek(size_t n)
    {
        m_pos += n;
        if (m_pos > m_data.size()) {
            throw std::ios_base::failure("VectorReader::seek(): end of data");
        }
    }
};

template <typename IStream>
class BitStreamReader
{
private:
    IStream& m_istream;
    /// Buffered byte read in from the input stream. A new byte is read into the
    /// buffer when m_offset reaches 8.
    uint8_t m_buffer{0};
    /// Number of high order bits in m_buffer already returned by previous
    /// Read() calls. The next bit to be returned is at this offset from the
    /// most significant bit position.
    int m_offset{8};
public:
    explicit BitStreamReader(IStream& istream) : m_istream(istream) {}
    /** Read the specified number of bits from the stream. The data is returned
     * in the nbits least significant bits of a 64-bit uint.
     */
    uint64_t Read(int nbits) {
        if (nbits < 0 || nbits > 64) {
            throw std::out_of_range("nbits must be between 0 and 64");
        }
        uint64_t data = 0;
        while (nbits > 0) {
            if (m_offset == 8) {
                m_istream >> m_buffer;
                m_offset = 0;
            }
            int bits = std::min(8 - m_offset, nbits);
            data <<= bits;
            data |= static_cast<uint8_t>(m_buffer << m_offset) >> (8 - bits);
            m_offset += bits;
            nbits -= bits;
        }
        return data;
    }
};

template <typename OStream>
class BitStreamWriter
{
private:
    OStream& m_ostream;

    /// Buffered byte waiting to be written to the output stream. The byte is
    /// written buffer when m_offset reaches 8 or Flush() is called.
    uint8_t m_buffer{0};

    /// Number of high order bits in m_buffer already written by previous
    /// Write() calls and not yet flushed to the stream. The next bit to be
    /// written to is at this offset from the most significant bit position.
    int m_offset{0};

public:
    explicit BitStreamWriter(OStream& ostream) : m_ostream(ostream) {}

    ~BitStreamWriter()
    {
        Flush();
    }

    /** Write the nbits least significant bits of a 64-bit int to the output
     * stream. Data is buffered until it completes an octet.
     */
    void Write(uint64_t data, int nbits) {
        if (nbits < 0 || nbits > 64) {
            throw std::out_of_range("nbits must be between 0 and 64");
        }

        while (nbits > 0) {
            int bits = std::min(8 - m_offset, nbits);
            m_buffer |= (data << (64 - nbits)) >> (64 - 8 + m_offset);
            m_offset += bits;
            nbits -= bits;

            if (m_offset == 8) {
                Flush();
            }
        }
    }

    /** Flush any unwritten bits to the output stream, padding with 0's to the
     * next byte boundary.
     */
    void Flush() {
        if (m_offset == 0) {
            return;
        }

        m_ostream << m_buffer;
        m_buffer = 0;
        m_offset = 0;
    }
};

identifier:class,VectorReader,private,m_type,m_version,m_data,size_t,m_pos,public,VectorReader,type,version,data,size_t,pos,m_type,type,m_version,version,m_data,data,seek,pos,template,typename,Args,VectorReader,type,version,data,size_t,pos,Args,args,VectorReader,type,version,data,pos,UnserializeMany,this,Args,args,template,typename,T,VectorReader,operator,T,obj,Unserialize,this,obj,this,GetVersion,m_version,GetType,m_type,size_t,size,m_data,size,m_pos,empty,m_data,size,m_pos,read,dst,size_t,n,n,size_t,pos_next,m_pos,n,pos_next,m_data,size,throw,memcpy,dst,m_data,data,m_pos,n,m_pos,pos_next,seek,size_t,n,m_pos,n,m_pos,m_data,size,throw,template,typename,IStream,class,BitStreamReader,private,IStream,m_istream,uint8_t,m_buffer,m_offset,public,explicit,BitStreamReader,IStream,istream,m_istream,istream,uint64_t,Read,nbits,nbits,nbits,throw,uint64_t,data,nbits,m_offset,m_istream,m_buffer,m_offset,bits,m_offset,nbits,data,bits,data,static_cast,uint8_t,m_buffer,m_offset,bits,m_offset,bits,nbits,bits,data,template,typename,OStream,class,BitStreamWriter,private,OStream,m_ostream,uint8_t,m_buffer,m_offset,public,explicit,BitStreamWriter,OStream,ostream,m_ostream,ostream,BitStreamWriter,Flush,Write,uint64_t,data,nbits,nbits,nbits,throw,nbits,bits,m_offset,nbits,m_buffer,data,nbits,m_offset,m_offset,bits,nbits,bits,m_offset,Flush,Flush,m_offset,m_ostream,m_buffer,m_buffer,m_offset,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto allocated = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(allocated->first);

identifier:allocated,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,allocated,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    if (g_debug_lockorder_abort) {
        fprintf(stderr, "Assertion failed: detected inconsistent lock order at %s:%i, details in debug log.\n", __FILE__, __LINE__);
        abort();
    }
    throw std::logic_error("potential deadlock detected");
bool g_debug_lockorder_abort = true;


identifier:g_debug_lockorder_abort,fprintf,stderr,__FILE__,__LINE__,abort,throw,g_debug_lockorder_abort,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);

 * Call abort() if a potential lock order deadlock bug is detected, instead of
 * just logging information and throwing a logic_error. Defaults to true, and
 * set to false in DEBUG_LOCKORDER unit tests.
 */
extern bool g_debug_lockorder_abort;
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)

/**
 * Template mixin that adds -Wthread-safety locking annotations and lock order
 * checking to a subset of the mutex API.
    ~AnnotatedMixin() {
        DeleteLock((void*)this);
    }


    using UniqueLock = std::unique_lock<PARENT>;
typedef AnnotatedMixin<std::recursive_mutex> CCriticalSection;
typedef AnnotatedMixin<std::mutex> Mutex;
/** Wrapper around std::unique_lock style lock for Mutex. */
template <typename Mutex, typename Base = typename Mutex::UniqueLock>
class SCOPED_LOCKABLE UniqueLock : public Base
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()));
        if (!Base::try_lock()) {
            Base::lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()), true);
        Base::try_lock();
        if (!Base::owns_lock())
        return Base::owns_lock();
    UniqueLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : Base(mutexIn, std::defer_lock)
    UniqueLock(Mutex* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        *static_cast<Base*>(this) = Base(*pmutexIn, std::defer_lock);
    ~UniqueLock() UNLOCK_FUNCTION()
        if (Base::owns_lock())
        return Base::owns_lock();
template<typename MutexArg>
using DebugLock = UniqueLock<typename std::remove_reference<typename std::remove_pointer<MutexArg>::type>::type>;

#define LOCK(cs) DebugLock<decltype(cs)> PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2)                                               \
    DebugLock<decltype(cs1)> criticalblock1(cs1, #cs1, __FILE__, __LINE__); \
    DebugLock<decltype(cs2)> criticalblock2(cs2, #cs2, __FILE__, __LINE__);
#define TRY_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__, true)
#define WAIT_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__)

identifier:ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,Call,abort,a,potential,lock,order,deadlock,bug,is,detected,instead,of,just,logging,information,and,throwing,a,logic_error,Defaults,to,and,set,to,in,DEBUG_LOCKORDER,unit,tests,g_debug_lockorder_abort,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,template,typename,Mutex,typename,Base,typename,Mutex::UniqueLock,class,SCOPED_LOCKABLE,UniqueLock,public,Base,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::lock,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::owns_lock,Base::owns_lock,UniqueLock,Mutex,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,Base,mutexIn,UniqueLock,Mutex,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,static_cast,Base,this,Base,pmutexIn,UniqueLock,UNLOCK_FUNCTION,Base::owns_lock,Base::owns_lock,template,typename,MutexArg,using,DebugLock,UniqueLock,typename,typename,MutexArg,type,type,define,LOCK,cs,DebugLock,decltype,cs,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,DebugLock,decltype,cs1,criticalblock1,cs1,cs1,__FILE__,__LINE__,DebugLock,decltype,cs2,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,define,WAIT_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockencodings_tests.cpp
changed code snippet:
    pool.addUnchecked(entry.FromTx(block.vtx[2]));
    pool.addUnchecked(entry.FromTx(block.vtx[2]));
    pool.addUnchecked(entry.FromTx(block.vtx[1]));

identifier:pool,addUnchecked,entry,FromTx,block,vtx,pool,addUnchecked,entry,FromTx,block,vtx,pool,addUnchecked,entry,FromTx,block,vtx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:

#include <test/data/blockfilters.json.h>
#include <test/test_bitcoin.h>

#include <blockfilter.h>
#include <core_io.h>
#include <serialize.h>
#include <streams.h>
#include <univalue.h>
#include <utilstrencodings.h>

#include <boost/test/unit_test.hpp>

BOOST_AUTO_TEST_SUITE(blockfilter_tests)

BOOST_AUTO_TEST_CASE(gcsfilter_test)
{
    GCSFilter::ElementSet included_elements, excluded_elements;
    for (int i = 0; i < 100; ++i) {
        GCSFilter::Element element1(32);
        element1[0] = i;
        included_elements.insert(std::move(element1));

        GCSFilter::Element element2(32);
        element2[1] = i;
        excluded_elements.insert(std::move(element2));
    }

    GCSFilter filter(0, 0, 10, 1 << 10, included_elements);
    for (const auto& element : included_elements) {
        BOOST_CHECK(filter.Match(element));

        auto insertion = excluded_elements.insert(element);
        BOOST_CHECK(filter.MatchAny(excluded_elements));
        excluded_elements.erase(insertion.first);
    }
}

BOOST_AUTO_TEST_CASE(blockfilter_basic_test)
{
    CScript included_scripts[5], excluded_scripts[3];

    // First two are outputs on a single transaction.
    included_scripts[0] << std::vector<unsigned char>(0, 65) << OP_CHECKSIG;
    included_scripts[1] << OP_DUP << OP_HASH160 << std::vector<unsigned char>(1, 20) << OP_EQUALVERIFY << OP_CHECKSIG;

    // Third is an output on in a second transaction.
    included_scripts[2] << OP_1 << std::vector<unsigned char>(2, 33) << OP_1 << OP_CHECKMULTISIG;

    // Last two are spent by a single transaction.
    included_scripts[3] << OP_0 << std::vector<unsigned char>(3, 32);
    included_scripts[4] << OP_4 << OP_ADD << OP_8 << OP_EQUAL;

    // OP_RETURN output is an output on the second transaction.
    excluded_scripts[0] << OP_RETURN << std::vector<unsigned char>(4, 40);

    // This script is not related to the block at all.
    excluded_scripts[1] << std::vector<unsigned char>(5, 33) << OP_CHECKSIG;

    CMutableTransaction tx_1;
    tx_1.vout.emplace_back(100, included_scripts[0]);
    tx_1.vout.emplace_back(200, included_scripts[1]);

    CMutableTransaction tx_2;
    tx_2.vout.emplace_back(300, included_scripts[2]);
    tx_2.vout.emplace_back(0, excluded_scripts[0]);
    tx_2.vout.emplace_back(400, excluded_scripts[2]); // Script is empty

    CBlock block;
    block.vtx.push_back(MakeTransactionRef(tx_1));
    block.vtx.push_back(MakeTransactionRef(tx_2));

    CBlockUndo block_undo;
    block_undo.vtxundo.emplace_back();
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(500, included_scripts[3]), 1000, true);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(600, included_scripts[4]), 10000, false);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(700, excluded_scripts[2]), 100000, false);

    BlockFilter block_filter(BlockFilterType::BASIC, block, block_undo);
    const GCSFilter& filter = block_filter.GetFilter();

    for (const CScript& script : included_scripts) {
        BOOST_CHECK(filter.Match(GCSFilter::Element(script.begin(), script.end())));
    }
    for (const CScript& script : excluded_scripts) {
        BOOST_CHECK(!filter.Match(GCSFilter::Element(script.begin(), script.end())));
    }
}

BOOST_AUTO_TEST_CASE(blockfilters_json_test)
{
    UniValue json;
    std::string json_data(json_tests::blockfilters,
                          json_tests::blockfilters + sizeof(json_tests::blockfilters));
    if (!json.read(json_data) || !json.isArray()) {
        BOOST_ERROR("Parse error.");
        return;
    }

    const UniValue& tests = json.get_array();
    for (unsigned int i = 0; i < tests.size(); i++) {
        UniValue test = tests[i];
        std::string strTest = test.write();

        if (test.size() == 1) {
            continue;
        } else if (test.size() < 7) {
            BOOST_ERROR("Bad test: " << strTest);
            continue;
        }

        unsigned int pos = 0;
        /*int block_height =*/ test[pos++].get_int();
        /*uint256 block_hash =*/ ParseHashStr(test[pos++].get_str(), "block_hash");

        CBlock block;
        BOOST_REQUIRE(DecodeHexBlk(block, test[pos++].get_str()));

        CBlockUndo block_undo;
        block_undo.vtxundo.emplace_back();
        CTxUndo& tx_undo = block_undo.vtxundo.back();
        const UniValue& prev_scripts = test[pos++].get_array();
        for (unsigned int ii = 0; ii < prev_scripts.size(); ii++) {
            std::vector<unsigned char> raw_script = ParseHex(prev_scripts[ii].get_str());
            CTxOut txout(0, CScript(raw_script.begin(), raw_script.end()));
            tx_undo.vprevout.emplace_back(txout, 0, false);
        }

        uint256 prev_filter_header_basic = ParseHashStr(test[pos++].get_str(), "prev_filter_header_basic");
        std::vector<unsigned char> filter_basic = ParseHex(test[pos++].get_str());
        uint256 filter_header_basic = ParseHashStr(test[pos++].get_str(), "filter_header_basic");

        BlockFilter computed_filter_basic(BlockFilterType::BASIC, block, block_undo);
        BOOST_CHECK(computed_filter_basic.GetFilter().GetEncoded() == filter_basic);

        uint256 computed_header_basic = computed_filter_basic.ComputeHeader(prev_filter_header_basic);
        BOOST_CHECK(computed_header_basic == filter_header_basic);
    }
}

BOOST_AUTO_TEST_SUITE_END()

identifier:include,test,data,blockfilters,json,h,include,test,test_bitcoin,h,include,blockfilter,h,include,core_io,h,include,serialize,h,include,streams,h,include,univalue,h,include,utilstrencodings,h,include,boost,test,unit_test,hpp,BOOST_AUTO_TEST_SUITE,blockfilter_tests,BOOST_AUTO_TEST_CASE,gcsfilter_test,GCSFilter::ElementSet,included_elements,excluded_elements,i,i,i,GCSFilter::Element,element1,element1,i,included_elements,insert,element1,GCSFilter::Element,element2,element2,i,excluded_elements,insert,element2,GCSFilter,filter,included_elements,element,included_elements,BOOST_CHECK,filter,Match,element,insertion,excluded_elements,insert,element,BOOST_CHECK,filter,MatchAny,excluded_elements,excluded_elements,erase,insertion,first,BOOST_AUTO_TEST_CASE,blockfilter_basic_test,CScript,included_scripts,excluded_scripts,included_scripts,OP_CHECKSIG,included_scripts,OP_DUP,OP_HASH160,OP_EQUALVERIFY,OP_CHECKSIG,included_scripts,OP_1,OP_1,OP_CHECKMULTISIG,included_scripts,OP_0,included_scripts,OP_4,OP_ADD,OP_8,OP_EQUAL,excluded_scripts,OP_RETURN,excluded_scripts,OP_CHECKSIG,CMutableTransaction,tx_1,tx_1,vout,emplace_back,included_scripts,tx_1,vout,emplace_back,included_scripts,CMutableTransaction,tx_2,tx_2,vout,emplace_back,included_scripts,tx_2,vout,emplace_back,excluded_scripts,tx_2,vout,emplace_back,excluded_scripts,CBlock,block,block,vtx,push_back,MakeTransactionRef,tx_1,block,vtx,push_back,MakeTransactionRef,tx_2,CBlockUndo,block_undo,block_undo,vtxundo,emplace_back,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,excluded_scripts,BlockFilter,block_filter,BlockFilterType::BASIC,block,block_undo,GCSFilter,filter,block_filter,GetFilter,CScript,script,included_scripts,BOOST_CHECK,filter,Match,GCSFilter::Element,script,begin,script,end,CScript,script,excluded_scripts,BOOST_CHECK,filter,Match,GCSFilter::Element,script,begin,script,end,BOOST_AUTO_TEST_CASE,blockfilters_json_test,UniValue,json,json_data,json_tests::blockfilters,json_tests::blockfilters,json_tests::blockfilters,json,read,json_data,json,isArray,BOOST_ERROR,UniValue,tests,json,get_array,i,i,tests,size,i,UniValue,test,tests,i,strTest,test,write,test,size,test,size,BOOST_ERROR,strTest,pos,test,pos,get_int,ParseHashStr,test,pos,get_str,CBlock,block,BOOST_REQUIRE,DecodeHexBlk,block,test,pos,get_str,CBlockUndo,block_undo,block_undo,vtxundo,emplace_back,CTxUndo,tx_undo,block_undo,vtxundo,back,UniValue,prev_scripts,test,pos,get_array,ii,ii,prev_scripts,size,ii,raw_script,ParseHex,prev_scripts,ii,get_str,CTxOut,txout,CScript,raw_script,begin,raw_script,end,tx_undo,vprevout,emplace_back,txout,uint256,prev_filter_header_basic,ParseHashStr,test,pos,get_str,filter_basic,ParseHex,test,pos,get_str,uint256,filter_header_basic,ParseHashStr,test,pos,get_str,BlockFilter,computed_filter_basic,BlockFilterType::BASIC,block,block_undo,BOOST_CHECK,computed_filter_basic,GetFilter,GetEncoded,filter_basic,uint256,computed_header_basic,computed_filter_basic,ComputeHeader,prev_filter_header_basic,BOOST_CHECK,computed_header_basic,filter_header_basic,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (const size_t i : range) {
        for (const bool end_fails : {true, false}) {

identifier:size_t,i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure&) {
    } catch (const std::ios_base::failure&) {
    } catch (std::logic_error&) {
    for (const CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error&) {
    for (const CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (const CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (const char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (const char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:CAmount,base_value,ABSENT,PRUNED,VALUE1,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (const uint256& h : hashes_insert_copy)
    for (const uint256& h : hashes)
            for (const auto& h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure&) {
    for (const int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/denialofservice_tests.cpp
changed code snippet:
extern CCriticalSection g_cs_orphans;
extern std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);
    LOCK2(cs_main, g_cs_orphans);
    LOCK2(cs_main, g_cs_orphans);

identifier:CCriticalSection,g_cs_orphans,uint256,COrphanTx,mapOrphanTransactions,GUARDED_BY,g_cs_orphans,LOCK2,cs_main,g_cs_orphans,LOCK2,cs_main,g_cs_orphans,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/descriptor_tests.cpp
changed code snippet:
    std::string prv1;

identifier:prv1,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.cpp
changed code snippet:
#include <test/gen/crypto_gen.h>

#include <key.h>

#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Predicate.h>
#include <rapidcheck/gen/Container.h>

/** Generates 1 to 20 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys()
{
    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {
        return keys.size() >= 1 && keys.size() <= 15;
    });
};

identifier:include,test,gen,crypto_gen,h,include,key,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Predicate,h,include,rapidcheck,gen,Container,h,rc::Gen,CKey,MultisigKeys,rc::gen::suchThat,rc::gen::arbitrary,CKey,CKey,keys,keys,size,keys,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.h
changed code snippet:
#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H
#define BITCOIN_TEST_GEN_CRYPTO_GEN_H

#include <key.h>
#include <random.h>
#include <uint256.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Create.h>
#include <rapidcheck/gen/Numeric.h>

/** Generates 1 to 15 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys();

namespace rc
{
/** Generator for a new CKey */
template <>
struct Arbitrary<CKey> {
    static Gen<CKey> arbitrary()
    {
        return rc::gen::map<int>([](int x) {
            CKey key;
            key.MakeNewKey(true);
            return key;
        });
    };
};

/** Generator for a CPrivKey */
template <>
struct Arbitrary<CPrivKey> {
    static Gen<CPrivKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPrivKey();
        });
    };
};

/** Generator for a new CPubKey */
template <>
struct Arbitrary<CPubKey> {
    static Gen<CPubKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPubKey();
        });
    };
};
/** Generates a arbitrary uint256 */
template <>
struct Arbitrary<uint256> {
    static Gen<uint256> arbitrary()
    {
        return rc::gen::just(GetRandHash());
    };
};
} //namespace rc
#endif

identifier:ifndef,BITCOIN_TEST_GEN_CRYPTO_GEN_H,define,BITCOIN_TEST_GEN_CRYPTO_GEN_H,include,key,h,include,random,h,include,uint256,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Create,h,include,rapidcheck,gen,Numeric,h,rc::Gen,CKey,MultisigKeys,namespace,rc,template,Arbitrary,CKey,Gen,CKey,arbitrary,rc::gen::map,x,CKey,key,key,MakeNewKey,key,template,Arbitrary,CPrivKey,Gen,CPrivKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPrivKey,template,Arbitrary,CPubKey,Gen,CPubKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPubKey,template,Arbitrary,uint256,Gen,uint256,arbitrary,rc::gen::just,GetRandHash,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (const std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (const auto& chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_properties.cpp
changed code snippet:
#include <key.h>

#include <base58.h>
#include <script/script.h>
#include <uint256.h>
#include <util.h>
#include <utilstrencodings.h>
#include <test/test_bitcoin.h>
#include <string>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <rapidcheck/boost_test.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>

#include <test/gen/crypto_gen.h>

BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)

/** Check CKey uniqueness */
RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))
{
    RC_ASSERT(!(key1 == key2));
}

/** Verify that a private key generates the correct public key */
RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))
{
    CPubKey pubKey = key.GetPubKey();
    RC_ASSERT(key.VerifyPubKey(pubKey));
}

/** Create a CKey using the 'Set' function must give us the same key */
RC_BOOST_PROP(key_set_symmetry, (const CKey& key))
{
    CKey key1;
    key1.Set(key.begin(), key.end(), key.IsCompressed());
    RC_ASSERT(key1 == key);
}

/** Create a CKey, sign a piece of data, then verify it with the public key */
RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))
{
    std::vector<unsigned char> vchSig;
    key.Sign(hash, vchSig, 0);
    const CPubKey& pubKey = key.GetPubKey();
    RC_ASSERT(pubKey.Verify(hash, vchSig));
}
BOOST_AUTO_TEST_SUITE_END()

identifier:include,key,h,include,base58,h,include,script,script,h,include,uint256,h,include,util,h,include,utilstrencodings,h,include,test,test_bitcoin,h,include,include,include,boost,test,unit_test,hpp,include,rapidcheck,boost_test,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,test,gen,crypto_gen,h,BOOST_FIXTURE_TEST_SUITE,key_properties,BasicTestingSetup,RC_BOOST_PROP,key_uniqueness,CKey,key1,CKey,key2,RC_ASSERT,key1,key2,RC_BOOST_PROP,key_generates_correct_pubkey,CKey,key,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,key,VerifyPubKey,pubKey,RC_BOOST_PROP,key_set_symmetry,CKey,key,CKey,key1,key1,Set,key,begin,key,end,key,IsCompressed,RC_ASSERT,key1,key,RC_BOOST_PROP,key_sign_symmetry,CKey,key,uint256,hash,vchSig,key,Sign,hash,vchSig,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,pubKey,Verify,hash,vchSig,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/mempool_tests.cpp
changed code snippet:
    testPool.addUnchecked(entry.FromTx(txParent));
    testPool.addUnchecked(entry.FromTx(txParent));
        testPool.addUnchecked(entry.FromTx(txChild[i]));
        testPool.addUnchecked(entry.FromTx(txGrandChild[i]));
        testPool.addUnchecked(entry.FromTx(txChild[i]));
        testPool.addUnchecked(entry.FromTx(txGrandChild[i]));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(entry.Fee(20000LL).FromTx(tx2));
    pool.addUnchecked(entry.Fee(0LL).FromTx(tx3));
    pool.addUnchecked(entry.Fee(15000LL).FromTx(tx4));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx5));
    pool.addUnchecked(entry.Fee(0LL).FromTx(tx6));
    pool.addUnchecked(entry.FromTx(tx7), setAncestors);
    pool.addUnchecked(entry.Fee(0LL).Time(2).FromTx(tx8), setAncestors);
    pool.addUnchecked(entry.Fee(0LL).Time(3).FromTx(tx9), setAncestors);
    pool.addUnchecked(entry.FromTx(tx10), setAncestors);
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(entry.Fee(20000LL).FromTx(tx2));
    pool.addUnchecked(entry.Fee(0LL).FromTx(tx3));
    pool.addUnchecked(entry.Fee(15000LL).FromTx(tx4));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx5));
    pool.addUnchecked(entry.Fee(0LL).FromTx(tx6));
    pool.addUnchecked(entry.Fee(fee).FromTx(tx7));
    pool.addUnchecked(entry.Fee(5000LL).FromTx(tx8));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(entry.Fee(5000LL).FromTx(tx2));
    pool.addUnchecked(entry.FromTx(tx2));
    pool.addUnchecked(entry.Fee(20000LL).FromTx(tx3));
    pool.addUnchecked(entry.Fee(7000LL).FromTx(tx4));
    pool.addUnchecked(entry.Fee(1000LL).FromTx(tx5));
    pool.addUnchecked(entry.Fee(1100LL).FromTx(tx6));
    pool.addUnchecked(entry.Fee(9000LL).FromTx(tx7));
        pool.addUnchecked(entry.Fee(1000LL).FromTx(tx5));
    pool.addUnchecked(entry.Fee(9000LL).FromTx(tx7));
    pool.addUnchecked(entry.Fee(1000LL).FromTx(tx5));
    pool.addUnchecked(entry.Fee(9000LL).FromTx(tx7));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx1));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx2));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx3));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(tx4));
        pool.addUnchecked(entry.Fee(10000LL).FromTx(tyi));
    pool.addUnchecked(entry.Fee(10000LL).FromTx(ty6));

identifier:testPool,addUnchecked,entry,FromTx,txParent,testPool,addUnchecked,entry,FromTx,txParent,testPool,addUnchecked,entry,FromTx,txChild,i,testPool,addUnchecked,entry,FromTx,txGrandChild,i,testPool,addUnchecked,entry,FromTx,txChild,i,testPool,addUnchecked,entry,FromTx,txGrandChild,i,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,entry,Fee,20000LL,FromTx,tx2,pool,addUnchecked,entry,Fee,0LL,FromTx,tx3,pool,addUnchecked,entry,Fee,15000LL,FromTx,tx4,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx5,pool,addUnchecked,entry,Fee,0LL,FromTx,tx6,pool,addUnchecked,entry,FromTx,tx7,setAncestors,pool,addUnchecked,entry,Fee,0LL,Time,FromTx,tx8,setAncestors,pool,addUnchecked,entry,Fee,0LL,Time,FromTx,tx9,setAncestors,pool,addUnchecked,entry,FromTx,tx10,setAncestors,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,entry,Fee,20000LL,FromTx,tx2,pool,addUnchecked,entry,Fee,0LL,FromTx,tx3,pool,addUnchecked,entry,Fee,15000LL,FromTx,tx4,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx5,pool,addUnchecked,entry,Fee,0LL,FromTx,tx6,pool,addUnchecked,entry,Fee,fee,FromTx,tx7,pool,addUnchecked,entry,Fee,5000LL,FromTx,tx8,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,entry,Fee,5000LL,FromTx,tx2,pool,addUnchecked,entry,FromTx,tx2,pool,addUnchecked,entry,Fee,20000LL,FromTx,tx3,pool,addUnchecked,entry,Fee,7000LL,FromTx,tx4,pool,addUnchecked,entry,Fee,1000LL,FromTx,tx5,pool,addUnchecked,entry,Fee,1100LL,FromTx,tx6,pool,addUnchecked,entry,Fee,9000LL,FromTx,tx7,pool,addUnchecked,entry,Fee,1000LL,FromTx,tx5,pool,addUnchecked,entry,Fee,9000LL,FromTx,tx7,pool,addUnchecked,entry,Fee,1000LL,FromTx,tx5,pool,addUnchecked,entry,Fee,9000LL,FromTx,tx7,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx1,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx2,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx3,pool,addUnchecked,entry,Fee,10000LL,FromTx,tx4,pool,addUnchecked,entry,Fee,10000LL,FromTx,tyi,pool,addUnchecked,entry,Fee,10000LL,FromTx,ty6,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    explicit HasReason(const std::string& reason) : m_reason(reason) {}
static bool TestSequenceLocks(const CTransaction &tx, int flags) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
    mempool.addUnchecked(entry.Fee(1000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(10000).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(entry.Fee(0).FromTx(tx));
    size_t freeTxSize = ::GetSerializeSize(tx, PROTOCOL_VERSION);
    mempool.addUnchecked(entry.Fee(feeToUse).FromTx(tx));
    mempool.addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));
    mempool.addUnchecked(entry.Fee(0).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(entry.Fee(10000).FromTx(tx));
        mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));
        mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));
        mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));
    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));
    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));
    mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));
    mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));
    mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));
    mempool.addUnchecked(entry.Time(GetTime()).FromTx(tx));

identifier:explicit,HasReason,reason,m_reason,reason,TestSequenceLocks,CTransaction,tx,flags,EXCLUSIVE_LOCKS_REQUIRED,cs_main,mempool,addUnchecked,entry,Fee,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,FromTx,tx,size_t,freeTxSize,GetSerializeSize,tx,PROTOCOL_VERSION,mempool,addUnchecked,entry,Fee,feeToUse,FromTx,tx,mempool,addUnchecked,entry,Fee,feeToUse,FromTx,tx,mempool,addUnchecked,entry,Fee,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,feeToUse,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,spendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,spendsCoinbase,SigOpsCost,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,spendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,FromTx,tx,mempool,addUnchecked,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,HIGHERFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,LOWFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Fee,HIGHFEE,Time,GetTime,SpendsCoinbase,FromTx,tx,mempool,addUnchecked,entry,Time,GetTime,FromTx,tx,mempool,addUnchecked,entry,Time,GetTime,FromTx,tx,mempool,addUnchecked,entry,Time,GetTime,FromTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception&) {
    } catch (const std::exception&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/netbase_tests.cpp
changed code snippet:
BOOST_AUTO_TEST_CASE(netbase_parsenetwork)
{
    BOOST_CHECK_EQUAL(ParseNetwork("ipv4"), NET_IPV4);
    BOOST_CHECK_EQUAL(ParseNetwork("ipv6"), NET_IPV6);
    BOOST_CHECK_EQUAL(ParseNetwork("onion"), NET_ONION);
    BOOST_CHECK_EQUAL(ParseNetwork("tor"), NET_ONION);

    BOOST_CHECK_EQUAL(ParseNetwork("IPv4"), NET_IPV4);
    BOOST_CHECK_EQUAL(ParseNetwork("IPv6"), NET_IPV6);
    BOOST_CHECK_EQUAL(ParseNetwork("ONION"), NET_ONION);
    BOOST_CHECK_EQUAL(ParseNetwork("TOR"), NET_ONION);

    BOOST_CHECK_EQUAL(ParseNetwork(":)"), NET_UNROUTABLE);
    BOOST_CHECK_EQUAL(ParseNetwork("tr"), NET_UNROUTABLE);
    BOOST_CHECK_EQUAL(ParseNetwork("\xfe\xff"), NET_UNROUTABLE);
    BOOST_CHECK_EQUAL(ParseNetwork(""), NET_UNROUTABLE);
}


identifier:BOOST_AUTO_TEST_CASE,netbase_parsenetwork,BOOST_CHECK_EQUAL,ParseNetwork,NET_IPV4,BOOST_CHECK_EQUAL,ParseNetwork,NET_IPV6,BOOST_CHECK_EQUAL,ParseNetwork,NET_ONION,BOOST_CHECK_EQUAL,ParseNetwork,NET_ONION,BOOST_CHECK_EQUAL,ParseNetwork,NET_IPV4,BOOST_CHECK_EQUAL,ParseNetwork,NET_IPV6,BOOST_CHECK_EQUAL,ParseNetwork,NET_ONION,BOOST_CHECK_EQUAL,ParseNetwork,NET_ONION,BOOST_CHECK_EQUAL,ParseNetwork,NET_UNROUTABLE,BOOST_CHECK_EQUAL,ParseNetwork,NET_UNROUTABLE,BOOST_CHECK_EQUAL,ParseNetwork,NET_UNROUTABLE,BOOST_CHECK_EQUAL,ParseNetwork,NET_UNROUTABLE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/policyestimator_tests.cpp
changed code snippet:
                mpool.addUnchecked(entry.Fee(feeV[j]).Time(GetTime()).Height(blocknum).FromTx(tx));
                mpool.addUnchecked(entry.Fee(feeV[j]).Time(GetTime()).Height(blocknum).FromTx(tx));
                mpool.addUnchecked(entry.Fee(feeV[j]).Time(GetTime()).Height(blocknum).FromTx(tx));

identifier:mpool,addUnchecked,entry,Fee,feeV,j,Time,GetTime,Height,blocknum,FromTx,tx,mpool,addUnchecked,entry,Fee,feeV,j,Time,GetTime,Height,blocknum,FromTx,tx,mpool,addUnchecked,entry,Fee,feeV,j,Time,GetTime,Height,blocknum,FromTx,tx,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/scheduler_tests.cpp
changed code snippet:
    FastRandomContext rng{/* fDeterministic */ true};
            bool expectation = i == counter1++;
            assert(expectation);
            bool expectation = i == counter2++;
            assert(expectation);

identifier:FastRandomContext,rng,expectation,i,counter1,assert,expectation,expectation,i,counter2,assert,expectation,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/script_tests.cpp
changed code snippet:
#ifdef UPDATE_JSON_TESTS
#endif
#ifdef UPDATE_JSON_TESTS
        strGen += str + ",\n";
#else

identifier:ifdef,UPDATE_JSON_TESTS,endif,ifdef,UPDATE_JSON_TESTS,strGen,str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0);
        size += ::GetSerializeSize(VARINT(i), 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (const unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/streams_tests.cpp
changed code snippet:
BOOST_AUTO_TEST_CASE(streams_vector_reader)
{
    std::vector<unsigned char> vch = {1, 255, 3, 4, 5, 6};

    VectorReader reader(SER_NETWORK, INIT_PROTO_VERSION, vch, 0);
    BOOST_CHECK_EQUAL(reader.size(), 6);
    BOOST_CHECK(!reader.empty());

    // Read a single byte as an unsigned char.
    unsigned char a;
    reader >> a;
    BOOST_CHECK_EQUAL(a, 1);
    BOOST_CHECK_EQUAL(reader.size(), 5);
    BOOST_CHECK(!reader.empty());

    // Read a single byte as a signed char.
    signed char b;
    reader >> b;
    BOOST_CHECK_EQUAL(b, -1);
    BOOST_CHECK_EQUAL(reader.size(), 4);
    BOOST_CHECK(!reader.empty());

    // Read a 4 bytes as an unsigned int.
    unsigned int c;
    reader >> c;
    BOOST_CHECK_EQUAL(c, 100992003); // 3,4,5,6 in little-endian base-256
    BOOST_CHECK_EQUAL(reader.size(), 0);
    BOOST_CHECK(reader.empty());

    // Reading after end of byte vector throws an error.
    signed int d;
    BOOST_CHECK_THROW(reader >> d, std::ios_base::failure);

    // Read a 4 bytes as a signed int from the beginning of the buffer.
    reader.seek(-6);
    reader >> d;
    BOOST_CHECK_EQUAL(d, 67370753); // 1,255,3,4 in little-endian base-256
    BOOST_CHECK_EQUAL(reader.size(), 2);
    BOOST_CHECK(!reader.empty());

    // Reading after end of byte vector throws an error even if the reader is
    // not totally empty.
    BOOST_CHECK_THROW(reader >> d, std::ios_base::failure);
}

BOOST_AUTO_TEST_CASE(bitstream_reader_writer)
{
    CDataStream data(SER_NETWORK, INIT_PROTO_VERSION);

    BitStreamWriter<CDataStream> bit_writer(data);
    bit_writer.Write(0, 1);
    bit_writer.Write(2, 2);
    bit_writer.Write(6, 3);
    bit_writer.Write(11, 4);
    bit_writer.Write(1, 5);
    bit_writer.Write(32, 6);
    bit_writer.Write(7, 7);
    bit_writer.Write(30497, 16);
    bit_writer.Flush();

    CDataStream data_copy(data);
    uint32_t serialized_int1;
    data >> serialized_int1;
    BOOST_CHECK_EQUAL(serialized_int1, (uint32_t)0x7700C35A); // NOTE: Serialized as LE
    uint16_t serialized_int2;
    data >> serialized_int2;
    BOOST_CHECK_EQUAL(serialized_int2, (uint16_t)0x1072); // NOTE: Serialized as LE

    BitStreamReader<CDataStream> bit_reader(data_copy);
    BOOST_CHECK_EQUAL(bit_reader.Read(1), 0);
    BOOST_CHECK_EQUAL(bit_reader.Read(2), 2);
    BOOST_CHECK_EQUAL(bit_reader.Read(3), 6);
    BOOST_CHECK_EQUAL(bit_reader.Read(4), 11);
    BOOST_CHECK_EQUAL(bit_reader.Read(5), 1);
    BOOST_CHECK_EQUAL(bit_reader.Read(6), 32);
    BOOST_CHECK_EQUAL(bit_reader.Read(7), 7);
    BOOST_CHECK_EQUAL(bit_reader.Read(16), 30497);
    BOOST_CHECK_THROW(bit_reader.Read(8), std::ios_base::failure);
}


identifier:BOOST_AUTO_TEST_CASE,streams_vector_reader,vch,VectorReader,reader,SER_NETWORK,INIT_PROTO_VERSION,vch,BOOST_CHECK_EQUAL,reader,size,BOOST_CHECK,reader,empty,a,reader,a,BOOST_CHECK_EQUAL,a,BOOST_CHECK_EQUAL,reader,size,BOOST_CHECK,reader,empty,b,reader,b,BOOST_CHECK_EQUAL,b,BOOST_CHECK_EQUAL,reader,size,BOOST_CHECK,reader,empty,c,reader,c,BOOST_CHECK_EQUAL,c,BOOST_CHECK_EQUAL,reader,size,BOOST_CHECK,reader,empty,d,BOOST_CHECK_THROW,reader,d,reader,seek,reader,d,BOOST_CHECK_EQUAL,d,BOOST_CHECK_EQUAL,reader,size,BOOST_CHECK,reader,empty,BOOST_CHECK_THROW,reader,d,BOOST_AUTO_TEST_CASE,bitstream_reader_writer,CDataStream,data,SER_NETWORK,INIT_PROTO_VERSION,BitStreamWriter,CDataStream,bit_writer,data,bit_writer,Write,bit_writer,Write,bit_writer,Write,bit_writer,Write,bit_writer,Write,bit_writer,Write,bit_writer,Write,bit_writer,Write,bit_writer,Flush,CDataStream,data_copy,data,uint32_t,serialized_int1,data,serialized_int1,BOOST_CHECK_EQUAL,serialized_int1,uint32_t,0x7700C35A,uint16_t,serialized_int2,data,serialized_int2,BOOST_CHECK_EQUAL,serialized_int2,uint16_t,0x1072,BitStreamReader,CDataStream,bit_reader,data_copy,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_EQUAL,bit_reader,Read,BOOST_CHECK_THROW,bit_reader,Read,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/sync_tests.cpp
changed code snippet:

#include <sync.h>
#include <test/test_bitcoin.h>

#include <boost/test/unit_test.hpp>

namespace {
template <typename MutexType>
void TestPotentialDeadLockDetected(MutexType& mutex1, MutexType& mutex2)
{
    {
        LOCK2(mutex1, mutex2);
    }
    bool error_thrown = false;
    try {
        LOCK2(mutex2, mutex1);
    } catch (const std::logic_error& e) {
        BOOST_CHECK_EQUAL(e.what(), "potential deadlock detected");
        error_thrown = true;
    }
    #ifdef DEBUG_LOCKORDER
    BOOST_CHECK(error_thrown);
    #else
    BOOST_CHECK(!error_thrown);
    #endif
}
} // namespace

BOOST_FIXTURE_TEST_SUITE(sync_tests, BasicTestingSetup)

BOOST_AUTO_TEST_CASE(potential_deadlock_detected)
{
    #ifdef DEBUG_LOCKORDER
    bool prev = g_debug_lockorder_abort;
    g_debug_lockorder_abort = false;
    #endif

    CCriticalSection rmutex1, rmutex2;
    TestPotentialDeadLockDetected(rmutex1, rmutex2);

    Mutex mutex1, mutex2;
    TestPotentialDeadLockDetected(mutex1, mutex2);

    #ifdef DEBUG_LOCKORDER
    g_debug_lockorder_abort = prev;
    #endif
}

BOOST_AUTO_TEST_SUITE_END()

identifier:include,sync,h,include,test,test_bitcoin,h,include,boost,test,unit_test,hpp,namespace,template,typename,MutexType,TestPotentialDeadLockDetected,MutexType,mutex1,MutexType,mutex2,LOCK2,mutex1,mutex2,error_thrown,LOCK2,mutex2,mutex1,e,BOOST_CHECK_EQUAL,e,what,error_thrown,ifdef,DEBUG_LOCKORDER,BOOST_CHECK,error_thrown,BOOST_CHECK,error_thrown,endif,BOOST_FIXTURE_TEST_SUITE,sync_tests,BasicTestingSetup,BOOST_AUTO_TEST_CASE,potential_deadlock_detected,ifdef,DEBUG_LOCKORDER,prev,g_debug_lockorder_abort,g_debug_lockorder_abort,endif,CCriticalSection,rmutex1,rmutex2,TestPotentialDeadLockDetected,rmutex1,rmutex2,Mutex,mutex1,mutex2,TestPotentialDeadLockDetected,mutex1,mutex2,ifdef,DEBUG_LOCKORDER,g_debug_lockorder_abort,prev,endif,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (const CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (const std::string& word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/txindex_tests.cpp
changed code snippet:

    txindex.Stop(); // Stop thread before calling destructor

identifier:txindex,Stop,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (const char opt : "abcdef")
    for (const bool def : {false, true}) {
BOOST_AUTO_TEST_CASE(test_ToLower)
{
    BOOST_CHECK_EQUAL(ToLower('@'), '@');
    BOOST_CHECK_EQUAL(ToLower('A'), 'a');
    BOOST_CHECK_EQUAL(ToLower('Z'), 'z');
    BOOST_CHECK_EQUAL(ToLower('['), '[');
    BOOST_CHECK_EQUAL(ToLower(0), 0);
    BOOST_CHECK_EQUAL(ToLower(255), 255);

    std::string testVector;
    Downcase(testVector);
    BOOST_CHECK_EQUAL(testVector, "");

    testVector = "#HODL";
    Downcase(testVector);
    BOOST_CHECK_EQUAL(testVector, "#hodl");

    testVector = "\x00\xfe\xff";
    Downcase(testVector);
    BOOST_CHECK_EQUAL(testVector, "\x00\xfe\xff");
}

BOOST_AUTO_TEST_CASE(test_ToUpper)
{
    BOOST_CHECK_EQUAL(ToUpper('`'), '`');
    BOOST_CHECK_EQUAL(ToUpper('a'), 'A');
    BOOST_CHECK_EQUAL(ToUpper('z'), 'Z');
    BOOST_CHECK_EQUAL(ToUpper('{'), '{');
    BOOST_CHECK_EQUAL(ToUpper(0), 0);
    BOOST_CHECK_EQUAL(ToUpper(255), 255);
}

BOOST_AUTO_TEST_CASE(test_Capitalize)
{
    BOOST_CHECK_EQUAL(Capitalize(""), "");
    BOOST_CHECK_EQUAL(Capitalize("bitcoin"), "Bitcoin");
    BOOST_CHECK_EQUAL(Capitalize("\x00\xfe\xff"), "\x00\xfe\xff");
}


identifier:opt,def,BOOST_AUTO_TEST_CASE,test_ToLower,BOOST_CHECK_EQUAL,ToLower,BOOST_CHECK_EQUAL,ToLower,BOOST_CHECK_EQUAL,ToLower,BOOST_CHECK_EQUAL,ToLower,BOOST_CHECK_EQUAL,ToLower,BOOST_CHECK_EQUAL,ToLower,testVector,Downcase,testVector,BOOST_CHECK_EQUAL,testVector,testVector,Downcase,testVector,BOOST_CHECK_EQUAL,testVector,testVector,Downcase,testVector,BOOST_CHECK_EQUAL,testVector,BOOST_AUTO_TEST_CASE,test_ToUpper,BOOST_CHECK_EQUAL,ToUpper,BOOST_CHECK_EQUAL,ToUpper,BOOST_CHECK_EQUAL,ToUpper,BOOST_CHECK_EQUAL,ToUpper,BOOST_CHECK_EQUAL,ToUpper,BOOST_CHECK_EQUAL,ToUpper,BOOST_AUTO_TEST_CASE,test_Capitalize,BOOST_CHECK_EQUAL,Capitalize,BOOST_CHECK_EQUAL,Capitalize,BOOST_CHECK_EQUAL,Capitalize,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/validation_block_tests.cpp
changed code snippet:
    explicit TestSubscriber(uint256 tip) : m_expected_tip(tip) {}

identifier:explicit,TestSubscriber,uint256,tip,m_expected_tip,tip,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
#include <sync.h>

        LOCK(mut);
    WAIT_LOCK(mut, lock);

identifier:include,sync,h,LOCK,mut,WAIT_LOCK,mut,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
#include <sync.h>

    Mutex mut;

identifier:include,sync,h,Mutex,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (const int64_t nOffset : vSorted)
            for (const int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
                                 bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp)
    : tx(_tx), nFee(_nFee), nTxWeight(GetTransactionWeight(*tx)), nUsageSize(RecursiveDynamicUsage(tx)), nTime(_nTime), entryHeight(_entryHeight),
            boost::optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);
            if (piter) {
                parentHashes.insert(*piter);
        for (txiter phash : setMemPoolParents) {
void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, setEntries &setAncestors, bool validFeeEstimate)
    CAmount delta{0};
    ApplyDelta(entry.GetTx().GetHash(), delta);
    if (delta) {
    for (const auto& pit : GetIterSet(setParentTransactions)) {
        for (txiter childiter : setChildren) {
                setParentCheck.insert(it2);
const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const
{
    const auto it = mapNextTx.find(prevout);
    return it == mapNextTx.end() ? nullptr : it->second;
}

boost::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const
{
    auto it = mapTx.find(txid);
    if (it != mapTx.end()) return it;
    return boost::optional<txiter>{};
}

CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const
{
    CTxMemPool::setEntries ret;
    for (const auto& h : hashes) {
        const auto mi = GetIter(h);
        if (mi) ret.insert(*mi);
    }
    return ret;
}

    for (txiter it : stage) {
void CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimate)
    return addUnchecked(entry, setAncestors, validFeeEstimate);

identifier:_spendsCoinbase,int64_t,_sigOpsCost,LockPoints,lp,tx,_tx,nFee,_nFee,nTxWeight,GetTransactionWeight,tx,nUsageSize,RecursiveDynamicUsage,tx,nTime,_nTime,entryHeight,_entryHeight,boost::optional,txiter,piter,GetIter,tx,vin,i,prevout,hash,piter,parentHashes,insert,piter,txiter,phash,setMemPoolParents,CTxMemPool::addUnchecked,CTxMemPoolEntry,entry,setEntries,setAncestors,validFeeEstimate,CAmount,delta,ApplyDelta,entry,GetTx,GetHash,delta,delta,pit,GetIterSet,setParentTransactions,txiter,childiter,setChildren,setParentCheck,insert,it2,CTransaction,CTxMemPool::GetConflictTx,COutPoint,prevout,it,mapNextTx,find,prevout,it,mapNextTx,end,nullptr,it,second,boost::optional,CTxMemPool::txiter,CTxMemPool::GetIter,uint256,txid,it,mapTx,find,txid,it,mapTx,end,it,boost::optional,txiter,CTxMemPool::setEntries,CTxMemPool::GetIterSet,uint256,hashes,CTxMemPool::setEntries,ret,h,hashes,mi,GetIter,h,mi,ret,insert,mi,ret,txiter,it,stage,CTxMemPool::addUnchecked,CTxMemPoolEntry,entry,validFeeEstimate,addUnchecked,entry,setAncestors,validFeeEstimate,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
extern CCriticalSection cs_main;
    const CTransactionRef tx;
    const CAmount nFee;             //!< Cached to avoid expensive parent-transaction lookups
    const size_t nTxWeight;         //!< ... and avoid recomputing tx weight (also used for GetTxSize())
    const size_t nUsageSize;        //!< ... and total memory usage
    const int64_t nTime;            //!< Local time when entering the mempool
    const unsigned int entryHeight; //!< Chain height when entering the mempool
    const bool spendsCoinbase;      //!< keep track of transactions that spend a coinbase
    const int64_t sigOpCost;        //!< Total sigop cost
    void addUnchecked(const CTxMemPoolEntry& entry, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs);
    void addUnchecked(const CTxMemPoolEntry& entry, setEntries& setAncestors, bool validFeeEstimate = true) EXCLUSIVE_LOCKS_REQUIRED(cs);
    void removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight, int flags) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    /** Get the transaction in the pool that spends the same prevout */
    const CTransaction* GetConflictTx(const COutPoint& prevout) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Returns an iterator to the given hash, if found */
    boost::optional<txiter> GetIter(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Translate a set of hashes into a set of pool iterators to avoid repeated lookups */
    setEntries GetIterSet(const std::set<uint256>& hashes) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    bool exists(const uint256& hash) const

identifier:CCriticalSection,cs_main,CTransactionRef,tx,CAmount,nFee,size_t,nTxWeight,size_t,nUsageSize,int64_t,nTime,entryHeight,spendsCoinbase,int64_t,sigOpCost,addUnchecked,CTxMemPoolEntry,entry,validFeeEstimate,EXCLUSIVE_LOCKS_REQUIRED,cs,addUnchecked,CTxMemPoolEntry,entry,setEntries,setAncestors,validFeeEstimate,EXCLUSIVE_LOCKS_REQUIRED,cs,removeForReorg,CCoinsViewCache,pcoins,nMemPoolHeight,flags,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CTransaction,GetConflictTx,COutPoint,prevout,EXCLUSIVE_LOCKS_REQUIRED,cs,boost::optional,txiter,GetIter,uint256,txid,EXCLUSIVE_LOCKS_REQUIRED,cs,setEntries,GetIterSet,uint256,hashes,EXCLUSIVE_LOCKS_REQUIRED,cs,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
#include <coins.h>
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), PROTOCOL_VERSION);

identifier:include,coins,h,size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
static bool validNumStr(const std::string& s)
    std::string tokenVal;
bool UniValue::setNumStr(const std::string& val_)
    std::ostringstream oss;
    std::ostringstream oss;
    std::ostringstream oss;
bool UniValue::setStr(const std::string& val_)

identifier:validNumStr,s,tokenVal,UniValue::setNumStr,val_,oss,oss,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
enum jtokentype getJsonToken(std::string& tokenVal, unsigned int& consumed,
        std::string numStr;
        std::string valStr;
    std::vector<UniValue*> stack;
    std::string tokenVal;

identifier:jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
static std::string json_escape(const std::string& inS)
    std::string outS;
std::string UniValue::write(unsigned int prettyIndent,
                            unsigned int indentLevel) const
    std::string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, std::string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const

identifier:json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
std::string srcdir(JSON_TEST_SRC);
static void runtest(std::string filename, const std::string& jdata)
        std::string prefix = filename.substr(0, 4);
        std::string basename(filename_);
        std::string filename = srcdir + "/" + basename;
        std::string jdata;
                std::string s(buf, bread);

identifier:srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#include <codecvt>
static std::map<std::string, std::unique_ptr<fsbridge::FileLock>> dir_locks;
    auto lock = MakeUnique<fsbridge::FileLock>(pathLockFile);
    if (!lock->TryLock()) {
        return error("Error while attempting to lock directory %s: %s", directory.string(), lock->GetReason());
    }
    if (!probe_only) {
        // Lock successful and we're not just probing, put it into the map
        dir_locks.emplace(pathLockFile.string(), std::move(lock));
    static inline bool UseDefaultSection(const ArgsManager& am, const std::string& arg) EXCLUSIVE_LOCKS_REQUIRED(am.cs_args)
    static inline bool GetNetBoolArg(const ArgsManager &am, const std::string& net_arg) EXCLUSIVE_LOCKS_REQUIRED(am.cs_args)
    LOCK(cs_args);

    LOCK(cs_args);
    LOCK(cs_args);
    LOCK(cs_args);
    LOCK(cs_args);
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");
static bool GetConfigOptions(std::istream& stream, std::string& error, std::vector<std::pair<std::string, std::string>> &options)
    int linenr = 1;
            } else if (*str.begin() == '-') {
                error = strprintf("parse error on line %i: %s, options in configuration file must be specified without leading -", linenr, str);
                return false;
            } else {
                error = strprintf("parse error on line %i: %s", linenr, str);
                if (str.size() >= 2 && str.substr(0, 2) == "no") {
                    error += strprintf(", if you intended to specify a negated option, use %s=1 instead", str);
                }
                return false;
        ++linenr;
    return true;
    std::vector<std::pair<std::string, std::string>> options;
    if (!GetConfigOptions(stream, error, options)) {
        return false;
    }
    for (const std::pair<std::string, std::string>& option : options) {
        bool emptyIncludeConf;
        {
            LOCK(cs_args);
            emptyIncludeConf = m_override_args.count("-includeconf") == 0;
        }
        if (emptyIncludeConf) {
    LOCK(cs_args);
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),
    WCHAR pszPath[MAX_PATH] = L"";
    if(SHGetSpecialFolderPathW(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathW() failed, could not obtain requested path.\n");
#ifndef WIN32
#else
    int nErr = ::_wsystem(std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().from_bytes(strCommand).c_str());
#endif

identifier:include,codecvt,fsbridge::FileLock,dir_locks,lock,MakeUnique,fsbridge::FileLock,pathLockFile,lock,TryLock,error,directory,lock,GetReason,probe_only,dir_locks,emplace,pathLockFile,lock,inline,UseDefaultSection,ArgsManager,am,arg,EXCLUSIVE_LOCKS_REQUIRED,am,cs_args,inline,GetNetBoolArg,ArgsManager,am,net_arg,EXCLUSIVE_LOCKS_REQUIRED,am,cs_args,LOCK,cs_args,LOCK,cs_args,LOCK,cs_args,LOCK,cs_args,LOCK,cs_args,args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,GetConfigOptions,stream,error,options,linenr,str,begin,error,strprintf,linenr,str,error,strprintf,linenr,str,str,size,str,substr,error,strprintf,str,linenr,options,GetConfigOptions,stream,error,options,option,options,emptyIncludeConf,LOCK,cs_args,emptyIncludeConf,m_override_args,count,emptyIncludeConf,LOCK,cs_args,MoveFileExW,src,wstring,c_str,dest,wstring,c_str,WCHAR,pszPath,MAX_PATH,L,SHGetSpecialFolderPathW,nullptr,pszPath,nFolder,fCreate,LogPrintf,ifndef,WIN32,nErr,_wsystem,wchar_t,wchar_t,from_bytes,strCommand,c_str,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
    std::map<std::string, std::vector<std::string>> m_override_args GUARDED_BY(cs_args);
    std::map<std::string, std::vector<std::string>> m_config_args GUARDED_BY(cs_args);
    std::string m_network GUARDED_BY(cs_args);
    std::set<std::string> m_network_only_args GUARDED_BY(cs_args);
    std::map<OptionsCategory, std::map<std::string, Arg>> m_available_args GUARDED_BY(cs_args);
    void ClearArgs() {
        LOCK(cs_args);
        m_available_args.clear();
    }

identifier:m_override_args,GUARDED_BY,cs_args,m_config_args,GUARDED_BY,cs_args,m_network,GUARDED_BY,cs_args,m_network_only_args,GUARDED_BY,cs_args,OptionsCategory,Arg,m_available_args,GUARDED_BY,cs_args,ClearArgs,LOCK,cs_args,m_available_args,clear,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
#include <algorithm>
    for (const char c : str.substr(starting_location)) {
bool ParseHDKeypath(const std::string& keypath_str, std::vector<uint32_t>& keypath)
{
    std::stringstream ss(keypath_str);
    std::string item;
    bool first = true;
    while (std::getline(ss, item, '/')) {
        if (item.compare("m") == 0) {
            if (first) {
                first = false;
                continue;
            }
            return false;
        }
        // Finds whether it is hardened
        uint32_t path = 0;
        size_t pos = item.find("'");
        if (pos != std::string::npos) {
            // The hardened tick can only be in the last index of the string
            if (pos != item.size() - 1) {
                return false;
            }
            path |= 0x80000000;
            item = item.substr(0, item.size() - 1); // Drop the last character which is the hardened tick
        }

        // Ensure this is only numbers
        if (item.find_first_not_of( "0123456789" ) != std::string::npos) {
            return false;
        }
        uint32_t number;
        if (!ParseUInt32(item, &number)) {
            return false;
        }
        path |= number;

        keypath.push_back(path);
        first = false;
    }
    return true;
}

void Downcase(std::string& str)
{
    std::transform(str.begin(), str.end(), str.begin(), [](unsigned char c){return ToLower(c);});
}

std::string Capitalize(std::string str)
{
    if (str.empty()) return str;
    str[0] = ToUpper(str.front());
    return str;
}

identifier:include,algorithm,c,str,substr,starting_location,ParseHDKeypath,keypath_str,uint32_t,keypath,ss,keypath_str,item,first,ss,item,item,compare,first,first,uint32_t,path,size_t,pos,item,find,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.h
changed code snippet:
/** Parse an HD keypaths like "m/7/0'/2000". */
bool ParseHDKeypath(const std::string& keypath_str, std::vector<uint32_t>& keypath);

/**
 * Converts the given character to its lowercase equivalent.
 * This function is locale independent. It only converts uppercase
 * characters in the standard 7-bit ASCII range.
 * @param[in] c     the character to convert to lowercase.
 * @return          the lowercase equivalent of c; or the argument
 *                  if no conversion is possible.
 */
constexpr unsigned char ToLower(unsigned char c)
{
    return (c >= 'A' && c <= 'Z' ? (c - 'A') + 'a' : c);
}

/**
 * Converts the given string to its lowercase equivalent.
 * This function is locale independent. It only converts uppercase
 * characters in the standard 7-bit ASCII range.
 * @param[in,out] str   the string to convert to lowercase.
 */
void Downcase(std::string& str);

/**
 * Converts the given character to its uppercase equivalent.
 * This function is locale independent. It only converts lowercase
 * characters in the standard 7-bit ASCII range.
 * @param[in] c     the character to convert to uppercase.
 * @return          the uppercase equivalent of c; or the argument
 *                  if no conversion is possible.
 */
constexpr unsigned char ToUpper(unsigned char c)
{
    return (c >= 'a' && c <= 'z' ? (c - 'a') + 'A' : c);
}

/**
 * Capitalizes the first character of the given string.
 * This function is locale independent. It only capitalizes the
 * first character of the argument if it has an uppercase equivalent
 * in the standard 7-bit ASCII range.
 * @param[in] str   the string to capitalize.
 * @return          string with the first letter capitalized.
 */
std::string Capitalize(std::string str);


identifier:ParseHDKeypath,keypath_str,uint32_t,keypath,constexpr,ToLower,c,c,c,c,c,Downcase,str,constexpr,ToUpper,c,c,c,c,c,Capitalize,str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
                      CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    void InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
Mutex g_best_block_mutex;
std::condition_variable g_best_block_cv;
            for (const int height : prevheights) {
static bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
                 unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {
                              bool bypass_limits, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        const CTransaction* ptxConflicting = pool.GetConflictTx(txin.prevout);
        if (ptxConflicting) {
            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);
            for (const auto& mi : setIterConflicting) {
                    if (pool.exists(tx.vin[j].prevout.hash)) {
                    }
        pool.addUnchecked(entry, setAncestors, validForFeeEstimation);
                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());
static void CheckForkWarningConditions() EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
    unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))
static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {
        LOCK(g_best_block_mutex);
            return error("%s: ConnectBlock %s failed, %s", __func__, pindexNew->GetBlockHash().ToString(), FormatStateMessage(state));

    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
        if (!CheckTransaction(*tx, state, true))
    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);
        uiInterface.ShowProgress(_("Replaying blocks..."), (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);
    for (const BlockMap::value_type& entry : mapBlockIndex) {
    for (const std::pair<const uint256, CBlockIndex*>& entry : mapBlockIndex) {

identifier:CCoinsViewCache,view,CChainParams,chainparams,fJustCheck,EXCLUSIVE_LOCKS_REQUIRED,cs_main,ActivateBestChainStep,CValidationState,state,CChainParams,chainparams,CBlockIndex,pindexMostWork,CBlock,pblock,fInvalidFound,ConnectTrace,connectTrace,EXCLUSIVE_LOCKS_REQUIRED,cs_main,ConnectTip,CValidationState,state,CChainParams,chainparams,CBlockIndex,pindexNew,CBlock,pblock,ConnectTrace,connectTrace,DisconnectedBlockTransactions,disconnectpool,EXCLUSIVE_LOCKS_REQUIRED,cs_main,InvalidBlockFound,CBlockIndex,pindex,CValidationState,state,EXCLUSIVE_LOCKS_REQUIRED,cs_main,Mutex,g_best_block_mutex,g_best_block_cv,height,prevheights,IsCurrentForFeeEstimation,EXCLUSIVE_LOCKS_REQUIRED,cs_main,UpdateMempoolForReorg,DisconnectedBlockTransactions,disconnectpool,fAddToMempool,EXCLUSIVE_LOCKS_REQUIRED,cs_main,flags,cacheSigStore,PrecomputedTransactionData,txdata,EXCLUSIVE_LOCKS_REQUIRED,cs_main,bypass_limits,CAmount,nAbsurdFee,COutPoint,coins_to_uncache,test_accept,EXCLUSIVE_LOCKS_REQUIRED,cs_main,GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,CTransaction,ptxConflicting,pool,GetConflictTx,txin,prevout,ptxConflicting,CTxMemPool::setEntries,setIterConflicting,pool,GetIterSet,setConflicts,mi,setIterConflicting,pool,exists,tx,vin,j,prevout,hash,pool,addUnchecked,entry,setAncestors,validForFeeEstimation,bypass_limits,CAmount,nAbsurdFee,test_accept,EXCLUSIVE_LOCKS_REQUIRED,cs_main,nSize,GetSerializeSize,block,fileout,GetVersion,CheckForkWarningConditions,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CheckForkWarningConditionsOnNewFork,CBlockIndex,pindexNewForkTip,EXCLUSIVE_LOCKS_REQUIRED,cs_main,InvalidChainFound,CBlockIndex,pindexNew,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CheckInputs,CTransaction,tx,CValidationState,state,CCoinsViewCache,inputs,fScriptChecks,flags,cacheSigStore,cacheFullScriptStore,PrecomputedTransactionData,txdata,CScriptCheck,pvChecks,EXCLUSIVE_LOCKS_REQUIRED,cs_main,nSize,GetSerializeSize,blockundo,fileout,GetVersion,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,CLIENT_VERSION,GetBlockScriptFlags,CBlockIndex,pindex,Consensus::Params,consensusparams,EXCLUSIVE_LOCKS_REQUIRED,cs_main,LOCK,g_best_block_mutex,error,__func__,pindexNew,GetBlockHash,ToString,FormatStateMessage,state,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,CheckTransaction,tx,state,nBlockSize,GetSerializeSize,block,CLIENT_VERSION,uiInterface,ShowProgress,_,nHeight,nForkHeight,pindexNew,nHeight,nForkHeight,BlockMap::value_type,entry,mapBlockIndex,uint256,CBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = COIN / 10;
static const CAmount HIGH_TX_FEE_PER_KB = COIN / 100;
extern Mutex g_best_block_mutex;
extern std::condition_variable g_best_block_cv;
                        bool bypass_limits, const CAmount nAbsurdFee, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
bool CheckFinalTx(const CTransaction &tx, int flags = -1) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
bool TestLockPointValidity(const LockPoints* lp) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,Mutex,g_best_block_mutex,g_best_block_cv,bypass_limits,CAmount,nAbsurdFee,test_accept,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CheckFinalTx,CTransaction,tx,flags,EXCLUSIVE_LOCKS_REQUIRED,cs_main,TestLockPointValidity,LockPoints,lp,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CheckSequenceLocks,CTransaction,tx,flags,LockPoints,lp,nullptr,useExistingLockPoints,EXCLUSIVE_LOCKS_REQUIRED,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validationinterface.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/validationinterface.h
changed code snippet:
#include <sync.h>
extern CCriticalSection cs_main;
void SyncWithValidationInterfaceQueue() LOCKS_EXCLUDED(cs_main);

identifier:include,sync,h,CCriticalSection,cs_main,SyncWithValidationInterfaceQueue,LOCKS_EXCLUDED,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (const KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An unused temporary BerkeleyEnvironment object may be created inside the
            for (const auto& env : g_dbenvs) {
    env->m_db_in_use.notify_all();
void BerkeleyEnvironment::ReloadDbEnv()
{
    // Make sure that no Db's are in use
    AssertLockNotHeld(cs_db);
    std::unique_lock<CCriticalSection> lock(cs_db);
    m_db_in_use.wait(lock, [this](){
        for (auto& count : mapFileUseCount) {
            if (count.second > 0) return false;
        }
        return true;
    });

    std::vector<std::string> filenames;
    for (auto it : mapDb) {
        filenames.push_back(it.first);
    }
    // Close the individual Db's
    for (const std::string& filename : filenames) {
        CloseDb(filename);
    }
    // Reset the environment
    Flush(true); // This will flush and close the environment
    Reset();
    Open(true);
}

                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));
        if (shutdown) {
            LOCK(cs_db);
            g_dbenvs.erase(env->Directory().string());
            env = nullptr;
        }
    }
}

void BerkeleyDatabase::ReloadDbEnv()
{
    if (!IsDummy()) {
        env->ReloadDbEnv();

identifier:env,g_dbenvs,env,m_db_in_use,notify_all,BerkeleyEnvironment::ReloadDbEnv,AssertLockNotHeld,cs_db,CCriticalSection,lock,cs_db,m_db_in_use,wait,lock,this,count,mapFileUseCount,count,second,filenames,it,mapDb,filenames,push_back,it,first,filename,filenames,CloseDb,filename,Flush,Reset,Open,LogPrintf,strFile,pathDest,fsbridge::get_filesystem_error_message,e,shutdown,LOCK,cs_db,g_dbenvs,erase,env,Directory,env,nullptr,BerkeleyDatabase::ReloadDbEnv,IsDummy,env,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:
    std::condition_variable_any m_db_in_use;
    void ReloadDbEnv();
    void ReloadDbEnv();


identifier:m_db_in_use,ReloadDbEnv,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/feebumper.cpp
changed code snippet:
static feebumper::Result PreconditionChecks(const CWallet* wallet, const CWalletTx& wtx, std::vector<std::string>& errors) EXCLUSIVE_LOCKS_REQUIRED(cs_main, wallet->cs_wallet)
    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, reservekey, g_connman.get(), state)) {

identifier:feebumper::Result,PreconditionChecks,CWallet,wallet,CWalletTx,wtx,errors,EXCLUSIVE_LOCKS_REQUIRED,cs_main,wallet,cs_wallet,wallet,CommitTransaction,tx,mapValue,oldWtx,vOrderForm,reservekey,g_connman,get,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
    //! Was the wallet component compiled in.
    bool HasWalletSupport() const override {return true;}

                               " (1 = keep tx meta data e.g. payment request information, 2 = drop tx meta data)", false, OptionsCategory::WALLET);

identifier:HasWalletSupport,override,OptionsCategory::WALLET,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (const unsigned char c : str) {
            if (!ExtractDestination(script, dest) && !internal) {
                throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set to true for nonstandard scriptPubKey imports.");
            }
                if (!(pubkey_dest == dest)) {
                if (!(pubkey_dest == dest)) {
                // add to address book or update label
                if (IsValidDestination(dest)) {
                    pwallet->SetAddressBook(dest, label, "receive");
            "      \"label\": <label>                                      , (string, optional, default: '') Label to assign to the address, only allowed with internal=false\n"

identifier:c,str,ExtractDestination,script,dest,internal,throw,JSONRPCError,RPC_INVALID_PARAMETER,pubkey_dest,dest,pubkey_dest,dest,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
static void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static CTransactionRef SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, const CCoinControl& coin_control, mapValue_t mapValue)
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, reservekey, g_connman.get(), state)) {
    CTransactionRef tx = SendMoney(pwallet, dest, nAmount, fSubtractFeeFromAmount, coin_control, std::move(mapValue));
            "2. minconf           (numeric, optional, default=0) Only include transactions confirmed at least this many times.\n"
            "amount              (numeric) The total amount in " + CURRENCY_UNIT + " received for this wallet.\n"
    const UniValue& dummy_value = request.params[0];
    if (!dummy_value.isNull() && dummy_value.get_str() != "*") {
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "dummy first argument must be excluded or set to \"*\".");
    }
    if (request.fHelp || request.params.size() < 2 || request.params.size() > 8)
        throw std::runtime_error(
            "sendmany \"\" {\"address\":amount,...} ( minconf \"comment\" [\"address\",...] replaceable conf_target \"estimate_mode\")\n"
            + HelpExampleRpc("sendmany", "\"\", {\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\":0.01,\"1353tsE8YMTA4EuV7dgUXGjNFf9KpVvKHz\":0.02}, 6, \"testing\"")
        );
    if (!request.params[0].isNull() && !request.params[0].get_str().empty()) {
    if (totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth)) {
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, keyChange, g_connman.get(), state)) {
static UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool by_label) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
static void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter) EXCLUSIVE_LOCKS_REQUIRED(cs_main)
    wtx.GetAmounts(listReceived, listSent, nFee, filter);
    if ((!listSent.empty() || nFee != 0))
            std::string label;
                label = pwallet->mapAddressBook[r.destination].name;
            UniValue entry(UniValue::VOBJ);
            if (involvesWatchonly || (::IsMine(*pwallet, r.destination) & ISMINE_WATCH_ONLY)) {
                entry.pushKV("involvesWatchonly", true);
            }
            MaybePushAddress(entry, r.destination);
            if (wtx.IsCoinBase())
                if (wtx.GetDepthInMainChain() < 1)
                    entry.pushKV("category", "orphan");
                else if (wtx.IsImmatureCoinBase())
                    entry.pushKV("category", "immature");
                    entry.pushKV("category", "generate");
            else
            {
                entry.pushKV("category", "receive");
            }
            entry.pushKV("amount", ValueFromAmount(r.amount));
            if (pwallet->mapAddressBook.count(r.destination)) {
                entry.pushKV("label", label);
            }
            entry.pushKV("vout", r.vout);
            if (fLong)
                WalletTxToJSON(wtx, entry);
            ret.push_back(entry);
    if (request.fHelp || request.params.size() > 4)
        throw std::runtime_error(
            "listtransactions (dummy count skip include_watchonly)\n"
            "\nReturns up to 'count' most recent transactions skipping the first 'from' transactions.\n"
            + HelpExampleRpc("listtransactions", "\"*\", 20, 100")
        );
    if (!request.params[0].isNull() && request.params[0].get_str() != "*") {
        throw JSONRPCError(RPC_INVALID_PARAMETER, "Dummy value must be set to \"*\"");
            CWalletTx *const pwtx = (*it).second;
            ListTransactions(pwallet, *pwtx, 0, true, ret, filter);
            ListTransactions(pwallet, tx, 0, true, transactions, filter);
                ListTransactions(pwallet, it->second, -100000000, true, removed, filter);
    ListTransactions(pwallet, wtx, 0, false, details, filter);
    return "wallet encrypted; The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";
    for (const COutPoint& outpt : vOutpts) {
            "  \"embedded\" : {...},           (object, optional) Information about the address embedded in P2SH or P2WSH, if relevant and known. It includes all getaddressinfo output fields for the embedded address, excluding metadata (\"timestamp\", \"hdkeypath\", \"hdseedid\") and relation to the wallet (\"ismine\", \"iswatchonly\").\n"
            "  \"label\" :  \"label\"         (string) The label associated with the address, \"\" is the default label\n"
void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubKey, KeyOriginInfo>& hd_keypaths)
    KeyOriginInfo info;
    if (!pwallet->GetKeyOrigin(keyID, info)) {
        throw JSONRPCError(RPC_INTERNAL_ERROR, "Internal keypath is broken");
    hd_keypaths.emplace(vchPubKey, std::move(info));
        complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), *psbtx.tx, input, i, sighash_type);
        ProduceSignature(HidingSigningProvider(pwallet, true, !bip32derivs), creator, out.scriptPubKey, sigdata);
            "4. bip32derivs                    (boolean, optional, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\n"
                            "5. bip32derivs                    (boolean, optional, default=false) If true, includes the BIP 32 derivation paths for public keys if we know them\n"
    bool bip32derivs = request.params[4].isNull() ? false : request.params[4].get_bool();
    { "generating",         "generate",                         &generate,                      {"nblocks","maxtries"} },
    { "hidden",             "addwitnessaddress",                &addwitnessaddress,             {"address","p2sh"} },
    { "hidden",             "resendwallettransactions",         &resendwallettransactions,      {} },
    { "wallet",             "addmultisigaddress",               &addmultisigaddress,            {"nrequired","keys","label","address_type"} },
    { "wallet",             "getaddressesbylabel",              &getaddressesbylabel,           {"label"} },
    { "wallet",             "getbalance",                       &getbalance,                    {"dummy","minconf","include_watchonly"} },
    { "wallet",             "getnewaddress",                    &getnewaddress,                 {"label","address_type"} },
    { "wallet",             "getreceivedbylabel",               &getreceivedbylabel,            {"label","minconf"} },
    { "wallet",             "importaddress",                    &importaddress,                 {"address","label","rescan","p2sh"} },
    { "wallet",             "importwallet",                     &importwallet,                  {"filename"} },
    { "wallet",             "listlabels",                       &listlabels,                    {"purpose"} },
    { "wallet",             "listreceivedbylabel",              &listreceivedbylabel,           {"minconf","include_empty","include_watchonly"} },
    { "wallet",             "listtransactions",                 &listtransactions,              {"dummy","count","skip","include_watchonly"} },
    { "wallet",             "removeprunedfunds",                &removeprunedfunds,             {"txid"} },
    { "wallet",             "rescanblockchain",                 &rescanblockchain,              {"start_height", "stop_height"} },
    { "wallet",             "sendmany",                         &sendmany,                      {"dummy","amounts","minconf","comment","subtractfeefrom","replaceable","conf_target","estimate_mode"} },
    { "wallet",             "sethdseed",                        &sethdseed,                     {"newkeypool","seed"} },
    { "wallet",             "setlabel",                         &setlabel,                      {"address","label"} },
    { "wallet",             "walletcreatefundedpsbt",           &walletcreatefundedpsbt,        {"inputs","outputs","locktime","options","bip32derivs"} },
    { "wallet",             "walletpassphrase",                 &walletpassphrase,              {"passphrase","timeout"} },
    { "wallet",             "walletprocesspsbt",                &walletprocesspsbt,             {"psbt","sign","sighashtype","bip32derivs"} },

identifier:WalletTxToJSON,CWalletTx,wtx,UniValue,entry,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CTransactionRef,SendMoney,CWallet,pwallet,CTxDestination,address,CAmount,nValue,fSubtractFeeFromAmount,CCoinControl,coin_control,mapValue_t,mapValue,pwallet,CommitTransaction,tx,mapValue,reservekey,g_connman,get,state,CTransactionRef,tx,SendMoney,pwallet,dest,nAmount,fSubtractFeeFromAmount,coin_control,mapValue,CURRENCY_UNIT,UniValue,dummy_value,request,params,dummy_value,isNull,dummy_value,get_str,throw,JSONRPCError,RPC_METHOD_DEPRECATED,request,fHelp,request,params,size,request,params,size,throw,HelpExampleRpc,request,params,isNull,request,params,get_str,empty,totalAmount,pwallet,GetLegacyBalance,ISMINE_SPENDABLE,nMinDepth,pwallet,CommitTransaction,tx,mapValue,keyChange,g_connman,get,state,UniValue,ListReceived,CWallet,pwallet,UniValue,params,by_label,EXCLUSIVE_LOCKS_REQUIRED,cs_main,ListTransactions,CWallet,pwallet,CWalletTx,wtx,nMinDepth,fLong,UniValue,ret,isminefilter,filter,EXCLUSIVE_LOCKS_REQUIRED,cs_main,wtx,GetAmounts,listReceived,listSent,nFee,filter,listSent,empty,nFee,label,label,pwallet,mapAddressBook,r,destination,name,UniValue,entry,UniValue::VOBJ,involvesWatchonly,IsMine,pwallet,r,destination,ISMINE_WATCH_ONLY,entry,pushKV,MaybePushAddress,entry,r,destination,wtx,IsCoinBase,wtx,GetDepthInMainChain,entry,pushKV,wtx,IsImmatureCoinBase,entry,pushKV,entry,pushKV,entry,pushKV,entry,pushKV,ValueFromAmount,r,amount,pwallet,mapAddressBook,count,r,destination,entry,pushKV,label,entry,pushKV,r,vout,fLong,WalletTxToJSON,wtx,entry,ret,push_back,entry,request,fHelp,request,params,size,throw,HelpExampleRpc,request,params,isNull,request,params,get_str,throw,JSONRPCError,RPC_INVALID_PARAMETER,CWalletTx,pwtx,it,second,ListTransactions,pwallet,pwtx,ret,filter,ListTransactions,pwallet,tx,transactions,filter,ListTransactions,pwallet,it,second,removed,filter,ListTransactions,pwallet,wtx,details,filter,COutPoint,outpt,vOutpts,AddKeypathToMap,CWallet,pwallet,CKeyID,keyID,CPubKey,KeyOriginInfo,hd_keypaths,KeyOriginInfo,info,pwallet,GetKeyOrigin,keyID,info,throw,JSONRPCError,RPC_INTERNAL_ERROR,hd_keypaths,emplace,vchPubKey,info,complete,SignPSBTInput,HidingSigningProvider,pwallet,sign,bip32derivs,psbtx,tx,input,i,sighash_type,ProduceSignature,HidingSigningProvider,pwallet,bip32derivs,creator,out,scriptPubKey,sigdata,bip32derivs,request,params,isNull,request,params,get_bool,generate,addwitnessaddress,resendwallettransactions,addmultisigaddress,getaddressesbylabel,getbalance,getnewaddress,getreceivedbylabel,importaddress,importwallet,listlabels,listreceivedbylabel,listtransactions,removeprunedfunds,rescanblockchain,sendmany,sethdseed,setlabel,walletcreatefundedpsbt,walletpassphrase,walletprocesspsbt,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
    BOOST_CHECK_EQUAL(value_ret, 1 * CENT);
    BOOST_CHECK_EQUAL(value_ret, 2 * CENT);
    BOOST_CHECK_EQUAL(value_ret, 5 * CENT);
    BOOST_CHECK_EQUAL(value_ret, 10 * CENT);
    BOOST_CHECK_EQUAL(value_ret, 10 * CENT);
    // FIXME: this test is redundant with the above, because 1 Cent is selected, not "too small"
    // BOOST_CHECK(equal_sets(selection, actual_selection));
    utxo_pool.clear();
    BOOST_CHECK_EQUAL(value_ret, 30 * CENT);
    BOOST_CHECK(equal_sets(selection, actual_selection));
      }
      // test with many inputs
      for (CAmount amt=1500; amt < COIN; amt*=10) {
           empty_wallet();
           // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
           for (uint16_t j = 0; j < 676; j++)
               add_coin(amt);

           // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.
           for (int i = 0; i < RUN_TESTS; i++) {

           }
      }
      // test randomness
      {
          empty_wallet();
          for (int i2 = 0; i2 < 100; i2++)
              add_coin(COIN);
          // Again, we only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.
          for (int i = 0; i < RUN_TESTS; i++) {
          }
          // add 75 cents in small change.  not enough to make 90 cents,
          // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
          // one of which should be picked at random
          add_coin(5 * CENT);
          add_coin(10 * CENT);
          add_coin(15 * CENT);
          add_coin(20 * CENT);
          add_coin(25 * CENT);
          for (int i = 0; i < RUN_TESTS; i++) {
            int fails = 0;
          }
      }


identifier:BOOST_CHECK_EQUAL,value_ret,CENT,BOOST_CHECK_EQUAL,value_ret,CENT,BOOST_CHECK_EQUAL,value_ret,CENT,BOOST_CHECK_EQUAL,value_ret,CENT,BOOST_CHECK_EQUAL,value_ret,CENT,utxo_pool,clear,BOOST_CHECK_EQUAL,value_ret,CENT,BOOST_CHECK,equal_sets,selection,actual_selection,CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,i,i,RUN_TESTS,i,empty_wallet,i2,i2,i2,add_coin,COIN,i,i,RUN_TESTS,i,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,i,i,RUN_TESTS,i,fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/psbt_wallet_tests.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/wallet_tests.cpp
changed code snippet:
        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, reservekey, nullptr, state));
    std::map<CTxDestination, std::vector<COutput>> list;
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }

identifier:BOOST_CHECK,wallet,CommitTransaction,tx,reservekey,nullptr,state,CTxDestination,COutput,list,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            encrypted_batch = nullptr;
            encrypted_batch = nullptr;
        // BDB seems to have a bad habit of writing old data into
        // slack space in .dat files; that is bad if the old data is
        // unencrypted private keys. So:
        database->ReloadDbEnv();

    // First: get all CWalletTx into a sorted-by-time multimap.
    typedef std::multimap<int64_t, CWalletTx*> TxItems;
        txByTime.insert(std::make_pair(wtx->nTimeReceived, wtx));
        CWalletTx *const pwtx = (*it).second;
        int64_t& nOrderPos = pwtx->nOrderPos;
            if (!batch.WriteTx(*pwtx))
                return DBErrors::LOAD_FAIL;
            if (!batch.WriteTx(*pwtx))
                return DBErrors::LOAD_FAIL;
        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));
        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));
    for (const CTxIn& input : tx.vin) {
                           std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const
    for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth) const
            } else if (IsMine(out) & filter && depth >= minDepth) {
        if (outgoing) {
    AssertLockHeld(cs_main);
    AssertLockHeld(cs_wallet);
    for (const COutput& coin : availableCoins) {
    for (const COutPoint& output : lockedCoins) {
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);
bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state)
        for (const int64_t nIndex : setInternalKeyPool) {
        for (const int64_t nIndex : setExternalKeyPool) {
        for (const int64_t nIndex : set_pre_split_keypool) {
            for (const CTxIn& txin : pcoin->tx->vin)
               for (const CTxOut& txout : pcoin->tx->vout)
        for (const CTxDestination& address : _grouping)
        for (const CTxDestination& element : *merged)
    for (const std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)
                CWalletTx* const pwtx = it->second;
                nSmartTime = pwtx->nTimeSmart;
                if (!nSmartTime) {
                    nSmartTime = pwtx->nTimeReceived;
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, fsbridge::get_filesystem_error_message(e));

bool CWallet::GetKeyOrigin(const CKeyID& keyID, KeyOriginInfo& info) const
{
    CKeyMetadata meta;
    {
        LOCK(cs_wallet);
        auto it = mapKeyMetadata.find(keyID);
        if (it != mapKeyMetadata.end()) {
            meta = it->second;
        }
    }
    if (!meta.hdKeypath.empty()) {
        if (!ParseHDKeypath(meta.hdKeypath, info.path)) return false;
        // Get the proper master key id
        CKey key;
        GetKey(meta.hd_seed_id, key);
        CExtKey masterKey;
        masterKey.SetSeed(key.begin(), key.size());
        // Compute identifier
        CKeyID masterid = masterKey.key.GetPubKey().GetID();
        std::copy(masterid.begin(), masterid.begin() + 4, info.fingerprint);
    } else { // Single pubkeys get the master fingerprint of themselves
        std::copy(keyID.begin(), keyID.begin() + 4, info.fingerprint);
    }
    return true;
}

identifier:encrypted_batch,nullptr,encrypted_batch,nullptr,database,ReloadDbEnv,int64_t,CWalletTx,TxItems,txByTime,insert,wtx,nTimeReceived,wtx,CWalletTx,pwtx,it,second,int64_t,nOrderPos,pwtx,nOrderPos,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,wtx,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,wtx,CTxIn,input,tx,vin,COutputEntry,listSent,CAmount,nFee,isminefilter,filter,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,CAmount,CWallet::GetLegacyBalance,isminefilter,filter,minDepth,IsMine,out,filter,depth,minDepth,outgoing,AssertLockHeld,cs_main,AssertLockHeld,cs_wallet,COutput,coin,availableCoins,COutPoint,output,lockedCoins,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,PROTOCOL_VERSION,CWallet::CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,CReserveKey,reservekey,CConnman,connman,CValidationState,state,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,CWalletTx,pwtx,it,second,nSmartTime,pwtx,nTimeSmart,nSmartTime,nSmartTime,pwtx,nTimeReceived,error_string,strprintf,wallet_file,fsbridge::get_filesystem_error_message,e,CWallet::GetKeyOrigin,CKeyID,keyID,KeyOriginInfo,info,CKeyMetadata,meta,LOCK,cs_wallet,it,mapKeyMetadata,find,keyID,it,mapKeyMetadata,end,meta,it,second,meta,hdKeypath,empty,ParseHDKeypath,meta,hdKeypath,info,path,CKey,key,GetKey,meta,hd_seed_id,key,CExtKey,masterKey,masterKey,SetSeed,key,begin,key,size,CKeyID,masterid,masterKey,key,GetPubKey,GetID,masterid,begin,masterid,begin,info,fingerprint,keyID,begin,keyID,begin,info,fingerprint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.h
changed code snippet:
    int GetDepthInMainChain() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    bool IsInMainChain() const EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return GetDepthInMainChain() > 0; }
    int GetBlocksToMaturity() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    bool IsImmatureCoinBase() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
     *                         and sendmany wallet RPCs
    std::multimap<int64_t, CWalletTx*>::const_iterator m_it_wtxOrdered;
        mapValueCopy["fromaccount"] = "";
    CAmount GetCredit(const isminefilter& filter) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    CAmount GetImmatureCredit(bool fUseCache=true) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    CAmount GetAvailableCredit(bool fUseCache=true, const isminefilter& filter=ISMINE_SPENDABLE) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache=true) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;
    bool IsTrusted() const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    bool RelayWalletTransaction(CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    bool AcceptToMemoryPool(const CAmount& nAbsurdFee, CValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    typedef std::multimap<int64_t, CWalletTx*> TxItems;
    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe=true, const CCoinControl *coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0, const int nMinDepth = 0, const int nMaxDepth = 9999999) const EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_wallet);
    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_wallet);
    bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    std::vector<uint256> ResendWalletTransactionsBefore(int64_t nTime, CConnman* connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    CAmount GetLegacyBalance(const isminefilter& filter, int minDepth) const;
    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state);
    bool m_allow_fallback_fee{true}; //!< will be defined via chainparams
    std::map<CTxDestination, CAmount> GetAddressBalances() EXCLUSIVE_LOCKS_REQUIRED(cs_main);
    void BlockUntilSyncedToCurrentChain() LOCKS_EXCLUDED(cs_main, cs_wallet);
    /** Implement lookup of key origin information through wallet key metadata. */
    bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const override;

identifier:GetDepthInMainChain,EXCLUSIVE_LOCKS_REQUIRED,cs_main,IsInMainChain,EXCLUSIVE_LOCKS_REQUIRED,cs_main,GetDepthInMainChain,GetBlocksToMaturity,EXCLUSIVE_LOCKS_REQUIRED,cs_main,IsImmatureCoinBase,EXCLUSIVE_LOCKS_REQUIRED,cs_main,and,sendmany,wallet,RPCs,int64_t,CWalletTx,const_iterator,m_it_wtxOrdered,mapValueCopy,CAmount,GetCredit,isminefilter,filter,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CAmount,GetImmatureCredit,fUseCache,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CAmount,GetAvailableCredit,fUseCache,isminefilter,filter,ISMINE_SPENDABLE,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CAmount,GetImmatureWatchOnlyCredit,fUseCache,EXCLUSIVE_LOCKS_REQUIRED,cs_main,COutputEntry,listSent,CAmount,nFee,isminefilter,filter,IsTrusted,EXCLUSIVE_LOCKS_REQUIRED,cs_main,RelayWalletTransaction,CConnman,connman,EXCLUSIVE_LOCKS_REQUIRED,cs_main,AcceptToMemoryPool,CAmount,nAbsurdFee,CValidationState,state,EXCLUSIVE_LOCKS_REQUIRED,cs_main,int64_t,CWalletTx,TxItems,AvailableCoins,COutput,vCoins,fOnlySafe,CCoinControl,coinControl,nullptr,CAmount,nMinimumAmount,CAmount,nMaximumAmount,MAX_MONEY,CAmount,nMinimumSumAmount,MAX_MONEY,uint64_t,nMaximumCount,nMinDepth,nMaxDepth,EXCLUSIVE_LOCKS_REQUIRED,cs_main,cs_wallet,CTxDestination,COutput,ListCoins,EXCLUSIVE_LOCKS_REQUIRED,cs_main,cs_wallet,IsSpent,uint256,hash,n,EXCLUSIVE_LOCKS_REQUIRED,cs_main,ResendWalletTransactions,int64_t,nBestBlockTime,CConnman,connman,override,EXCLUSIVE_LOCKS_REQUIRED,cs_main,uint256,ResendWalletTransactionsBefore,int64_t,nTime,CConnman,connman,EXCLUSIVE_LOCKS_REQUIRED,cs_main,CAmount,GetLegacyBalance,isminefilter,filter,minDepth,CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,CReserveKey,reservekey,CConnman,connman,CValidationState,state,m_allow_fallback_fee,CTxDestination,CAmount,GetAddressBalances,EXCLUSIVE_LOCKS_REQUIRED,cs_main,BlockUntilSyncedToCurrentChain,LOCKS_EXCLUDED,cs_main,cs_wallet,GetKeyOrigin,CKeyID,keyid,KeyOriginInfo,info,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
#include <string>
                    std::string unused_string;
                    ssValue >> fTmp >> fUnused >> unused_string;
                    strErr = strprintf("LoadWallet() upgrading tx ver=%d %d %s",
                                       wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());
                strType != "minversion" && strType != "acentry") {
    for (const uint256& hash : wss.vWalletUpgrade)
    for (const uint256& hash : vTxHash) {
    for (const uint256& hash : vTxHash) {

identifier:include,unused_string,ssValue,fTmp,fUnused,unused_string,strErr,strprintf,wtx,fTimeReceivedIsTxTime,fTmp,hash,ToString,strType,strType,uint256,hash,wss,vWalletUpgrade,uint256,hash,vTxHash,uint256,hash,vTxHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:
    /** Is the wallet component enabled */
    virtual bool HasWalletSupport() const = 0;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:virtual,HasWalletSupport,WalletInitInterface,g_wallet_init_interface,
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    int major = 0, minor = 0, patch = 0;
    zmq_version(&major, &minor, &patch);
    LogPrint(BCLog::ZMQ, "zmq: version %d.%d.%d\n", major, minor, patch);

    pcontext = zmq_ctx_new();
        zmq_ctx_term(pcontext);

identifier:major,minor,patch,zmq_version,major,minor,patch,LogPrint,BCLog::ZMQ,major,minor,patch,pcontext,zmq_ctx_new,zmq_ctx_term,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d26278988fbfc71dc558f7b2c60a184e8091450b
commit B:24f095df4506c599fe770309efd1c5b8048420e5
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d926a87fde80b64024b2d94260c53aab20ccb259
commit B:a2eb6f540538d32725aecf678301a96247db6fd9
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:
    { "getnodeaddresses", 0, "count"},

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
static UniValue getnodeaddresses(const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() > 1) {
        throw std::runtime_error(
            "getnodeaddresses ( count )\n"
            "\nReturn known addresses which can potentially be used to find new nodes in the network\n"
            "\nArguments:\n"
            "1. \"count\"    (numeric, optional) How many addresses to return. Limited to the smaller of " + std::to_string(ADDRMAN_GETADDR_MAX) +
                " or " + std::to_string(ADDRMAN_GETADDR_MAX_PCT) + "% of all known addresses. (default = 1)\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"time\": ttt,                (numeric) Timestamp in seconds since epoch (Jan 1 1970 GMT) keeping track of when the node was last seen\n"
            "    \"services\": n,              (numeric) The services offered\n"
            "    \"address\": \"host\",          (string) The address of the node\n"
            "    \"port\": n                   (numeric) The port of the node\n"
            "  }\n"
            "  ,....\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getnodeaddresses", "8")
            + HelpExampleRpc("getnodeaddresses", "8")
        );
    }
    if (!g_connman) {
        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, "Error: Peer-to-peer functionality missing or disabled");
    }

    int count = 1;
    if (!request.params[0].isNull()) {
        count = request.params[0].get_int();
        if (count <= 0) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Address count out of range");
        }
    }
    // returns a shuffled list of CAddress
    std::vector<CAddress> vAddr = g_connman->GetAddresses();
    UniValue ret(UniValue::VARR);

    int address_return_count = std::min<int>(count, vAddr.size());
    for (int i = 0; i < address_return_count; ++i) {
        UniValue obj(UniValue::VOBJ);
        const CAddress& addr = vAddr[i];
        obj.pushKV("time", (int)addr.nTime);
        obj.pushKV("services", (uint64_t)addr.nServices);
        obj.pushKV("address", addr.ToStringIP());
        obj.pushKV("port", addr.GetPort());
        ret.push_back(obj);
    }
    return ret;
}

    { "network",            "getnodeaddresses",       &getnodeaddresses,       {"count"} },

identifier:UniValue,getnodeaddresses,JSONRPCRequest,request,request,fHelp,request,params,size,throw,ADDRMAN_GETADDR_MAX,ADDRMAN_GETADDR_MAX_PCT,HelpExampleCli,HelpExampleRpc,g_connman,throw,JSONRPCError,RPC_CLIENT_P2P_DISABLED,count,request,params,isNull,count,request,params,get_int,count,throw,JSONRPCError,RPC_INVALID_PARAMETER,CAddress,vAddr,g_connman,GetAddresses,UniValue,ret,UniValue::VARR,address_return_count,count,vAddr,size,i,i,address_return_count,i,UniValue,obj,UniValue::VOBJ,CAddress,addr,vAddr,i,obj,pushKV,addr,nTime,obj,pushKV,uint64_t,addr,nServices,obj,pushKV,addr,ToStringIP,obj,pushKV,addr,GetPort,ret,push_back,obj,ret,getnodeaddresses,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, false))

identifier:CheckTransaction,tx,state,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:a2eb6f540538d32725aecf678301a96247db6fd9
commit B:9b4a36effcf642f3844c6696b757266686ece11a
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, true))

identifier:CheckTransaction,tx,state,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:b8f801964f59586508ea8da6cf3decd76bc0e571
commit B:fa84723e73d3d7766e7821881ac96ec203e50efc
++@DIFF ENTRY SEPERATOR@++
changed file:src/amount.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/ccoins_caching.cpp
changed code snippet:
    dummyTransactions[0].vout[0].nValue = 11 * COIN;
    dummyTransactions[0].vout[1].nValue = 50 * COIN;
    dummyTransactions[1].vout[0].nValue = 21 * COIN;
    dummyTransactions[1].vout[1].nValue = 22 * COIN;
    t1.vout[0].nValue = 90 * COIN;
        assert(value == (50 + 21 + 22) * COIN);

identifier:dummyTransactions,vout,nValue,COIN,dummyTransactions,vout,nValue,COIN,dummyTransactions,vout,nValue,COIN,dummyTransactions,vout,nValue,COIN,t1,vout,nValue,COIN,assert,value,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.h
changed code snippet:
static constexpr CAmount CENT{1000000};


identifier:constexpr,CAmount,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilmoneystr.cpp
changed code snippet:
            int64_t nMult = COIN / 10;

identifier:int64_t,nMult,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        if (!CheckTransaction(*tx, state, false))

identifier:CheckTransaction,tx,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/coinselection.h
changed code snippet:
static constexpr CAmount MIN_CHANGE{COIN / 100};

identifier:constexpr,CAmount,MIN_CHANGE,COIN,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fa84723e73d3d7766e7821881ac96ec203e50efc
commit B:4901c00792c1dabae4bb01e6373c9b1ed9ef3008
++@DIFF ENTRY SEPERATOR@++
changed file:src/amount.h
changed code snippet:
static const CAmount CENT = 1000000;

identifier:CAmount,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bench/ccoins_caching.cpp
changed code snippet:
    dummyTransactions[0].vout[0].nValue = 11 * CENT;
    dummyTransactions[0].vout[1].nValue = 50 * CENT;
    dummyTransactions[1].vout[0].nValue = 21 * CENT;
    dummyTransactions[1].vout[1].nValue = 22 * CENT;
    t1.vout[0].nValue = 90 * CENT;
        assert(value == (50 + 21 + 22) * CENT);

identifier:dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,dummyTransactions,vout,nValue,CENT,t1,vout,nValue,CENT,assert,value,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilmoneystr.cpp
changed code snippet:
            int64_t nMult = CENT*10;

identifier:int64_t,nMult,CENT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/coinselection.h
changed code snippet:
static const CAmount MIN_CHANGE = CENT;

identifier:CAmount,MIN_CHANGE,CENT,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:4901c00792c1dabae4bb01e6373c9b1ed9ef3008
commit B:661ac15a4aafae6ec1579721ef36ca2fde9c17b0
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    pcontext = zmq_init(1);
        zmq_ctx_destroy(pcontext);

identifier:pcontext,zmq_init,zmq_ctx_destroy,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:0ca4c8b3c61984e9e2ab5a2a9a7c47faf139d1fc
commit B:2d4749b366c4cae3da19017d6658f11349634303
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = COIN / 10;
static const CAmount HIGH_TX_FEE_PER_KB = COIN / 100;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    int major = 0, minor = 0, patch = 0;
    zmq_version(&major, &minor, &patch);
    LogPrint(BCLog::ZMQ, "zmq: version %d.%d.%d\n", major, minor, patch);

    pcontext = zmq_ctx_new();
        zmq_ctx_term(pcontext);

identifier:major,minor,patch,zmq_version,major,minor,patch,LogPrint,BCLog::ZMQ,major,minor,patch,pcontext,zmq_ctx_new,zmq_ctx_term,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:2d4749b366c4cae3da19017d6658f11349634303
commit B:72e358dca7d9f470e9e42e4b715a8edfc7b53bdb
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    pcontext = zmq_init(1);
        zmq_ctx_destroy(pcontext);

identifier:pcontext,zmq_init,zmq_ctx_destroy,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:72e358dca7d9f470e9e42e4b715a8edfc7b53bdb
commit B:2148c36b6ec02fcf10d6d3b76e50b690ee93bdfd
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:c0d947d72505833fae0767c3345f408a9126902c
commit B:be54f42e5f309ff332d74828ae294636d77fb8ea
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = COIN / 10;
static const CAmount HIGH_TX_FEE_PER_KB = COIN / 100;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:be54f42e5f309ff332d74828ae294636d77fb8ea
commit B:c53e083a49291b611d278a8db24ff235c1202e43
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
static const CAmount DEFAULT_TRANSACTION_MAXFEE = 0.1 * COIN;
static const CAmount HIGH_TX_FEE_PER_KB = 0.01 * COIN;

identifier:CAmount,DEFAULT_TRANSACTION_MAXFEE,COIN,CAmount,HIGH_TX_FEE_PER_KB,COIN,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:de89eec25dc25ef96c9b06a2be3d5bdd87287a0d
commit B:8e1c13e6da2a5e1054503539664c139f1eb91e90
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/fees.h>
#include <wallet/wallet.h>
#define CHECK_WALLET(x) x
#else
#define CHECK_WALLET(x) throw std::logic_error("Wallet function called in non-wallet build.")
#endif
#ifdef ENABLE_WALLET
#else
        throw std::logic_error("Node::getWallets() called in non-wallet build.");
#endif
        CHECK_WALLET(
            return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); })));

identifier:ifdef,ENABLE_WALLET,include,wallet,fees,h,include,wallet,wallet,h,define,CHECK_WALLET,x,x,define,CHECK_WALLET,x,throw,endif,ifdef,ENABLE_WALLET,throw,endif,CHECK_WALLET,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("%1 will close now to finish the encryption process. "
                                         "your bitcoins from being stolen by malware infecting your computer.").arg(tr(PACKAGE_NAME)) +
                    QApplication::quit();

identifier:tr,arg,tr,PACKAGE_NAME,QApplication::quit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block) {
        if (!accepted) {
            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?
            return "invalid";
        }

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, e.what());

identifier:LogPrintf,__func__,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExA,src,c_str,dest,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                g_dbenvs.erase(strPath);
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), e.what());
        if (shutdown) env = nullptr;

identifier:g_dbenvs,erase,strPath,LogPrintf,strFile,pathDest,e,what,shutdown,env,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
            "Note that this will shutdown the server.\n"
    // BDB seems to have a bad habit of writing old data into
    // slack space in .dat files; that is bad if the old data is
    // unencrypted private keys. So:
    StartShutdown();
    return "wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:StartShutdown,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, e.what());

identifier:error_string,strprintf,wallet_file,e,what,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:8e1c13e6da2a5e1054503539664c139f1eb91e90
commit B:f09bc7ec9859bba6d1df765adb1030d276b8f626
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:
class CWallet;


std::vector<std::shared_ptr<CWallet>> GetWallets()
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

namespace interfaces {

class Wallet;

std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

} // namespace interfaces

identifier:class,CWallet,CWallet,GetWallets,throw,namespace,interfaces,class,Wallet,Wallet,MakeWallet,CWallet,wallet,throw,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
std::string get_filesystem_error_message(const fs::filesystem_error& e)
{
#ifndef WIN32
    return e.what();
#else
    // Convert from Multi Byte to utf-16
    std::string mb_string(e.what());
    int size = MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), nullptr, 0);

    std::wstring utf16_string(size, L'\0');
    MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), &*utf16_string.begin(), size);
    // Convert from utf-16 to utf-8
    return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>().to_bytes(utf16_string);
#endif
}


identifier:get_filesystem_error_message,fs::filesystem_error,e,ifndef,WIN32,e,what,mb_string,e,what,size,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,nullptr,utf16_string,size,L,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,utf16_string,begin,size,wchar_t,wchar_t,to_bytes,utf16_string,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

    std::string get_filesystem_error_message(const fs::filesystem_error& e);

identifier:get_filesystem_error_message,fs::filesystem_error,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is (0-4, default: %u)", DEFAULT_CHECKLEVEL), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,strprintf,DEFAULT_CHECKLEVEL,OptionsCategory::DEBUG_TEST,gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
class CWallet;
std::vector<std::shared_ptr<CWallet>> GetWallets();


class Wallet;

        return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); }));

identifier:class,CWallet,CWallet,GetWallets,class,Wallet,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("Your wallet is now encrypted. "
                                         "your bitcoins from being stolen by malware infecting your computer.") +

identifier:tr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block && accepted) {

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,__func__,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExW,src,wstring,c_str,dest,wstring,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        uiInterface.ShowProgress(_("Replaying blocks..."), (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);

identifier:uiInterface,ShowProgress,_,nHeight,nForkHeight,pindexNew,nHeight,nForkHeight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    env->m_db_in_use.notify_all();
void BerkeleyEnvironment::ReloadDbEnv()
{
    // Make sure that no Db's are in use
    AssertLockNotHeld(cs_db);
    std::unique_lock<CCriticalSection> lock(cs_db);
    m_db_in_use.wait(lock, [this](){
        for (auto& count : mapFileUseCount) {
            if (count.second > 0) return false;
        }
        return true;
    });

    std::vector<std::string> filenames;
    for (auto it : mapDb) {
        filenames.push_back(it.first);
    }
    // Close the individual Db's
    for (const std::string& filename : filenames) {
        CloseDb(filename);
    }
    // Reset the environment
    Flush(true); // This will flush and close the environment
    Reset();
    Open(true);
}

                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));
        if (shutdown) {
            LOCK(cs_db);
            g_dbenvs.erase(env->Directory().string());
            env = nullptr;
        }
    }
}

void BerkeleyDatabase::ReloadDbEnv()
{
    if (!IsDummy()) {
        env->ReloadDbEnv();

identifier:env,m_db_in_use,notify_all,BerkeleyEnvironment::ReloadDbEnv,AssertLockNotHeld,cs_db,CCriticalSection,lock,cs_db,m_db_in_use,wait,lock,this,count,mapFileUseCount,count,second,filenames,it,mapDb,filenames,push_back,it,first,filename,filenames,CloseDb,filename,Flush,Reset,Open,LogPrintf,strFile,pathDest,fsbridge::get_filesystem_error_message,e,shutdown,LOCK,cs_db,g_dbenvs,erase,env,Directory,env,nullptr,BerkeleyDatabase::ReloadDbEnv,IsDummy,env,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:
    std::condition_variable_any m_db_in_use;
    void ReloadDbEnv();
    void ReloadDbEnv();


identifier:m_db_in_use,ReloadDbEnv,ReloadDbEnv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    return "wallet encrypted; The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        // BDB seems to have a bad habit of writing old data into
        // slack space in .dat files; that is bad if the old data is
        // unencrypted private keys. So:
        database->ReloadDbEnv();

        error_string = strprintf("Error loading wallet %s. %s", wallet_file, fsbridge::get_filesystem_error_message(e));

identifier:database,ReloadDbEnv,error_string,strprintf,wallet_file,fsbridge::get_filesystem_error_message,e,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:f09bc7ec9859bba6d1df765adb1030d276b8f626
commit B:a098245ec9392fcaa31540ad67d520eae1ca086c
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/askpassphrasedialog.cpp
changed code snippet:
                                         tr("%1 will close now to finish the encryption process. "
                                         "your bitcoins from being stolen by malware infecting your computer.").arg(tr(PACKAGE_NAME)) +
                    QApplication::quit();

identifier:tr,arg,tr,PACKAGE_NAME,QApplication::quit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                g_dbenvs.erase(strPath);
        if (shutdown) env = nullptr;

identifier:g_dbenvs,erase,strPath,shutdown,env,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
            "Note that this will shutdown the server.\n"
    // BDB seems to have a bad habit of writing old data into
    // slack space in .dat files; that is bad if the old data is
    // unencrypted private keys. So:
    StartShutdown();
    return "wallet encrypted; Bitcoin server stopping, restart to run with encrypted wallet. The keypool has been flushed and a new HD seed was generated (if you are using HD). You need to make a new backup.";

identifier:StartShutdown,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:efb11d7c055f4633c90faf5deef4a26f3e47ceb2
commit B:9dcb6763fb6851df6572e75278a41029fbfe8809
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/fees.h>
#include <wallet/wallet.h>
#define CHECK_WALLET(x) x
#else
#define CHECK_WALLET(x) throw std::logic_error("Wallet function called in non-wallet build.")
#endif
#ifdef ENABLE_WALLET
#else
        throw std::logic_error("Node::getWallets() called in non-wallet build.");
#endif
        CHECK_WALLET(
            return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); })));

identifier:ifdef,ENABLE_WALLET,include,wallet,fees,h,include,wallet,wallet,h,define,CHECK_WALLET,x,x,define,CHECK_WALLET,x,throw,endif,ifdef,ENABLE_WALLET,throw,endif,CHECK_WALLET,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block) {
        if (!accepted) {
            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?
            return "invalid";
        }

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, e.what());

identifier:LogPrintf,__func__,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExA,src,c_str,dest,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), e.what());

identifier:LogPrintf,strFile,pathDest,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, e.what());

identifier:error_string,strprintf,wallet_file,e,what,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:9dcb6763fb6851df6572e75278a41029fbfe8809
commit B:cccc362d62b0ba9475b1ac47d5908f77f7eb5d21
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:
class CWallet;


std::vector<std::shared_ptr<CWallet>> GetWallets()
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

namespace interfaces {

class Wallet;

std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)
{
    throw std::logic_error("Wallet function called in non-wallet build.");
}

} // namespace interfaces

identifier:class,CWallet,CWallet,GetWallets,throw,namespace,interfaces,class,Wallet,Wallet,MakeWallet,CWallet,wallet,throw,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
class CWallet;
std::vector<std::shared_ptr<CWallet>> GetWallets();


class Wallet;

        return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); }));

identifier:class,CWallet,CWallet,GetWallets,class,Wallet,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block && accepted) {

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExW,src,wstring,c_str,dest,wstring,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        uiInterface.ShowProgress(_("Replaying blocks..."), (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);

identifier:uiInterface,ShowProgress,_,nHeight,nForkHeight,pindexNew,nHeight,nForkHeight,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:cccc362d62b0ba9475b1ac47d5908f77f7eb5d21
commit B:3ccfa34b32b7ed9d7bef05baa36827b4b262197e
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
std::string get_filesystem_error_message(const fs::filesystem_error& e)
{
#ifndef WIN32
    return e.what();
#else
    // Convert from Multi Byte to utf-16
    std::string mb_string(e.what());
    int size = MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), nullptr, 0);

    std::wstring utf16_string(size, L'\0');
    MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), &*utf16_string.begin(), size);
    // Convert from utf-16 to utf-8
    return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>().to_bytes(utf16_string);
#endif
}


identifier:get_filesystem_error_message,fs::filesystem_error,e,ifndef,WIN32,e,what,mb_string,e,what,size,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,nullptr,utf16_string,size,L,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,utf16_string,begin,size,wchar_t,wchar_t,to_bytes,utf16_string,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

    std::string get_filesystem_error_message(const fs::filesystem_error& e);

identifier:get_filesystem_error_message,fs::filesystem_error,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void()>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void()>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void()>& handler);
    std::function<void()> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
static bool InitSanityCheck()

identifier:InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start();
void ECC_Stop();
bool ECC_InitSanityCheck();

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void()> >("std::function<void()>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport();

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void()>& _func, int64_t millis):
    std::function<void()> func;
    RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,__func__,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void()>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void()> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void ()> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void ()> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void()> Function;
    std::list<std::function<void ()>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void ()> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString() {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority()

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority();

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
bool LoadMempool()
bool DumpMempool()

identifier:LoadMempool,DumpMempool,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,strFile,pathDest,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, fsbridge::get_filesystem_error_message(e));

identifier:error_string,strprintf,wallet_file,fsbridge::get_filesystem_error_message,e,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:3ccfa34b32b7ed9d7bef05baa36827b4b262197e
commit B:f0a6a922fe64c16829649281f182dc8c5e153333
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override

identifier:HTTPRPCTimer,event_base,eventBase,func,int64_t,millis,RPCTimerBase,NewTimer,func,int64_t,millis,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
HTTPEvent::HTTPEvent(struct event_base* base, bool _deleteWhenTriggered, const std::function<void(void)>& _handler):

identifier:HTTPEvent::HTTPEvent,event_base,base,_deleteWhenTriggered,_handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.h
changed code snippet:
    HTTPEvent(struct event_base* base, bool deleteWhenTriggered, const std::function<void(void)>& handler);
    std::function<void(void)> handler;

identifier:HTTPEvent,event_base,base,deleteWhenTriggered,handler,handler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
static bool InitSanityCheck(void)

identifier:InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.h
changed code snippet:
void ECC_Start(void);
void ECC_Stop(void);
bool ECC_InitSanityCheck(void);

identifier:ECC_Start,ECC_Stop,ECC_InitSanityCheck,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    qRegisterMetaType< std::function<void(void)> >("std::function<void(void)>");

identifier:qRegisterMetaType,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/macnotificationhandler.h
changed code snippet:
    bool hasUserNotificationCenterSupport(void);

identifier:hasUserNotificationCenterSupport,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):
    std::function<void(void)> func;
    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)

identifier:QtRPCTimerBase,_func,int64_t,millis,func,RPCTimerBase,NewTimer,func,int64_t,millis,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)

identifier:RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.h
changed code snippet:
    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;
void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);

identifier:virtual,RPCTimerBase,NewTimer,func,int64_t,millis,RPCRunLater,name,func,int64_t,nSeconds,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.cpp
changed code snippet:
    std::function<void (void)> callback;
void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {

identifier:callback,SingleThreadedSchedulerClient::AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
    typedef std::function<void(void)> Function;
    std::list<std::function<void (void)>> m_callbacks_pending GUARDED_BY(m_cs_callbacks_pending);
    void AddToProcessQueue(std::function<void (void)> func);

identifier:Function,m_callbacks_pending,GUARDED_BY,m_cs_callbacks_pending,AddToProcessQueue,func,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/crypto_tests.cpp
changed code snippet:
static std::string LongTestString(void) {

identifier:LongTestString,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
int ScheduleBatchPriority(void)

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
int ScheduleBatchPriority(void);

identifier:ScheduleBatchPriority,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
bool LoadMempool(void)
bool DumpMempool(void)

identifier:LoadMempool,DumpMempool,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d73205ef3652e1ea58d9b90f3f397fdf2e6bd9fd
commit B:14b29a77acb2ea7ebc5c9d08ace1ac5e08013384
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, e.what());

identifier:LogPrintf,__func__,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), e.what());

identifier:LogPrintf,strFile,pathDest,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, e.what());

identifier:error_string,strprintf,wallet_file,e,what,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:49fd485bbf5b140e23b538c7c9355e33d7193b48
commit B:e4ef4b459548b4032b9da03b3103525f935acb82
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block) {
        if (!accepted) {
            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?
            return "invalid";
        }

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExA,src,c_str,dest,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e4ef4b459548b4032b9da03b3103525f935acb82
commit B:962c302710cd6556a85ba953bac236f33b8e1a09
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/node.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/fees.h>
#include <wallet/wallet.h>
#define CHECK_WALLET(x) x
#else
#define CHECK_WALLET(x) throw std::logic_error("Wallet function called in non-wallet build.")
#endif
#ifdef ENABLE_WALLET
#else
        throw std::logic_error("Node::getWallets() called in non-wallet build.");
#endif
        CHECK_WALLET(
            return MakeHandler(::uiInterface.LoadWallet_connect([fn](std::shared_ptr<CWallet> wallet) { fn(MakeWallet(wallet)); })));

identifier:ifdef,ENABLE_WALLET,include,wallet,fees,h,include,wallet,wallet,h,define,CHECK_WALLET,x,x,define,CHECK_WALLET,x,throw,endif,ifdef,ENABLE_WALLET,throw,endif,CHECK_WALLET,MakeHandler,uiInterface,LoadWallet_connect,fn,CWallet,wallet,fn,MakeWallet,wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block && accepted) {

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExW,src,wstring,c_str,dest,wstring,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        uiInterface.ShowProgress(_("Replaying blocks..."), (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);

identifier:uiInterface,ShowProgress,_,nHeight,nForkHeight,pindexNew,nHeight,nForkHeight,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:962c302710cd6556a85ba953bac236f33b8e1a09
commit B:fa8433e3797a574937009c1b0843f44d8d7b5358
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", _("Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"), false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,_,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx	transaction for which we are checking input total
     * @return	Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
    // ifdef can be removed once we switch to better endpoint support and API versioning
    RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
#endif
#ifdef ENABLE_WALLET
    UnregisterHTTPHandler("/wallet/", false);
#endif

identifier:ifdef,ENABLE_WALLET,RegisterHTTPHandler,HTTPReq_JSONRPC,endif,ifdef,ENABLE_WALLET,UnregisterHTTPHandler,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#if !(ENABLE_WALLET)
class DummyWalletInit : public WalletInitInterface {
public:

    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();
#endif

    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);
    LogPrintf("Using config file %s\n", GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME)).string());

identifier:ENABLE_WALLET,class,DummyWalletInit,public,WalletInitInterface,public,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,endif,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::DEBUG_TEST,LogPrintf,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:
class WalletInitInterface;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:class,WalletInitInterface,WalletInitInterface,g_wallet_init_interface,
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
#else

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
static bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
static bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
static void noui_InitMessage(const std::string& message)
    // Connect bitcoind signal handlers

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
extern void noui_connect();

identifier:noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);

identifier:size_t,nSize,GetSerializeSize,txout,SER_DISK,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
static void InitMessage(const std::string &message)
    LogPrintf("init message: %s\n", message);

identifier:InitMessage,message,LogPrintf,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)

identifier:ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
#include <boost/scoped_array.hpp>

        IShellLink* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLink,
            TCHAR pszExePath[MAX_PATH];
            GetModuleFileName(nullptr, pszExePath, sizeof(pszExePath));
#ifdef UNICODE
            boost::scoped_array<TCHAR> args(new TCHAR[strArgs.length() + 1]);
            // Convert the QString to TCHAR*
            strArgs.toWCharArray(args.get());
            // Add missing '\0'-termination to string
            args[strArgs.length()] = '\0';
#endif

            PathRemoveFileSpec(pszExePath);
#ifndef UNICODE
            psl->SetArguments(strArgs.toStdString().c_str());
#else
            psl->SetArguments(args.get());
#endif
                WCHAR pwsz[MAX_PATH];
                // Ensure that the string is ANSI.
                MultiByteToWideChar(CP_ACP, 0, StartupShortcutPath().string().c_str(), -1, pwsz, MAX_PATH);
                hres = ppf->Save(pwsz, TRUE);

identifier:include,boost,scoped_array,hpp,IShellLink,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLink,TCHAR,pszExePath,MAX_PATH,GetModuleFileName,nullptr,pszExePath,pszExePath,ifdef,UNICODE,boost::scoped_array,TCHAR,args,new,TCHAR,strArgs,length,strArgs,toWCharArray,args,get,args,strArgs,length,endif,PathRemoveFileSpec,pszExePath,ifndef,UNICODE,psl,SetArguments,strArgs,toStdString,c_str,psl,SetArguments,args,get,endif,WCHAR,pwsz,MAX_PATH,MultiByteToWideChar,CP_ACP,StartupShortcutPath,c_str,pwsz,MAX_PATH,hres,ppf,Save,pwsz,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION));
                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;

identifier:result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,utxo_size_inc,GetSerializeSize,out,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
    if (!new_block) {
        if (!accepted) {
            // TODO Maybe pass down fNewBlock to AcceptBlockHeader, so it is properly set to true in this case?
            return "invalid";
        }

identifier:new_block,accepted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s, args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    const int nType;
    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}
    int GetType() const { return nType; }
size_t GetSerializeSize(const T& t, int nType, int nVersion = 0)
    return (CSizeComputer(nType, nVersion) << t).size();
template <typename S, typename T>
size_t GetSerializeSize(const S& s, const T& t)
    return (CSizeComputer(s.GetType(), s.GetVersion()) << t).size();
}

template <typename S, typename... T>
size_t GetSerializeSizeMany(const S& s, const T&... t)
{
    CSizeComputer sc(s.GetType(), s.GetVersion());

identifier:nType,CSizeComputer,nTypeIn,nVersionIn,nSize,nType,nTypeIn,nVersion,nVersionIn,GetType,nType,size_t,GetSerializeSize,T,t,nType,nVersion,CSizeComputer,nType,nVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSize,S,s,T,t,CSizeComputer,s,GetType,s,GetVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSizeMany,S,s,T,t,CSizeComputer,sc,s,GetType,s,GetVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0, 0);
        size += ::GetSerializeSize(VARINT(i), 0, 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, 0, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, 0, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            txiter piter = mapTx.find(tx.vin[i].prevout.hash);
            if (piter != mapTx.end()) {
                parentHashes.insert(piter);
    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(entry.GetTx().GetHash());
    if (pos != mapDeltas.end()) {
        const CAmount &delta = pos->second;
        if (delta) {
        }
    for (const uint256 &phash : setParentTransactions) {
        txiter pit = mapTx.find(phash);
        if (pit != mapTx.end()) {
        }

identifier:txiter,piter,mapTx,find,tx,vin,i,prevout,hash,piter,mapTx,end,parentHashes,insert,piter,uint256,CAmount,const_iterator,pos,mapDeltas,find,entry,GetTx,GetHash,pos,mapDeltas,end,CAmount,delta,pos,second,delta,uint256,phash,setParentTransactions,txiter,pit,mapTx,find,phash,pit,mapTx,end,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
public:
    bool exists(uint256 hash) const

identifier:public,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:
using namespace std;


identifier:using,namespace,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:
#include <utility>        // std::pair
    bool push_back(std::pair<std::string,UniValue> pear) {
        return pushKV(pear.first, pear.second);
    }
static inline std::pair<std::string,UniValue> Pair(const char *cKey, const char *cVal)
{
    std::string key(cKey);
    UniValue uVal(cVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, std::string strVal)
{
    std::string key(cKey);
    UniValue uVal(strVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, uint64_t u64Val)
{
    std::string key(cKey);
    UniValue uVal(u64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int64_t i64Val)
{
    std::string key(cKey);
    UniValue uVal(i64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, bool iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, double dVal)
{
    std::string key(cKey);
    UniValue uVal(dVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, const UniValue& uVal)
{
    std::string key(cKey);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(std::string key, const UniValue& uVal)
{
    return std::make_pair(key, uVal);
}


identifier:include,utility,push_back,UniValue,pear,pushKV,pear,first,pear,second,inline,UniValue,Pair,cKey,cVal,key,cKey,UniValue,uVal,cVal,key,uVal,inline,UniValue,Pair,cKey,strVal,key,cKey,UniValue,uVal,strVal,key,uVal,inline,UniValue,Pair,cKey,uint64_t,u64Val,key,cKey,UniValue,uVal,u64Val,key,uVal,inline,UniValue,Pair,cKey,int64_t,i64Val,key,cKey,UniValue,uVal,i64Val,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,dVal,key,cKey,UniValue,uVal,dVal,key,uVal,inline,UniValue,Pair,cKey,UniValue,uVal,key,cKey,key,uVal,inline,UniValue,Pair,key,UniValue,uVal,key,uVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
using namespace std;

static bool validNumStr(const string& s)
    string tokenVal;
bool UniValue::setNumStr(const string& val_)
    ostringstream oss;
    ostringstream oss;
    ostringstream oss;
bool UniValue::setStr(const string& val_)

identifier:using,namespace,validNumStr,s,tokenVal,UniValue::setNumStr,val_,ostringstream,oss,ostringstream,oss,ostringstream,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
using namespace std;

enum jtokentype getJsonToken(string& tokenVal, unsigned int& consumed,
        string numStr;
        string valStr;
    vector<UniValue*> stack;
    string tokenVal;

identifier:using,namespace,jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
using namespace std;

static string json_escape(const string& inS)
    string outS;
string UniValue::write(unsigned int prettyIndent,
                       unsigned int indentLevel) const
    string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, string& s) const

identifier:using,namespace,json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
using namespace std;
string srcdir(JSON_TEST_SRC);
static void runtest(string filename, const string& jdata)
        string prefix = filename.substr(0, 4);
        string basename(filename_);
        string filename = srcdir + "/" + basename;
        string jdata;
                string s(buf, bread);

identifier:using,namespace,srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),
    char pszPath[MAX_PATH] = "";
    if(SHGetSpecialFolderPathA(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathA() failed, could not obtain requested path.\n");

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExA,src,c_str,dest,c_str,pszPath,MAX_PATH,SHGetSpecialFolderPathA,nullptr,pszPath,nFolder,fCreate,LogPrintf,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        auto itConflicting = pool.mapNextTx.find(txin.prevout);
        if (itConflicting != pool.mapNextTx.end())
        {
            const CTransaction *ptxConflicting = itConflicting->second;
            CTxMemPool::setEntries setIterConflicting;
            for (const uint256 &hashConflicting : setConflicts)
            {
                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);
                if (mi == pool.mapTx.end())
                    continue;

                // Save these to avoid repeated lookups
                setIterConflicting.insert(mi);

                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())
    unsigned int nSize = GetSerializeSize(fileout, block);
    unsigned int nSize = GetSerializeSize(fileout, blockundo);
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,itConflicting,pool,mapNextTx,find,txin,prevout,itConflicting,pool,mapNextTx,end,CTransaction,ptxConflicting,itConflicting,second,CTxMemPool::setEntries,setIterConflicting,uint256,hashConflicting,setConflicts,CTxMemPool::txiter,mi,pool,mapTx,find,hashConflicting,mi,pool,mapTx,end,setIterConflicting,insert,mi,pool,mapTx,find,tx,vin,j,prevout,hash,pool,mapTx,end,nSize,GetSerializeSize,fileout,block,nSize,GetSerializeSize,fileout,blockundo,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,SER_DISK,CLIENT_VERSION,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
        // Not having Internal + Script
        if (!internal && isScript) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set for hex scriptPubKey");
        }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (scriptPubKey.getType() == UniValue::VOBJ) {
                    // add to address book or update label
                    if (IsValidDestination(dest)) {
                        pwallet->SetAddressBook(dest, label, "receive");
                    }

identifier:internal,isScript,throw,JSONRPCError,RPC_INVALID_PARAMETER,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,scriptPubKey,getType,UniValue::VOBJ,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
        // test with many inputs
        for (CAmount amt=1500; amt < COIN; amt*=10) {
             empty_wallet();
             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
             for (uint16_t j = 0; j < 676; j++)
                 add_coin(amt);
        }
        // test randomness
        {
            empty_wallet();
            for (int i2 = 0; i2 < 100; i2++)
                add_coin(COIN);
            // add 75 cents in small change.  not enough to make 90 cents,
            // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
            // one of which should be picked at random
            add_coin(5 * CENT);
            add_coin(10 * CENT);
            add_coin(15 * CENT);
            add_coin(20 * CENT);
            add_coin(25 * CENT);
            fails = 0;
        }
    }

identifier:CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,empty_wallet,i2,i2,i2,add_coin,COIN,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);

identifier:coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,SER_DISK,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e413c2ddd1240d7bacd1837fa49d25781fe6e5fa
commit B:b9ed2fd026926cafe38a1ee23d47eb891a94ddb1
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", "Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)", false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx    transaction for which we are checking input total
     * @return  Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,PROTOCOL_VERSION,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,PROTOCOL_VERSION,GetSerializeSize,txin,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

#include <stdio.h>
#include <util.h>
#include <walletinitinterface.h>

class DummyWalletInit : public WalletInitInterface {
public:

    bool HasWalletSupport() const override {return false;}
    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();

identifier:include,stdio,h,include,util,h,include,walletinitinterface,h,class,DummyWalletInit,public,WalletInitInterface,public,HasWalletSupport,override,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
#ifndef WIN32
#else
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t> utf8_cvt;
    return ::_wfopen(p.wstring().c_str(), utf8_cvt.from_bytes(mode).c_str());
#endif

identifier:ifndef,WIN32,wchar_t,wchar_t,utf8_cvt,_wfopen,p,wstring,c_str,utf8_cvt,from_bytes,mode,c_str,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#include <walletinitinterface.h>
    if (g_wallet_init_interface.HasWalletSupport()) {
        RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
    }
    if (g_wallet_init_interface.HasWalletSupport()) {
        UnregisterHTTPHandler("/wallet/", false);
    }

identifier:include,walletinitinterface,h,g_wallet_init_interface,HasWalletSupport,RegisterHTTPHandler,HTTPReq_JSONRPC,g_wallet_init_interface,HasWalletSupport,UnregisterHTTPHandler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);

    // Only log conf file usage message if conf file actually exists.
    fs::path config_file_path = GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME));
    if (fs::exists(config_file_path)) {
        LogPrintf("Config file: %s\n", config_file_path.string());
    } else if (gArgs.IsArgSet("-conf")) {
        // Warn if no conf file exists at path provided by user
        InitWarning(strprintf(_("The specified config file %s does not exist\n"), config_file_path.string()));
    } else {
        // Not categorizing as "Warning" because it's the default behavior
        LogPrintf("Config file: %s (not found, skipping)\n", config_file_path.string());
    }


identifier:gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::DEBUG_TEST,fs::path,config_file_path,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,fs::exists,config_file_path,LogPrintf,config_file_path,gArgs,IsArgSet,InitWarning,strprintf,_,config_file_path,LogPrintf,config_file_path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
#elif (HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS)

identifier:elif,HAVE_DECL_GETIFADDRS,HAVE_DECL_FREEIFADDRS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61{false};

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
void noui_InitMessage(const std::string& message)

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
#include <string>

/** Non-GUI handler, which logs and prints messages. */
bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style);
/** Non-GUI handler, which logs and prints questions. */
bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style);
/** Non-GUI handler, which only logs a message. */
void noui_InitMessage(const std::string& message);

/** Connect all bitcoind signal handlers */
void noui_connect();

identifier:include,noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout);

identifier:size_t,nSize,GetSerializeSize,txout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
#include <noui.h>
static void InitMessage(const std::string& message)
    noui_InitMessage(message);

identifier:include,noui,h,InitMessage,message,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
#include <noui.h>
static bool ThreadSafeMessageBox(BitcoinGUI* gui, const std::string& message, const std::string& caption, unsigned int style)
    // Redundantly log and print message in non-gui fashion
    noui_ThreadSafeMessageBox(message, caption, style);


identifier:include,noui,h,ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,noui_ThreadSafeMessageBox,message,caption,style,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
        IShellLinkW* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLinkW,
            WCHAR pszExePath[MAX_PATH];
            GetModuleFileNameW(nullptr, pszExePath, ARRAYSIZE(pszExePath));
            PathRemoveFileSpecW(pszExePath);
            psl->SetArguments(strArgs.toStdWString().c_str());
                hres = ppf->Save(StartupShortcutPath().wstring().c_str(), TRUE);

identifier:IShellLinkW,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLinkW,WCHAR,pszExePath,MAX_PATH,GetModuleFileNameW,nullptr,pszExePath,ARRAYSIZE,pszExePath,PathRemoveFileSpecW,pszExePath,psl,SetArguments,strArgs,toStdWString,c_str,hres,ppf,Save,StartupShortcutPath,wstring,c_str,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, PROTOCOL_VERSION));
                utxo_size_inc += GetSerializeSize(out, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;

identifier:result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,utxo_size_inc,GetSerializeSize,out,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s.GetVersion(), args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,GetVersion,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    explicit CSizeComputer(int nVersionIn) : nSize(0), nVersion(nVersionIn) {}
size_t GetSerializeSize(const T& t, int nVersion = 0)
    return (CSizeComputer(nVersion) << t).size();
template <typename... T>
size_t GetSerializeSizeMany(int nVersion, const T&... t)
    CSizeComputer sc(nVersion);

identifier:explicit,CSizeComputer,nVersionIn,nSize,nVersion,nVersionIn,size_t,GetSerializeSize,T,t,nVersion,CSizeComputer,nVersion,t,size,template,typename,T,size_t,GetSerializeSizeMany,nVersion,T,t,CSizeComputer,sc,nVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.cpp
changed code snippet:
#include <test/gen/crypto_gen.h>

#include <key.h>

#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Predicate.h>
#include <rapidcheck/gen/Container.h>

/** Generates 1 to 20 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys()
{
    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {
        return keys.size() >= 1 && keys.size() <= 15;
    });
};

identifier:include,test,gen,crypto_gen,h,include,key,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Predicate,h,include,rapidcheck,gen,Container,h,rc::Gen,CKey,MultisigKeys,rc::gen::suchThat,rc::gen::arbitrary,CKey,CKey,keys,keys,size,keys,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.h
changed code snippet:
#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H
#define BITCOIN_TEST_GEN_CRYPTO_GEN_H

#include <key.h>
#include <random.h>
#include <uint256.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Create.h>
#include <rapidcheck/gen/Numeric.h>

/** Generates 1 to 15 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys();

namespace rc
{
/** Generator for a new CKey */
template <>
struct Arbitrary<CKey> {
    static Gen<CKey> arbitrary()
    {
        return rc::gen::map<int>([](int x) {
            CKey key;
            key.MakeNewKey(true);
            return key;
        });
    };
};

/** Generator for a CPrivKey */
template <>
struct Arbitrary<CPrivKey> {
    static Gen<CPrivKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPrivKey();
        });
    };
};

/** Generator for a new CPubKey */
template <>
struct Arbitrary<CPubKey> {
    static Gen<CPubKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPubKey();
        });
    };
};
/** Generates a arbitrary uint256 */
template <>
struct Arbitrary<uint256> {
    static Gen<uint256> arbitrary()
    {
        return rc::gen::just(GetRandHash());
    };
};
} //namespace rc
#endif

identifier:ifndef,BITCOIN_TEST_GEN_CRYPTO_GEN_H,define,BITCOIN_TEST_GEN_CRYPTO_GEN_H,include,key,h,include,random,h,include,uint256,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Create,h,include,rapidcheck,gen,Numeric,h,rc::Gen,CKey,MultisigKeys,namespace,rc,template,Arbitrary,CKey,Gen,CKey,arbitrary,rc::gen::map,x,CKey,key,key,MakeNewKey,key,template,Arbitrary,CPrivKey,Gen,CPrivKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPrivKey,template,Arbitrary,CPubKey,Gen,CPubKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPubKey,template,Arbitrary,uint256,Gen,uint256,arbitrary,rc::gen::just,GetRandHash,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_properties.cpp
changed code snippet:
#include <key.h>

#include <base58.h>
#include <script/script.h>
#include <uint256.h>
#include <util.h>
#include <utilstrencodings.h>
#include <test/test_bitcoin.h>
#include <string>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <rapidcheck/boost_test.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>

#include <test/gen/crypto_gen.h>

BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)

/** Check CKey uniqueness */
RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))
{
    RC_ASSERT(!(key1 == key2));
}

/** Verify that a private key generates the correct public key */
RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))
{
    CPubKey pubKey = key.GetPubKey();
    RC_ASSERT(key.VerifyPubKey(pubKey));
}

/** Create a CKey using the 'Set' function must give us the same key */
RC_BOOST_PROP(key_set_symmetry, (const CKey& key))
{
    CKey key1;
    key1.Set(key.begin(), key.end(), key.IsCompressed());
    RC_ASSERT(key1 == key);
}

/** Create a CKey, sign a piece of data, then verify it with the public key */
RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))
{
    std::vector<unsigned char> vchSig;
    key.Sign(hash, vchSig, 0);
    const CPubKey& pubKey = key.GetPubKey();
    RC_ASSERT(pubKey.Verify(hash, vchSig));
}
BOOST_AUTO_TEST_SUITE_END()

identifier:include,key,h,include,base58,h,include,script,script,h,include,uint256,h,include,util,h,include,utilstrencodings,h,include,test,test_bitcoin,h,include,include,include,boost,test,unit_test,hpp,include,rapidcheck,boost_test,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,test,gen,crypto_gen,h,BOOST_FIXTURE_TEST_SUITE,key_properties,BasicTestingSetup,RC_BOOST_PROP,key_uniqueness,CKey,key1,CKey,key2,RC_ASSERT,key1,key2,RC_BOOST_PROP,key_generates_correct_pubkey,CKey,key,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,key,VerifyPubKey,pubKey,RC_BOOST_PROP,key_set_symmetry,CKey,key,CKey,key1,key1,Set,key,begin,key,end,key,IsCompressed,RC_ASSERT,key1,key,RC_BOOST_PROP,key_sign_symmetry,CKey,key,uint256,hash,vchSig,key,Sign,hash,vchSig,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,pubKey,Verify,hash,vchSig,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0);
        size += ::GetSerializeSize(VARINT(i), 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            boost::optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);
            if (piter) {
                parentHashes.insert(*piter);
    CAmount delta{0};
    ApplyDelta(entry.GetTx().GetHash(), delta);
    if (delta) {
    for (const auto& pit : GetIterSet(setParentTransactions)) {
const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const
{
    const auto it = mapNextTx.find(prevout);
    return it == mapNextTx.end() ? nullptr : it->second;
}

boost::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const
{
    auto it = mapTx.find(txid);
    if (it != mapTx.end()) return it;
    return boost::optional<txiter>{};
}

CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const
{
    CTxMemPool::setEntries ret;
    for (const auto& h : hashes) {
        const auto mi = GetIter(h);
        if (mi) ret.insert(*mi);
    }
    return ret;
}


identifier:boost::optional,txiter,piter,GetIter,tx,vin,i,prevout,hash,piter,parentHashes,insert,piter,CAmount,delta,ApplyDelta,entry,GetTx,GetHash,delta,delta,pit,GetIterSet,setParentTransactions,CTransaction,CTxMemPool::GetConflictTx,COutPoint,prevout,it,mapNextTx,find,prevout,it,mapNextTx,end,nullptr,it,second,boost::optional,CTxMemPool::txiter,CTxMemPool::GetIter,uint256,txid,it,mapTx,find,txid,it,mapTx,end,it,boost::optional,txiter,CTxMemPool::setEntries,CTxMemPool::GetIterSet,uint256,hashes,CTxMemPool::setEntries,ret,h,hashes,mi,GetIter,h,mi,ret,insert,mi,ret,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    /** Get the transaction in the pool that spends the same prevout */
    const CTransaction* GetConflictTx(const COutPoint& prevout) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Returns an iterator to the given hash, if found */
    boost::optional<txiter> GetIter(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Translate a set of hashes into a set of pool iterators to avoid repeated lookups */
    setEntries GetIterSet(const std::set<uint256>& hashes) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    bool exists(const uint256& hash) const

identifier:CTransaction,GetConflictTx,COutPoint,prevout,EXCLUSIVE_LOCKS_REQUIRED,cs,boost::optional,txiter,GetIter,uint256,txid,EXCLUSIVE_LOCKS_REQUIRED,cs,setEntries,GetIterSet,uint256,hashes,EXCLUSIVE_LOCKS_REQUIRED,cs,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
static bool validNumStr(const std::string& s)
    std::string tokenVal;
bool UniValue::setNumStr(const std::string& val_)
    std::ostringstream oss;
    std::ostringstream oss;
    std::ostringstream oss;
bool UniValue::setStr(const std::string& val_)

identifier:validNumStr,s,tokenVal,UniValue::setNumStr,val_,oss,oss,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
enum jtokentype getJsonToken(std::string& tokenVal, unsigned int& consumed,
        std::string numStr;
        std::string valStr;
    std::vector<UniValue*> stack;
    std::string tokenVal;

identifier:jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
static std::string json_escape(const std::string& inS)
    std::string outS;
std::string UniValue::write(unsigned int prettyIndent,
                            unsigned int indentLevel) const
    std::string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, std::string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const

identifier:json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
std::string srcdir(JSON_TEST_SRC);
static void runtest(std::string filename, const std::string& jdata)
        std::string prefix = filename.substr(0, 4);
        std::string basename(filename_);
        std::string filename = srcdir + "/" + basename;
        std::string jdata;
                std::string s(buf, bread);

identifier:srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#include <codecvt>
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),
    WCHAR pszPath[MAX_PATH] = L"";
    if(SHGetSpecialFolderPathW(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathW() failed, could not obtain requested path.\n");
#ifndef WIN32
#else
    int nErr = ::_wsystem(std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().from_bytes(strCommand).c_str());
#endif

identifier:include,codecvt,args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,MoveFileExW,src,wstring,c_str,dest,wstring,c_str,WCHAR,pszPath,MAX_PATH,L,SHGetSpecialFolderPathW,nullptr,pszPath,nFolder,fCreate,LogPrintf,ifndef,WIN32,nErr,_wsystem,wchar_t,wchar_t,from_bytes,strCommand,c_str,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        const CTransaction* ptxConflicting = pool.GetConflictTx(txin.prevout);
        if (ptxConflicting) {
            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);
            for (const auto& mi : setIterConflicting) {
                    if (pool.exists(tx.vin[j].prevout.hash)) {
                    }
    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());
    unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);
        uiInterface.ShowProgress(_("Replaying blocks..."), (int) ((nHeight - nForkHeight) * 100.0 / (pindexNew->nHeight - nForkHeight)) , false);

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,CTransaction,ptxConflicting,pool,GetConflictTx,txin,prevout,ptxConflicting,CTxMemPool::setEntries,setIterConflicting,pool,GetIterSet,setConflicts,mi,setIterConflicting,pool,exists,tx,vin,j,prevout,hash,nSize,GetSerializeSize,block,fileout,GetVersion,nSize,GetSerializeSize,blockundo,fileout,GetVersion,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,CLIENT_VERSION,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,CLIENT_VERSION,uiInterface,ShowProgress,_,nHeight,nForkHeight,pindexNew,nHeight,nForkHeight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
    //! Was the wallet component compiled in.
    bool HasWalletSupport() const override {return true;}


identifier:HasWalletSupport,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
            if (!ExtractDestination(script, dest) && !internal) {
                throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set to true for nonstandard scriptPubKey imports.");
            }
                if (!(pubkey_dest == dest)) {
                if (!(pubkey_dest == dest)) {
                // add to address book or update label
                if (IsValidDestination(dest)) {
                    pwallet->SetAddressBook(dest, label, "receive");

identifier:ExtractDestination,script,dest,internal,throw,JSONRPCError,RPC_INVALID_PARAMETER,pubkey_dest,dest,pubkey_dest,dest,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
      }
      // test with many inputs
      for (CAmount amt=1500; amt < COIN; amt*=10) {
           empty_wallet();
           // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
           for (uint16_t j = 0; j < 676; j++)
               add_coin(amt);

           // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.
           for (int i = 0; i < RUN_TESTS; i++) {

           }
      }
      // test randomness
      {
          empty_wallet();
          for (int i2 = 0; i2 < 100; i2++)
              add_coin(COIN);
          // Again, we only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.
          for (int i = 0; i < RUN_TESTS; i++) {
          }
          // add 75 cents in small change.  not enough to make 90 cents,
          // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
          // one of which should be picked at random
          add_coin(5 * CENT);
          add_coin(10 * CENT);
          add_coin(15 * CENT);
          add_coin(20 * CENT);
          add_coin(25 * CENT);
          for (int i = 0; i < RUN_TESTS; i++) {
            int fails = 0;
          }
      }


identifier:CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,i,i,RUN_TESTS,i,empty_wallet,i2,i2,i2,add_coin,COIN,i,i,RUN_TESTS,i,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,i,i,RUN_TESTS,i,fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            encrypted_batch = nullptr;
            encrypted_batch = nullptr;
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);

identifier:encrypted_batch,nullptr,encrypted_batch,nullptr,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:
    /** Is the wallet component enabled */
    virtual bool HasWalletSupport() const = 0;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:virtual,HasWalletSupport,WalletInitInterface,g_wallet_init_interface,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:b9ed2fd026926cafe38a1ee23d47eb891a94ddb1
commit B:a2a04a5abb347d52b3ef473f7c80c3c0ffc67a2f
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:37b836ad09369d62244e79bf4ba806516f2344cc
commit B:477f258755265ce49bd56dfbd574616e2cd45584
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),

identifier:MoveFileExA,src,c_str,dest,c_str,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:477f258755265ce49bd56dfbd574616e2cd45584
commit B:81b3f3c7a3d4e68db6587d5be91c54135ffaa176
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:81b3f3c7a3d4e68db6587d5be91c54135ffaa176
commit B:9a565a8282236f29334a6ec2de6a03358f5ce86e
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:9a565a8282236f29334a6ec2de6a03358f5ce86e
commit B:1bfcc0696c4638e1323ab7529f28b604d713067b
++@DIFF ENTRY SEPERATOR@++
changed file:src/key.cpp
changed code snippet:
static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, int compressed) {
    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);

identifier:ec_privkey_export_der,secp256k1_context,ctx,privkey,size_t,privkeylen,key32,compressed,ret,ec_privkey_export_der,secp256k1_context_sign,privkey,data,privkeylen,begin,fCompressed,SECP256K1_EC_COMPRESSED,SECP256K1_EC_UNCOMPRESSED,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:1bfcc0696c4638e1323ab7529f28b604d713067b
commit B:d0b1cee1fe95eba7b968bed2c33ab681d169c91f
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Print help message with debugging options and exit", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help") || args.IsArgSet("-help-debug");

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,args,IsArgSet,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d0b1cee1fe95eba7b968bed2c33ab681d169c91f
commit B:fae3fbd61a89c7a35bc0eda91b1df61371dc0936
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-help-debug", "Show all debugging options (usage: --help -help-debug)", false, OptionsCategory::DEBUG_TEST);

identifier:gArgs,AddArg,OptionsCategory::DEBUG_TEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
template <typename... Args>
static inline void LogPrintf(const char* fmt, const Args&... args)
{
    if (g_logger->Enabled()) {
        std::string log_msg;
        try {
            log_msg = tfm::format(fmt, args...);
        } catch (tinyformat::format_error& fmterr) {
            /* Original format string will have newline so don't add one here */
            log_msg = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + fmt;
        }
        g_logger->LogPrintStr(log_msg);
    }
}
template <typename... Args>
static inline void LogPrint(const BCLog::LogFlags& category, const Args&... args)
{
    if (LogAcceptCategory((category))) {
        LogPrintf(args...);
    }
}

identifier:template,typename,Args,inline,LogPrintf,fmt,Args,args,g_logger,Enabled,log_msg,log_msg,tfm::format,fmt,args,tinyformat::format_error,fmterr,log_msg,fmterr,what,fmt,g_logger,LogPrintStr,log_msg,template,typename,Args,inline,LogPrint,BCLog::LogFlags,category,Args,args,LogAcceptCategory,category,LogPrintf,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/paymentrequestplus.cpp
changed code snippet:
            // This option is just shown in the UI options, if -help-debug is enabled.

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return args.IsArgSet("-?") || args.IsArgSet("-h") || args.IsArgSet("-help");

identifier:args,IsArgSet,args,IsArgSet,args,IsArgSet,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fae3fbd61a89c7a35bc0eda91b1df61371dc0936
commit B:8f464549c46db2954d7b64d1feb200eb35f2e7e8
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.h
changed code snippet:
/** Get format string from VA_ARGS for error reporting */
template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }

static inline void MarkUsed() {}
template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)
{
    (void)t;
    MarkUsed(args...);
}

#ifdef USE_COVERAGE
#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)
#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)
#else
#define LogPrintf(...) do { \
    if (g_logger->Enabled()) { \
        std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \
        try { \
            _log_msg_ = tfm::format(__VA_ARGS__); \
        } catch (tinyformat::format_error &fmterr) { \
            /* Original format string will have newline so don't add one here */ \
            _log_msg_ = "Error \"" + std::string(fmterr.what()) + "\" while formatting log message: " + FormatStringFromLogArgs(__VA_ARGS__); \
        } \
        g_logger->LogPrintStr(_log_msg_); \
    } \
} while(0)
#define LogPrint(category, ...) do { \
    if (LogAcceptCategory((category))) { \
        LogPrintf(__VA_ARGS__); \
    } \
} while(0)
#endif

identifier:template,typename,Args,FormatStringFromLogArgs,fmt,Args,args,fmt,inline,MarkUsed,template,typename,T,typename,Args,inline,MarkUsed,T,t,Args,args,t,MarkUsed,args,ifdef,USE_COVERAGE,define,LogPrintf,MarkUsed,__VA_ARGS__,define,LogPrint,category,MarkUsed,__VA_ARGS__,define,LogPrintf,g_logger,Enabled,_log_msg_,_log_msg_,tfm::format,__VA_ARGS__,tinyformat::format_error,fmterr,_log_msg_,fmterr,what,FormatStringFromLogArgs,__VA_ARGS__,g_logger,LogPrintStr,_log_msg_,define,LogPrint,category,LogAcceptCategory,category,LogPrintf,__VA_ARGS__,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
#include <codecvt>
#ifndef WIN32
#else
    int nErr = ::_wsystem(std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().from_bytes(strCommand).c_str());
#endif

identifier:include,codecvt,ifndef,WIN32,nErr,_wsystem,wchar_t,wchar_t,from_bytes,strCommand,c_str,endif,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:1c12cf60736c5a3ddf75244a0d61cda7f4ad5ed0
commit B:e0664f7f54aa9cf99ba31ca4bd9de1db0a9310a4
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e0664f7f54aa9cf99ba31ca4bd9de1db0a9310a4
commit B:f1bd03eb013b96ff040a8f835e4137fbd2a38cda
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    int major = 0, minor = 0, patch = 0;
    zmq_version(&major, &minor, &patch);
    LogPrint(BCLog::ZMQ, "zmq: version %d.%d.%d\n", major, minor, patch);

    pcontext = zmq_ctx_new();
        zmq_ctx_term(pcontext);

identifier:major,minor,patch,zmq_version,major,minor,patch,LogPrint,BCLog::ZMQ,major,minor,patch,pcontext,zmq_ctx_new,zmq_ctx_term,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:f1bd03eb013b96ff040a8f835e4137fbd2a38cda
commit B:b6a253337f6371e4aa27c488ad70741d2b750d01
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (auto v_i : v) {
    for (auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", _("Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,_,OptionsCategory::OPTIONS,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockfilter.cpp
changed code snippet:
            if (script[0] == OP_RETURN) continue;

identifier:script,OP_RETURN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <consensus/merkle.h>
#include <chainparamsseeds.h>

/**
 * What makes a good checkpoint block?
 * + Is surrounded by blocks with reasonable timestamps
 *   (no blocks before with a timestamp after, none after with
 *    timestamp before)
 * + Contains no strange transactions
 */


identifier:include,consensus,merkle,h,include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx	transaction for which we are checking input total
     * @return	Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (uint32_t loc : locs)
            for (uint32_t loc : locs) {
        for (uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmaped).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
}

FILE *freopen(const fs::path& p, const char *mode, FILE *stream)
{
    return ::freopen(p.string().c_str(), mode, stream);

identifier:FILE,freopen,fs::path,p,mode,FILE,stream,freopen,p,c_str,mode,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
    FILE *freopen(const fs::path& p, const char *mode, FILE *stream);

identifier:FILE,freopen,fs::path,p,mode,FILE,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
    // ifdef can be removed once we switch to better endpoint support and API versioning
    RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
#endif
#ifdef ENABLE_WALLET
    UnregisterHTTPHandler("/wallet/", false);
#endif

identifier:ifdef,ENABLE_WALLET,RegisterHTTPHandler,HTTPReq_JSONRPC,endif,ifdef,ENABLE_WALLET,UnregisterHTTPHandler,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    std::mutex cs;
        std::unique_lock<std::mutex> lock(cs);
                std::unique_lock<std::mutex> lock(cs);
        std::unique_lock<std::mutex> lock(cs);

identifier:cs,lock,cs,lock,cs,lock,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#if !(ENABLE_WALLET)
class DummyWalletInit : public WalletInitInterface {
public:

    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();
#endif

    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (0 to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u or testnet: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", strprintf("Output debugging information (default: %u, supplying <category> is optional)", 0) + ". " +
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set debuglogfile=0)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);
static CWaitableCriticalSection cs_GenesisWait;
static CConditionVariable condvar_GenesisWait;
            WaitableLock lock_GenesisWait(cs_GenesisWait);
        condvar_GenesisWait.notify_all();
    LogPrintf("Using config file %s\n", GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME)).string());
        WaitableLock lock(cs_GenesisWait);
            condvar_GenesisWait.wait_for(lock, std::chrono::milliseconds(500));

identifier:ENABLE_WALLET,class,DummyWalletInit,public,WalletInitInterface,public,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,endif,gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::RPC,CWaitableCriticalSection,cs_GenesisWait,CConditionVariable,condvar_GenesisWait,WaitableLock,lock_GenesisWait,cs_GenesisWait,condvar_GenesisWait,notify_all,LogPrintf,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,WaitableLock,lock,cs_GenesisWait,condvar_GenesisWait,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:
class WalletInitInterface;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:class,WalletInitInterface,WalletInitInterface,g_wallet_init_interface,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.cpp
changed code snippet:
                m_fileout = fsbridge::freopen(m_file_path, "a", m_fileout);
                if (!m_fileout) {
                    return;
                setbuf(m_fileout, nullptr); // unbuffered


identifier:m_fileout,fsbridge::freopen,m_file_path,m_fileout,m_fileout,setbuf,m_fileout,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(nPrevNodeCount);
        for (auto pnode : vNodes) {
        for (CNode* pnode : vNodes) {
            for (CNode* pnode : vNodes) {
        std::unique_lock<std::mutex> lock(mutexMsgProc);
#else
        std::unique_lock<std::mutex> lock(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,nPrevNodeCount,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,lock,mutexMsgProc,lock,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    std::mutex mutexMsgProc;

identifier:mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
static CCriticalSection g_cs_orphans;
        for (uint256 &orphanHash : vOrphanErase) {
            for (uint256 hash : vEraseQueue)

identifier:CCriticalSection,g_cs_orphans,uint256,orphanHash,vOrphanErase,uint256,hash,vEraseQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
static bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
static bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
static void noui_InitMessage(const std::string& message)
    // Connect bitcoind signal handlers

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
extern void noui_connect();

identifier:noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);

identifier:size_t,nSize,GetSerializeSize,txout,SER_DISK,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
static void InitMessage(const std::string &message)
    LogPrintf("init message: %s\n", message);
    for (WalletModel *walletModel : m_wallet_models) {

identifier:InitMessage,message,LogPrintf,message,WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
#include <boost/scoped_array.hpp>

        IShellLink* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLink,
            TCHAR pszExePath[MAX_PATH];
            GetModuleFileName(nullptr, pszExePath, sizeof(pszExePath));
#ifdef UNICODE
            boost::scoped_array<TCHAR> args(new TCHAR[strArgs.length() + 1]);
            // Convert the QString to TCHAR*
            strArgs.toWCharArray(args.get());
            // Add missing '\0'-termination to string
            args[strArgs.length()] = '\0';
#endif

            PathRemoveFileSpec(pszExePath);
#ifndef UNICODE
            psl->SetArguments(strArgs.toStdString().c_str());
#else
            psl->SetArguments(args.get());
#endif
                WCHAR pwsz[MAX_PATH];
                // Ensure that the string is ANSI.
                MultiByteToWideChar(CP_ACP, 0, StartupShortcutPath().string().c_str(), -1, pwsz, MAX_PATH);
                hres = ppf->Save(pwsz, TRUE);

identifier:include,boost,scoped_array,hpp,IShellLink,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLink,TCHAR,pszExePath,MAX_PATH,GetModuleFileName,nullptr,pszExePath,pszExePath,ifdef,UNICODE,boost::scoped_array,TCHAR,args,new,TCHAR,strArgs,length,strArgs,toWCharArray,args,get,args,strArgs,length,endif,PathRemoveFileSpec,pszExePath,ifndef,UNICODE,psl,SetArguments,strArgs,toStdString,c_str,psl,SetArguments,args,get,endif,WCHAR,pwsz,MAX_PATH,MultiByteToWideChar,CP_ACP,StartupShortcutPath,c_str,pwsz,MAX_PATH,hres,ppf,Save,pwsz,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of miliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,miliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (float f : vSamplesIn) {
    for (float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
static std::mutex cs_rng_state;
        std::unique_lock<std::mutex> lock(cs_rng_state);
        std::unique_lock<std::mutex> lock(cs_rng_state);

identifier:cs_rng_state,lock,cs_rng_state,lock,cs_rng_state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure& e) {

identifier:e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static std::mutex cs_blockchange;
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION));
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
    for (const CTxMemPool::txiter &childiter : setChildren) {
                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
            "For more information on output descriptors, see the documentation at TODO\n"

identifier:cs_blockchange,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,lock,cs_blockchange,lock,cs_blockchange,lock,cs_blockchange,CTxMemPool::txiter,childiter,setChildren,utxo_size_inc,GetSerializeSize,out,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index, or the chain tip if
 * not provided.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,or,the,chain,tip,not,provided,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WaitableLock lock(g_best_block_mutex);
    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WaitableLock,lock,g_best_block_mutex,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#include <wallet/wallet.h>
#include <wallet/walletdb.h>
#endif
#ifdef ENABLE_WALLET
        if (HasWallets() && IsDeprecatedRPCEnabled("validateaddress")) {
            ret.pushKVs(getaddressinfo(request));
        }
#endif
        if (ret["address"].isNull()) {
            std::string currentAddress = EncodeDestination(dest);
            ret.pushKV("address", currentAddress);
            CScript scriptPubKey = GetScriptForDestination(dest);
            ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));

            UniValue detail = DescribeAddress(dest);
            ret.pushKVs(detail);
        }
class CWallet;

            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\nNote that from v0.16, createmultisig no longer accepts addresses."
            " Users must use addmultisigaddress to create multisig addresses with addresses known to the wallet.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,include,wallet,wallet,h,include,wallet,walletdb,h,endif,ifdef,ENABLE_WALLET,HasWallets,IsDeprecatedRPCEnabled,ret,pushKVs,getaddressinfo,request,endif,ret,isNull,currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,class,CWallet,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#endif
            // if redeemScript given and not using the local wallet (private keys
            // given), add redeemScript to the keystore so it can be signed:
#ifdef ENABLE_WALLET
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();
#endif

    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)
        throw std::runtime_error(
            "signrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n"
            "\nDEPRECATED. Sign inputs for raw transaction (serialized, hex-encoded).\n"
            "The second optional argument (may be null) is an array of previous transaction outputs that\n"
            "this transaction depends on but may not yet be in the block chain.\n"
            "The third optional argument (may be null) is an array of base58-encoded private\n"
            "keys that, if given, will be the only keys used to sign the transaction.\n"
#ifdef ENABLE_WALLET
            + HelpRequiringPassphrase(pwallet) + "\n"
#endif
            "\nArguments:\n"
            "1. \"hexstring\"     (string, required) The transaction hex string\n"
            "2. \"prevtxs\"       (string, optional) An json array of previous dependent transaction outputs\n"
            "     [               (json array of json objects, or 'null' if none provided)\n"
            "       {\n"
            "         \"txid\":\"id\",             (string, required) The transaction id\n"
            "         \"vout\":n,                  (numeric, required) The output number\n"
            "         \"scriptPubKey\": \"hex\",   (string, required) script key\n"
            "         \"redeemScript\": \"hex\",   (string, required for P2SH or P2WSH) redeem script\n"
            "         \"amount\": value            (numeric, required) The amount spent\n"
            "       }\n"
            "       ,...\n"
            "    ]\n"
            "3. \"privkeys\"     (string, optional) A json array of base58-encoded private keys for signing\n"
            "    [                  (json array of strings, or 'null' if none provided)\n"
            "      \"privatekey\"   (string) private key in base58-encoding\n"
            "      ,...\n"
            "    ]\n"
            "4. \"sighashtype\"     (string, optional, default=ALL) The signature hash type. Must be one of\n"
            "       \"ALL\"\n"
            "       \"NONE\"\n"
            "       \"SINGLE\"\n"
            "       \"ALL|ANYONECANPAY\"\n"
            "       \"NONE|ANYONECANPAY\"\n"
            "       \"SINGLE|ANYONECANPAY\"\n"

            "\nResult:\n"
            "{\n"
            "  \"hex\" : \"value\",           (string) The hex-encoded raw transaction with signature(s)\n"
            "  \"complete\" : true|false,   (boolean) If the transaction has a complete set of signatures\n"
            "  \"errors\" : [                 (json array of objects) Script verification errors (if there are any)\n"
            "    {\n"
            "      \"txid\" : \"hash\",           (string) The hash of the referenced, previous transaction\n"
            "      \"vout\" : n,                (numeric) The index of the output to spent and used as input\n"
            "      \"scriptSig\" : \"hex\",       (string) The hex-encoded signature script\n"
            "      \"sequence\" : n,            (numeric) Script sequence number\n"
            "      \"error\" : \"text\"           (string) Verification or signing error related to the input\n"
            "    }\n"
            "    ,...\n"
            "  ]\n"
            "}\n"

            "\nExamples:\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"")
            + HelpExampleRpc("signrawtransaction", "\"myhex\"")
        );

    if (!IsDeprecatedRPCEnabled("signrawtransaction")) {
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction is deprecated and will be fully removed in v0.18. "
            "To use signrawtransaction in v0.17, restart bitcoind with -deprecatedrpc=signrawtransaction.\n"
            "Projects should transition to using signrawtransactionwithkey and signrawtransactionwithwallet before upgrading to v0.18");
    }

    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);

    // Make a JSONRPCRequest to pass on to the right signrawtransaction* command
    JSONRPCRequest new_request;
    new_request.id = request.id;
    new_request.params.setArray();

    // For signing with private keys
    if (!request.params[2].isNull()) {
        new_request.params.push_back(request.params[0]);
        // Note: the prevtxs and privkeys are reversed for signrawtransactionwithkey
        new_request.params.push_back(request.params[2]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithkey(new_request);
    } else {
#ifdef ENABLE_WALLET
        // Otherwise sign with the wallet which does not take a privkeys parameter
        new_request.params.push_back(request.params[0]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithwallet(new_request);
#else
        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.
        throw JSONRPCError(RPC_INVALID_PARAMETER, "No private keys available.");
#endif
    }
            "\nAlso see createrawtransaction and signrawtransaction calls.\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
                            "                              will be tried. If false, only non-witness deserialization wil be tried. Only has an effect if\n"
    { "rawtransactions",    "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,endif,ifdef,ENABLE_WALLET,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,endif,request,fHelp,request,params,size,request,params,size,throw,ifdef,ENABLE_WALLET,HelpRequiringPassphrase,pwallet,endif,HelpExampleCli,HelpExampleRpc,IsDeprecatedRPCEnabled,throw,JSONRPCError,RPC_METHOD_DEPRECATED,RPCTypeCheck,request,params,UniValue::VSTR,UniValue::VARR,UniValue::VARR,UniValue::VSTR,JSONRPCRequest,new_request,new_request,id,request,id,new_request,params,setArray,request,params,isNull,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithkey,new_request,ifdef,ENABLE_WALLET,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithwallet,new_request,throw,JSONRPCError,RPC_INVALID_PARAMETER,endif,HelpExampleCli,HelpExampleCli,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practially, this means that callbacks can behave as if they are executed

identifier:Practially,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */
/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s, args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    const int nType;
    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}
    int GetType() const { return nType; }
size_t GetSerializeSize(const T& t, int nType, int nVersion = 0)
    return (CSizeComputer(nType, nVersion) << t).size();
template <typename S, typename T>
size_t GetSerializeSize(const S& s, const T& t)
    return (CSizeComputer(s.GetType(), s.GetVersion()) << t).size();
}

template <typename S, typename... T>
size_t GetSerializeSizeMany(const S& s, const T&... t)
{
    CSizeComputer sc(s.GetType(), s.GetVersion());

identifier:nType,CSizeComputer,nTypeIn,nVersionIn,nSize,nType,nTypeIn,nVersion,nVersionIn,GetType,nType,size_t,GetSerializeSize,T,t,nType,nVersion,CSizeComputer,nType,nVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSize,S,s,T,t,CSizeComputer,s,GetType,s,GetVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSizeMany,S,s,T,t,CSizeComputer,sc,s,GetType,s,GetVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
     * in the nbits least signficant bits of a 64-bit uint.

identifier:in,the,nbits,least,signficant,bits,of,a,bit,uint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto alloced = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(alloced->first);

identifier:alloced,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,alloced,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    assert(false);

identifier:assert,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
 * Template mixin that adds -Wthread-safety locking
 * annotations to a subset of the mutex API.
};
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)
class CCriticalSection : public AnnotatedMixin<std::recursive_mutex>
{
public:
    ~CCriticalSection() {
        DeleteLock((void*)this);
    }
};
typedef AnnotatedMixin<std::mutex> CWaitableCriticalSection;

/** Just a typedef for std::condition_variable, can be wrapped later if desired */
typedef std::condition_variable CConditionVariable;

/** Just a typedef for std::unique_lock, can be wrapped later if desired */
typedef std::unique_lock<std::mutex> WaitableLock;
/** Wrapper around std::unique_lock<CCriticalSection> */
class SCOPED_LOCKABLE CCriticalBlock
    std::unique_lock<CCriticalSection> lock;

        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));
        if (!lock.try_lock()) {
            lock.lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);
        lock.try_lock();
        if (!lock.owns_lock())
        return lock.owns_lock();
    CCriticalBlock(CCriticalSection& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : lock(mutexIn, std::defer_lock)
    CCriticalBlock(CCriticalSection* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        lock = std::unique_lock<CCriticalSection>(*pmutexIn, std::defer_lock);
    ~CCriticalBlock() UNLOCK_FUNCTION()
        if (lock.owns_lock())
        return lock.owns_lock();
#define LOCK(cs) CCriticalBlock PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__), criticalblock2(cs2, #cs2, __FILE__, __LINE__)
#define TRY_LOCK(cs, name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)

identifier:Template,mixin,that,adds,Wthread,safety,locking,annotations,to,a,subset,of,the,mutex,API,ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,class,CCriticalSection,public,AnnotatedMixin,public,CCriticalSection,DeleteLock,this,AnnotatedMixin,CWaitableCriticalSection,CConditionVariable,WaitableLock,class,SCOPED_LOCKABLE,CCriticalBlock,CCriticalSection,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,owns_lock,lock,owns_lock,CCriticalBlock,CCriticalSection,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,lock,mutexIn,CCriticalBlock,CCriticalSection,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,lock,CCriticalSection,pmutexIn,CCriticalBlock,UNLOCK_FUNCTION,lock,owns_lock,lock,owns_lock,define,LOCK,cs,CCriticalBlock,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,CCriticalBlock,criticalblock1,cs1,cs1,__FILE__,__LINE__,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,CCriticalBlock,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
    CScript included_scripts[5], excluded_scripts[2];
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(400, included_scripts[3]), 1000, true);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(500, included_scripts[4]), 10000, false);

identifier:CScript,included_scripts,excluded_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (auto i : range) {
        for (bool end_fails : {true, false}) {

identifier:i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure& e) {
    } catch (const std::ios_base::failure& e) {
    } catch (std::logic_error& e) {
    for (CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error& e) {
    for (CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:e,e,e,CAmount,base_value,ABSENT,PRUNED,VALUE1,e,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (uint256& h : hashes_insert_copy)
    for (uint256& h : hashes)
            for (auto h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure& e) {
    for (int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,e,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/denialofservice_tests.cpp
changed code snippet:
extern std::map<uint256, COrphanTx> mapOrphanTransactions;
    LOCK(cs_main);
    LOCK(cs_main);

identifier:uint256,COrphanTx,mapOrphanTransactions,LOCK,cs_main,LOCK,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (auto chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception& e) {
    } catch (const std::exception& e) {

identifier:e,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/scheduler_tests.cpp
changed code snippet:
            assert(i == counter1++);
            assert(i == counter2++);

identifier:assert,i,counter1,assert,i,counter2,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0, 0);
        size += ::GetSerializeSize(VARINT(i), 0, 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (std::string word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, 0, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, 0, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (char opt : "abcdef")
    for (bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
        std::unique_lock<std::mutex> lock(mut);
    std::unique_lock<std::mutex> lock(mut);

identifier:lock,mut,lock,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
    std::mutex mut;

identifier:mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (int64_t nOffset : vSorted)
            for (int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            txiter piter = mapTx.find(tx.vin[i].prevout.hash);
            if (piter != mapTx.end()) {
                parentHashes.insert(piter);
        for (const txiter &phash : setMemPoolParents) {
    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(entry.GetTx().GetHash());
    if (pos != mapDeltas.end()) {
        const CAmount &delta = pos->second;
        if (delta) {
        }
    for (const uint256 &phash : setParentTransactions) {
        txiter pit = mapTx.find(phash);
        if (pit != mapTx.end()) {
        }
        for (const txiter &childiter : setChildren) {
    for (const txiter& it : stage) {

identifier:txiter,piter,mapTx,find,tx,vin,i,prevout,hash,piter,mapTx,end,parentHashes,insert,piter,txiter,phash,setMemPoolParents,uint256,CAmount,const_iterator,pos,mapDeltas,find,entry,GetTx,GetHash,pos,mapDeltas,end,CAmount,delta,pos,second,delta,uint256,phash,setParentTransactions,txiter,pit,mapTx,find,phash,pit,mapTx,end,txiter,childiter,setChildren,txiter,it,stage,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
public:
    bool exists(uint256 hash) const

identifier:public,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:
using namespace std;


identifier:using,namespace,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:
#include <utility>        // std::pair
    bool push_back(std::pair<std::string,UniValue> pear) {
        return pushKV(pear.first, pear.second);
    }
static inline std::pair<std::string,UniValue> Pair(const char *cKey, const char *cVal)
{
    std::string key(cKey);
    UniValue uVal(cVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, std::string strVal)
{
    std::string key(cKey);
    UniValue uVal(strVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, uint64_t u64Val)
{
    std::string key(cKey);
    UniValue uVal(u64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int64_t i64Val)
{
    std::string key(cKey);
    UniValue uVal(i64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, bool iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, double dVal)
{
    std::string key(cKey);
    UniValue uVal(dVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, const UniValue& uVal)
{
    std::string key(cKey);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(std::string key, const UniValue& uVal)
{
    return std::make_pair(key, uVal);
}


identifier:include,utility,push_back,UniValue,pear,pushKV,pear,first,pear,second,inline,UniValue,Pair,cKey,cVal,key,cKey,UniValue,uVal,cVal,key,uVal,inline,UniValue,Pair,cKey,strVal,key,cKey,UniValue,uVal,strVal,key,uVal,inline,UniValue,Pair,cKey,uint64_t,u64Val,key,cKey,UniValue,uVal,u64Val,key,uVal,inline,UniValue,Pair,cKey,int64_t,i64Val,key,cKey,UniValue,uVal,i64Val,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,dVal,key,cKey,UniValue,uVal,dVal,key,uVal,inline,UniValue,Pair,cKey,UniValue,uVal,key,cKey,key,uVal,inline,UniValue,Pair,key,UniValue,uVal,key,uVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
using namespace std;

static bool validNumStr(const string& s)
    string tokenVal;
bool UniValue::setNumStr(const string& val_)
    ostringstream oss;
    ostringstream oss;
    ostringstream oss;
bool UniValue::setStr(const string& val_)

identifier:using,namespace,validNumStr,s,tokenVal,UniValue::setNumStr,val_,ostringstream,oss,ostringstream,oss,ostringstream,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
using namespace std;

enum jtokentype getJsonToken(string& tokenVal, unsigned int& consumed,
        string numStr;
        string valStr;
    vector<UniValue*> stack;
    string tokenVal;

identifier:using,namespace,jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
using namespace std;

static string json_escape(const string& inS)
    string outS;
string UniValue::write(unsigned int prettyIndent,
                       unsigned int indentLevel) const
    string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, string& s) const

identifier:using,namespace,json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
using namespace std;
string srcdir(JSON_TEST_SRC);
static void runtest(string filename, const string& jdata)
        string prefix = filename.substr(0, 4);
        string basename(filename_);
        string filename = srcdir + "/" + basename;
        string jdata;
                string s(buf, bread);

identifier:using,namespace,srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
static std::vector<std::pair<std::string, std::string>> GetConfigOptions(std::istream& stream)
    std::vector<std::pair<std::string, std::string>> options;
    return options;

    for (const std::pair<std::string, std::string>& option : GetConfigOptions(stream)) {
    char pszPath[MAX_PATH] = "";
    if(SHGetSpecialFolderPathA(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathA() failed, could not obtain requested path.\n");

identifier:GetConfigOptions,stream,options,options,option,GetConfigOptions,stream,pszPath,MAX_PATH,SHGetSpecialFolderPathA,nullptr,pszPath,nFolder,fCreate,LogPrintf,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (auto c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
CWaitableCriticalSection g_best_block_mutex;
CConditionVariable g_best_block_cv;
            for (int height : prevheights) {
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        auto itConflicting = pool.mapNextTx.find(txin.prevout);
        if (itConflicting != pool.mapNextTx.end())
        {
            const CTransaction *ptxConflicting = itConflicting->second;
            CTxMemPool::setEntries setIterConflicting;
            for (const uint256 &hashConflicting : setConflicts)
            {
                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);
                if (mi == pool.mapTx.end())
                    continue;

                // Save these to avoid repeated lookups
                setIterConflicting.insert(mi);

                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())
    unsigned int nSize = GetSerializeSize(fileout, block);
    unsigned int nSize = GetSerializeSize(fileout, blockundo);
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))
        WaitableLock lock(g_best_block_mutex);
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);
    for (BlockMap::value_type& entry : mapBlockIndex) {
    for (auto& entry : mapBlockIndex) {

identifier:CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,height,prevheights,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,itConflicting,pool,mapNextTx,find,txin,prevout,itConflicting,pool,mapNextTx,end,CTransaction,ptxConflicting,itConflicting,second,CTxMemPool::setEntries,setIterConflicting,uint256,hashConflicting,setConflicts,CTxMemPool::txiter,mi,pool,mapTx,find,hashConflicting,mi,pool,mapTx,end,setIterConflicting,insert,mi,pool,mapTx,find,tx,vin,j,prevout,hash,pool,mapTx,end,nSize,GetSerializeSize,fileout,block,nSize,GetSerializeSize,fileout,blockundo,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,SER_DISK,CLIENT_VERSION,WaitableLock,lock,g_best_block_mutex,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,SER_DISK,CLIENT_VERSION,BlockMap::value_type,entry,mapBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
extern CWaitableCriticalSection g_best_block_mutex;
extern CConditionVariable g_best_block_cv;

identifier:CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An ununsed temporary BerkeleyEnvironment object may be created inside the
            for (auto& env : g_dbenvs) {

identifier:env,g_dbenvs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (unsigned char c : str) {
        // Not having Internal + Script
        if (!internal && isScript) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set for hex scriptPubKey");
        }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (scriptPubKey.getType() == UniValue::VOBJ) {
                    // add to address book or update label
                    if (IsValidDestination(dest)) {
                        pwallet->SetAddressBook(dest, label, "receive");
                    }

identifier:c,str,internal,isScript,throw,JSONRPCError,RPC_INVALID_PARAMETER,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,scriptPubKey,getType,UniValue::VOBJ,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    std::string old_label = pwallet->mapAddressBook[dest].name;
    for (COutPoint &outpt : vOutpts) {

identifier:old_label,pwallet,mapAddressBook,dest,name,COutPoint,outpt,vOutpts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
        // test with many inputs
        for (CAmount amt=1500; amt < COIN; amt*=10) {
             empty_wallet();
             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
             for (uint16_t j = 0; j < 676; j++)
                 add_coin(amt);
        }
        // test randomness
        {
            empty_wallet();
            for (int i2 = 0; i2 < 100; i2++)
                add_coin(COIN);
            // add 75 cents in small change.  not enough to make 90 cents,
            // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
            // one of which should be picked at random
            add_coin(5 * CENT);
            add_coin(10 * CENT);
            add_coin(15 * CENT);
            add_coin(20 * CENT);
            add_coin(25 * CENT);
            fails = 0;
        }
    }

identifier:CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,empty_wallet,i2,i2,i2,add_coin,COIN,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/wallet_tests.cpp
changed code snippet:
    auto list = wallet->ListCoins();
    list = wallet->ListCoins();
    list = wallet->ListCoins();

identifier:list,wallet,ListCoins,list,wallet,ListCoins,list,wallet,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
    for (auto& input : tx.vin) {
    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
    // TODO: Add AssertLockHeld(cs_wallet) here.
    //
    // Because the return value from this function contains pointers to
    // CWalletTx objects, callers to this function really should acquire the
    // cs_wallet lock before calling it. However, the current caller doesn't
    // acquire this lock yet. There was an attempt to add the missing lock in
    // https://github.com/bitcoin/bitcoin/pull/10340, but that change has been
    // postponed until after https://github.com/bitcoin/bitcoin/pull/10244 to
    // avoid adding some extra complexity to the Qt code.
    LOCK2(cs_main, cs_wallet);
    for (auto& coin : availableCoins) {
    for (const auto& output : lockedCoins) {
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);
        for (int64_t nIndex : setInternalKeyPool) {
        for (int64_t nIndex : setExternalKeyPool) {
        for (int64_t nIndex : set_pre_split_keypool) {
            for (CTxIn txin : pcoin->tx->vin)
               for (CTxOut txout : pcoin->tx->vout)
        for (CTxDestination address : _grouping)
        for (CTxDestination element : *merged)
    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)

identifier:input,tx,vin,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,LOCK2,cs_main,cs_wallet,coin,availableCoins,output,lockedCoins,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,SER_DISK,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,SER_NETWORK,PROTOCOL_VERSION,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.h
changed code snippet:
    std::map<CTxDestination, std::vector<COutput>> ListCoins() const;

identifier:CTxDestination,COutput,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
    for (uint256 hash : wss.vWalletUpgrade)
    for (uint256 hash : vTxHash) {
    for (uint256& hash : vTxHash) {

identifier:uint256,hash,wss,vWalletUpgrade,uint256,hash,vTxHash,uint256,hash,vTxHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/zmq/zmqnotificationinterface.cpp
changed code snippet:
    pcontext = zmq_init(1);
        zmq_ctx_destroy(pcontext);

identifier:pcontext,zmq_init,zmq_ctx_destroy,pcontext,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:b6a253337f6371e4aa27c488ad70741d2b750d01
commit B:4103cc31690e5be21854a9628f57c54b880ee195
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (const auto v_i : v) {
    for (const auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-rpccookiefile=<loc>", "Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (const CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockfilter.cpp
changed code snippet:
            if (script.empty() || script[0] == OP_RETURN) continue;
            if (script.empty()) continue;

identifier:script,empty,script,OP_RETURN,script,empty,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:

#include <chainparamsseeds.h>

identifier:include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx    transaction for which we are checking input total
     * @return  Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,PROTOCOL_VERSION,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,PROTOCOL_VERSION,GetSerializeSize,txin,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (const uint32_t loc : locs)
            for (const uint32_t loc : locs) {
        for (const uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmap'ed).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

#include <stdio.h>
#include <util.h>
#include <walletinitinterface.h>

class DummyWalletInit : public WalletInitInterface {
public:

    bool HasWalletSupport() const override {return false;}
    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();

identifier:include,stdio,h,include,util,h,include,walletinitinterface,h,class,DummyWalletInit,public,WalletInitInterface,public,HasWalletSupport,override,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
#ifndef WIN32
#else
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t> utf8_cvt;
    return ::_wfopen(p.wstring().c_str(), utf8_cvt.from_bytes(mode).c_str());
#endif

identifier:ifndef,WIN32,wchar_t,wchar_t,utf8_cvt,_wfopen,p,wstring,c_str,utf8_cvt,from_bytes,mode,c_str,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#include <walletinitinterface.h>
    if (g_wallet_init_interface.HasWalletSupport()) {
        RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
    }
    if (g_wallet_init_interface.HasWalletSupport()) {
        UnregisterHTTPHandler("/wallet/", false);
    }

identifier:include,walletinitinterface,h,g_wallet_init_interface,HasWalletSupport,RegisterHTTPHandler,HTTPReq_JSONRPC,g_wallet_init_interface,HasWalletSupport,UnregisterHTTPHandler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    Mutex cs;
        LOCK(cs);
                WAIT_LOCK(cs, lock);
        LOCK(cs);

identifier:Mutex,cs,LOCK,cs,WAIT_LOCK,cs,lock,LOCK,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    const auto regtestChainParams = CreateChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -noconnect disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services, set -noonion to disable (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort(), regtestChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy, set -noproxy to disable (default: disabled)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", "Output debugging information (default: -nodebug, supplying <category> is optional). "
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::RPC);
static Mutex g_genesis_wait_mutex;
static std::condition_variable g_genesis_wait_cv;
            LOCK(g_genesis_wait_mutex);
        g_genesis_wait_cv.notify_all();

    // Only log conf file usage message if conf file actually exists.
    fs::path config_file_path = GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME));
    if (fs::exists(config_file_path)) {
        LogPrintf("Config file: %s\n", config_file_path.string());
    } else if (gArgs.IsArgSet("-conf")) {
        // Warn if no conf file exists at path provided by user
        InitWarning(strprintf(_("The specified config file %s does not exist\n"), config_file_path.string()));
    } else {
        // Not categorizing as "Warning" because it's the default behavior
        LogPrintf("Config file: %s (not found, skipping)\n", config_file_path.string());
    }

        WAIT_LOCK(g_genesis_wait_mutex, lock);
            g_genesis_wait_cv.wait_for(lock, std::chrono::milliseconds(500));

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,regtestChainParams,CreateChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,regtestChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::RPC,Mutex,g_genesis_wait_mutex,g_genesis_wait_cv,LOCK,g_genesis_wait_mutex,g_genesis_wait_cv,notify_all,fs::path,config_file_path,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,fs::exists,config_file_path,LogPrintf,config_file_path,gArgs,IsArgSet,InitWarning,strprintf,_,config_file_path,LogPrintf,config_file_path,WAIT_LOCK,g_genesis_wait_mutex,lock,g_genesis_wait_cv,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.cpp
changed code snippet:
                FILE* new_fileout = fsbridge::fopen(m_file_path, "a");
                if (new_fileout) {
                    setbuf(new_fileout, nullptr); // unbuffered
                    fclose(m_fileout);
                    m_fileout = new_fileout;

identifier:FILE,new_fileout,fsbridge::fopen,m_file_path,new_fileout,setbuf,new_fileout,nullptr,fclose,m_fileout,m_fileout,new_fileout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (const CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(vNodesSize);
        for (const CNode* pnode : vNodes) {
        for (const CNode* pnode : vNodes) {
            for (const CNode* pnode : vNodes) {
        WAIT_LOCK(mutexMsgProc, lock);
#elif (HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS)
        LOCK(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,vNodesSize,CNode,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,WAIT_LOCK,mutexMsgProc,lock,elif,HAVE_DECL_GETIFADDRS,HAVE_DECL_FREEIFADDRS,LOCK,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    Mutex mutexMsgProc;

identifier:Mutex,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
CCriticalSection g_cs_orphans;
        for (const uint256& orphanHash : vOrphanErase) {
            for (const uint256& hash : vEraseQueue)

identifier:CCriticalSection,g_cs_orphans,uint256,orphanHash,vOrphanErase,uint256,hash,vEraseQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61{false};

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
void noui_InitMessage(const std::string& message)

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
#include <string>

/** Non-GUI handler, which logs and prints messages. */
bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style);
/** Non-GUI handler, which logs and prints questions. */
bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style);
/** Non-GUI handler, which only logs a message. */
void noui_InitMessage(const std::string& message);

/** Connect all bitcoind signal handlers */
void noui_connect();

identifier:include,noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout);

identifier:size_t,nSize,GetSerializeSize,txout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
#include <noui.h>
static void InitMessage(const std::string& message)
    noui_InitMessage(message);
    for (const WalletModel* walletModel : m_wallet_models) {

identifier:include,noui,h,InitMessage,message,noui_InitMessage,message,WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
#include <noui.h>
#ifndef Q_OS_MAC
    // Note: On Mac, the dock icon's menu already has show / hide action.
#endif
static bool ThreadSafeMessageBox(BitcoinGUI* gui, const std::string& message, const std::string& caption, unsigned int style)
    // Redundantly log and print message in non-gui fashion
    noui_ThreadSafeMessageBox(message, caption, style);

    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:include,noui,h,ifndef,Q_OS_MAC,endif,ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,noui_ThreadSafeMessageBox,message,caption,style,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
        IShellLinkW* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLinkW,
            WCHAR pszExePath[MAX_PATH];
            GetModuleFileNameW(nullptr, pszExePath, ARRAYSIZE(pszExePath));
            PathRemoveFileSpecW(pszExePath);
            psl->SetArguments(strArgs.toStdWString().c_str());
                hres = ppf->Save(StartupShortcutPath().wstring().c_str(), TRUE);

identifier:IShellLinkW,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLinkW,WCHAR,pszExePath,MAX_PATH,GetModuleFileNameW,nullptr,pszExePath,ARRAYSIZE,pszExePath,PathRemoveFileSpecW,pszExePath,psl,SetArguments,strArgs,toStdWString,c_str,hres,ppf,Save,StartupShortcutPath,wstring,c_str,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (const auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (const auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of milliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,milliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (const float f : vSamplesIn) {
    for (const float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
#include <sync.h>     // for WAIT_LOCK
static Mutex cs_rng_state;
        WAIT_LOCK(cs_rng_state, lock);
        WAIT_LOCK(cs_rng_state, lock);

identifier:include,sync,h,Mutex,cs_rng_state,WAIT_LOCK,cs_rng_state,lock,WAIT_LOCK,cs_rng_state,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static Mutex cs_blockchange;
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, PROTOCOL_VERSION));
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
    for (CTxMemPool::txiter childiter : setChildren) {
                utxo_size_inc += GetSerializeSize(out, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
            "For more information on output descriptors, see the documentation in the doc/descriptors.md file.\n"

identifier:Mutex,cs_blockchange,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,CTxMemPool::txiter,childiter,setChildren,utxo_size_inc,GetSerializeSize,out,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WAIT_LOCK(g_best_block_mutex, lock);
    for (const FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WAIT_LOCK,g_best_block_mutex,lock,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
        std::string currentAddress = EncodeDestination(dest);
        ret.pushKV("address", currentAddress);
        CScript scriptPubKey = GetScriptForDestination(dest);
        ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));
        UniValue detail = DescribeAddress(dest);
        ret.pushKVs(detail);
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\n.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} },

identifier:currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (const int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
            // if redeemScript and private keys were given, add redeemScript to the keystore so it can be signed
    // This method should be removed entirely in V0.19, along with the entries in the
    // CRPCCommand table and rpc/client.cpp.
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction was removed in v0.18.\n"
        "Clients should transition to using signrawtransactionwithkey and signrawtransactionwithwallet");
            "\nAlso see createrawtransaction and signrawtransactionwithkey calls.\n"
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
                            "                              will be tried. If false, only non-witness deserialization will be tried. Only has an effect if\n"
    { "hidden",             "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} },

identifier:throw,JSONRPCError,RPC_METHOD_DEPRECATED,HelpExampleCli,HelpExampleCli,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practically, this means that callbacks can behave as if they are executed

identifier:Practically,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If successful, sp is updated to skip the constant and return true. */
/** Parse a function call. If successful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s.GetVersion(), args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,GetVersion,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    explicit CSizeComputer(int nVersionIn) : nSize(0), nVersion(nVersionIn) {}
size_t GetSerializeSize(const T& t, int nVersion = 0)
    return (CSizeComputer(nVersion) << t).size();
template <typename... T>
size_t GetSerializeSizeMany(int nVersion, const T&... t)
    CSizeComputer sc(nVersion);

identifier:explicit,CSizeComputer,nVersionIn,nSize,nVersion,nVersionIn,size_t,GetSerializeSize,T,t,nVersion,CSizeComputer,nVersion,t,size,template,typename,T,size_t,GetSerializeSizeMany,nVersion,T,t,CSizeComputer,sc,nVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
     * in the nbits least significant bits of a 64-bit uint.

identifier:in,the,nbits,least,significant,bits,of,a,bit,uint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto allocated = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(allocated->first);

identifier:allocated,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,allocated,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    if (g_debug_lockorder_abort) {
        fprintf(stderr, "Assertion failed: detected inconsistent lock order at %s:%i, details in debug log.\n", __FILE__, __LINE__);
        abort();
    }
    throw std::logic_error("potential deadlock detected");
bool g_debug_lockorder_abort = true;


identifier:g_debug_lockorder_abort,fprintf,stderr,__FILE__,__LINE__,abort,throw,g_debug_lockorder_abort,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);

 * Call abort() if a potential lock order deadlock bug is detected, instead of
 * just logging information and throwing a logic_error. Defaults to true, and
 * set to false in DEBUG_LOCKORDER unit tests.
 */
extern bool g_debug_lockorder_abort;
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)

/**
 * Template mixin that adds -Wthread-safety locking annotations and lock order
 * checking to a subset of the mutex API.
    ~AnnotatedMixin() {
        DeleteLock((void*)this);
    }


    using UniqueLock = std::unique_lock<PARENT>;
typedef AnnotatedMixin<std::recursive_mutex> CCriticalSection;
typedef AnnotatedMixin<std::mutex> Mutex;
/** Wrapper around std::unique_lock style lock for Mutex. */
template <typename Mutex, typename Base = typename Mutex::UniqueLock>
class SCOPED_LOCKABLE UniqueLock : public Base
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()));
        if (!Base::try_lock()) {
            Base::lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()), true);
        Base::try_lock();
        if (!Base::owns_lock())
        return Base::owns_lock();
    UniqueLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : Base(mutexIn, std::defer_lock)
    UniqueLock(Mutex* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        *static_cast<Base*>(this) = Base(*pmutexIn, std::defer_lock);
    ~UniqueLock() UNLOCK_FUNCTION()
        if (Base::owns_lock())
        return Base::owns_lock();
template<typename MutexArg>
using DebugLock = UniqueLock<typename std::remove_reference<typename std::remove_pointer<MutexArg>::type>::type>;

#define LOCK(cs) DebugLock<decltype(cs)> PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2)                                               \
    DebugLock<decltype(cs1)> criticalblock1(cs1, #cs1, __FILE__, __LINE__); \
    DebugLock<decltype(cs2)> criticalblock2(cs2, #cs2, __FILE__, __LINE__);
#define TRY_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__, true)
#define WAIT_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__)

identifier:ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,Call,abort,a,potential,lock,order,deadlock,bug,is,detected,instead,of,just,logging,information,and,throwing,a,logic_error,Defaults,to,and,set,to,in,DEBUG_LOCKORDER,unit,tests,g_debug_lockorder_abort,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,template,typename,Mutex,typename,Base,typename,Mutex::UniqueLock,class,SCOPED_LOCKABLE,UniqueLock,public,Base,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::lock,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::owns_lock,Base::owns_lock,UniqueLock,Mutex,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,Base,mutexIn,UniqueLock,Mutex,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,static_cast,Base,this,Base,pmutexIn,UniqueLock,UNLOCK_FUNCTION,Base::owns_lock,Base::owns_lock,template,typename,MutexArg,using,DebugLock,UniqueLock,typename,typename,MutexArg,type,type,define,LOCK,cs,DebugLock,decltype,cs,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,DebugLock,decltype,cs1,criticalblock1,cs1,cs1,__FILE__,__LINE__,DebugLock,decltype,cs2,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,define,WAIT_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
    CScript included_scripts[5], excluded_scripts[3];
    tx_2.vout.emplace_back(400, excluded_scripts[2]); // Script is empty
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(500, included_scripts[3]), 1000, true);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(600, included_scripts[4]), 10000, false);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(700, excluded_scripts[2]), 100000, false);

identifier:CScript,included_scripts,excluded_scripts,tx_2,vout,emplace_back,excluded_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,excluded_scripts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (const size_t i : range) {
        for (const bool end_fails : {true, false}) {

identifier:size_t,i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure&) {
    } catch (const std::ios_base::failure&) {
    } catch (std::logic_error&) {
    for (const CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error&) {
    for (const CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (const CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (const char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (const char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:CAmount,base_value,ABSENT,PRUNED,VALUE1,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (const uint256& h : hashes_insert_copy)
    for (const uint256& h : hashes)
            for (const auto& h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure&) {
    for (const int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/denialofservice_tests.cpp
changed code snippet:
extern CCriticalSection g_cs_orphans;
extern std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);
    LOCK2(cs_main, g_cs_orphans);
    LOCK2(cs_main, g_cs_orphans);

identifier:CCriticalSection,g_cs_orphans,uint256,COrphanTx,mapOrphanTransactions,GUARDED_BY,g_cs_orphans,LOCK2,cs_main,g_cs_orphans,LOCK2,cs_main,g_cs_orphans,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.cpp
changed code snippet:
#include <test/gen/crypto_gen.h>

#include <key.h>

#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Predicate.h>
#include <rapidcheck/gen/Container.h>

/** Generates 1 to 20 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys()
{
    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {
        return keys.size() >= 1 && keys.size() <= 15;
    });
};

identifier:include,test,gen,crypto_gen,h,include,key,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Predicate,h,include,rapidcheck,gen,Container,h,rc::Gen,CKey,MultisigKeys,rc::gen::suchThat,rc::gen::arbitrary,CKey,CKey,keys,keys,size,keys,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.h
changed code snippet:
#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H
#define BITCOIN_TEST_GEN_CRYPTO_GEN_H

#include <key.h>
#include <random.h>
#include <uint256.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Create.h>
#include <rapidcheck/gen/Numeric.h>

/** Generates 1 to 15 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys();

namespace rc
{
/** Generator for a new CKey */
template <>
struct Arbitrary<CKey> {
    static Gen<CKey> arbitrary()
    {
        return rc::gen::map<int>([](int x) {
            CKey key;
            key.MakeNewKey(true);
            return key;
        });
    };
};

/** Generator for a CPrivKey */
template <>
struct Arbitrary<CPrivKey> {
    static Gen<CPrivKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPrivKey();
        });
    };
};

/** Generator for a new CPubKey */
template <>
struct Arbitrary<CPubKey> {
    static Gen<CPubKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPubKey();
        });
    };
};
/** Generates a arbitrary uint256 */
template <>
struct Arbitrary<uint256> {
    static Gen<uint256> arbitrary()
    {
        return rc::gen::just(GetRandHash());
    };
};
} //namespace rc
#endif

identifier:ifndef,BITCOIN_TEST_GEN_CRYPTO_GEN_H,define,BITCOIN_TEST_GEN_CRYPTO_GEN_H,include,key,h,include,random,h,include,uint256,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Create,h,include,rapidcheck,gen,Numeric,h,rc::Gen,CKey,MultisigKeys,namespace,rc,template,Arbitrary,CKey,Gen,CKey,arbitrary,rc::gen::map,x,CKey,key,key,MakeNewKey,key,template,Arbitrary,CPrivKey,Gen,CPrivKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPrivKey,template,Arbitrary,CPubKey,Gen,CPubKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPubKey,template,Arbitrary,uint256,Gen,uint256,arbitrary,rc::gen::just,GetRandHash,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (const std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (const auto& chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_properties.cpp
changed code snippet:
#include <key.h>

#include <base58.h>
#include <script/script.h>
#include <uint256.h>
#include <util.h>
#include <utilstrencodings.h>
#include <test/test_bitcoin.h>
#include <string>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <rapidcheck/boost_test.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>

#include <test/gen/crypto_gen.h>

BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)

/** Check CKey uniqueness */
RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))
{
    RC_ASSERT(!(key1 == key2));
}

/** Verify that a private key generates the correct public key */
RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))
{
    CPubKey pubKey = key.GetPubKey();
    RC_ASSERT(key.VerifyPubKey(pubKey));
}

/** Create a CKey using the 'Set' function must give us the same key */
RC_BOOST_PROP(key_set_symmetry, (const CKey& key))
{
    CKey key1;
    key1.Set(key.begin(), key.end(), key.IsCompressed());
    RC_ASSERT(key1 == key);
}

/** Create a CKey, sign a piece of data, then verify it with the public key */
RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))
{
    std::vector<unsigned char> vchSig;
    key.Sign(hash, vchSig, 0);
    const CPubKey& pubKey = key.GetPubKey();
    RC_ASSERT(pubKey.Verify(hash, vchSig));
}
BOOST_AUTO_TEST_SUITE_END()

identifier:include,key,h,include,base58,h,include,script,script,h,include,uint256,h,include,util,h,include,utilstrencodings,h,include,test,test_bitcoin,h,include,include,include,boost,test,unit_test,hpp,include,rapidcheck,boost_test,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,test,gen,crypto_gen,h,BOOST_FIXTURE_TEST_SUITE,key_properties,BasicTestingSetup,RC_BOOST_PROP,key_uniqueness,CKey,key1,CKey,key2,RC_ASSERT,key1,key2,RC_BOOST_PROP,key_generates_correct_pubkey,CKey,key,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,key,VerifyPubKey,pubKey,RC_BOOST_PROP,key_set_symmetry,CKey,key,CKey,key1,key1,Set,key,begin,key,end,key,IsCompressed,RC_ASSERT,key1,key,RC_BOOST_PROP,key_sign_symmetry,CKey,key,uint256,hash,vchSig,key,Sign,hash,vchSig,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,pubKey,Verify,hash,vchSig,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception&) {
    } catch (const std::exception&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/scheduler_tests.cpp
changed code snippet:
            bool expectation = i == counter1++;
            assert(expectation);
            bool expectation = i == counter2++;
            assert(expectation);

identifier:expectation,i,counter1,assert,expectation,expectation,i,counter2,assert,expectation,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0);
        size += ::GetSerializeSize(VARINT(i), 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (const unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/sync_tests.cpp
changed code snippet:

#include <sync.h>
#include <test/test_bitcoin.h>

#include <boost/test/unit_test.hpp>

namespace {
template <typename MutexType>
void TestPotentialDeadLockDetected(MutexType& mutex1, MutexType& mutex2)
{
    {
        LOCK2(mutex1, mutex2);
    }
    bool error_thrown = false;
    try {
        LOCK2(mutex2, mutex1);
    } catch (const std::logic_error& e) {
        BOOST_CHECK_EQUAL(e.what(), "potential deadlock detected");
        error_thrown = true;
    }
    #ifdef DEBUG_LOCKORDER
    BOOST_CHECK(error_thrown);
    #else
    BOOST_CHECK(!error_thrown);
    #endif
}
} // namespace

BOOST_FIXTURE_TEST_SUITE(sync_tests, BasicTestingSetup)

BOOST_AUTO_TEST_CASE(potential_deadlock_detected)
{
    #ifdef DEBUG_LOCKORDER
    bool prev = g_debug_lockorder_abort;
    g_debug_lockorder_abort = false;
    #endif

    CCriticalSection rmutex1, rmutex2;
    TestPotentialDeadLockDetected(rmutex1, rmutex2);

    Mutex mutex1, mutex2;
    TestPotentialDeadLockDetected(mutex1, mutex2);

    #ifdef DEBUG_LOCKORDER
    g_debug_lockorder_abort = prev;
    #endif
}

BOOST_AUTO_TEST_SUITE_END()

identifier:include,sync,h,include,test,test_bitcoin,h,include,boost,test,unit_test,hpp,namespace,template,typename,MutexType,TestPotentialDeadLockDetected,MutexType,mutex1,MutexType,mutex2,LOCK2,mutex1,mutex2,error_thrown,LOCK2,mutex2,mutex1,e,BOOST_CHECK_EQUAL,e,what,error_thrown,ifdef,DEBUG_LOCKORDER,BOOST_CHECK,error_thrown,BOOST_CHECK,error_thrown,endif,BOOST_FIXTURE_TEST_SUITE,sync_tests,BasicTestingSetup,BOOST_AUTO_TEST_CASE,potential_deadlock_detected,ifdef,DEBUG_LOCKORDER,prev,g_debug_lockorder_abort,g_debug_lockorder_abort,endif,CCriticalSection,rmutex1,rmutex2,TestPotentialDeadLockDetected,rmutex1,rmutex2,Mutex,mutex1,mutex2,TestPotentialDeadLockDetected,mutex1,mutex2,ifdef,DEBUG_LOCKORDER,g_debug_lockorder_abort,prev,endif,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (const CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (const std::string& word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (const char opt : "abcdef")
    for (const bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
#include <sync.h>

        LOCK(mut);
    WAIT_LOCK(mut, lock);

identifier:include,sync,h,LOCK,mut,WAIT_LOCK,mut,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
#include <sync.h>

    Mutex mut;

identifier:include,sync,h,Mutex,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (const int64_t nOffset : vSorted)
            for (const int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            boost::optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);
            if (piter) {
                parentHashes.insert(*piter);
        for (txiter phash : setMemPoolParents) {
    CAmount delta{0};
    ApplyDelta(entry.GetTx().GetHash(), delta);
    if (delta) {
    for (const auto& pit : GetIterSet(setParentTransactions)) {
        for (txiter childiter : setChildren) {
const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const
{
    const auto it = mapNextTx.find(prevout);
    return it == mapNextTx.end() ? nullptr : it->second;
}

boost::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const
{
    auto it = mapTx.find(txid);
    if (it != mapTx.end()) return it;
    return boost::optional<txiter>{};
}

CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const
{
    CTxMemPool::setEntries ret;
    for (const auto& h : hashes) {
        const auto mi = GetIter(h);
        if (mi) ret.insert(*mi);
    }
    return ret;
}

    for (txiter it : stage) {

identifier:boost::optional,txiter,piter,GetIter,tx,vin,i,prevout,hash,piter,parentHashes,insert,piter,txiter,phash,setMemPoolParents,CAmount,delta,ApplyDelta,entry,GetTx,GetHash,delta,delta,pit,GetIterSet,setParentTransactions,txiter,childiter,setChildren,CTransaction,CTxMemPool::GetConflictTx,COutPoint,prevout,it,mapNextTx,find,prevout,it,mapNextTx,end,nullptr,it,second,boost::optional,CTxMemPool::txiter,CTxMemPool::GetIter,uint256,txid,it,mapTx,find,txid,it,mapTx,end,it,boost::optional,txiter,CTxMemPool::setEntries,CTxMemPool::GetIterSet,uint256,hashes,CTxMemPool::setEntries,ret,h,hashes,mi,GetIter,h,mi,ret,insert,mi,ret,txiter,it,stage,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    /** Get the transaction in the pool that spends the same prevout */
    const CTransaction* GetConflictTx(const COutPoint& prevout) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Returns an iterator to the given hash, if found */
    boost::optional<txiter> GetIter(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Translate a set of hashes into a set of pool iterators to avoid repeated lookups */
    setEntries GetIterSet(const std::set<uint256>& hashes) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    bool exists(const uint256& hash) const

identifier:CTransaction,GetConflictTx,COutPoint,prevout,EXCLUSIVE_LOCKS_REQUIRED,cs,boost::optional,txiter,GetIter,uint256,txid,EXCLUSIVE_LOCKS_REQUIRED,cs,setEntries,GetIterSet,uint256,hashes,EXCLUSIVE_LOCKS_REQUIRED,cs,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
static bool validNumStr(const std::string& s)
    std::string tokenVal;
bool UniValue::setNumStr(const std::string& val_)
    std::ostringstream oss;
    std::ostringstream oss;
    std::ostringstream oss;
bool UniValue::setStr(const std::string& val_)

identifier:validNumStr,s,tokenVal,UniValue::setNumStr,val_,oss,oss,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
enum jtokentype getJsonToken(std::string& tokenVal, unsigned int& consumed,
        std::string numStr;
        std::string valStr;
    std::vector<UniValue*> stack;
    std::string tokenVal;

identifier:jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
static std::string json_escape(const std::string& inS)
    std::string outS;
std::string UniValue::write(unsigned int prettyIndent,
                            unsigned int indentLevel) const
    std::string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, std::string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const

identifier:json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
std::string srcdir(JSON_TEST_SRC);
static void runtest(std::string filename, const std::string& jdata)
        std::string prefix = filename.substr(0, 4);
        std::string basename(filename_);
        std::string filename = srcdir + "/" + basename;
        std::string jdata;
                std::string s(buf, bread);

identifier:srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
static bool GetConfigOptions(std::istream& stream, std::string& error, std::vector<std::pair<std::string, std::string>> &options)
    int linenr = 1;
            } else if (*str.begin() == '-') {
                error = strprintf("parse error on line %i: %s, options in configuration file must be specified without leading -", linenr, str);
                return false;
            } else {
                error = strprintf("parse error on line %i: %s", linenr, str);
                if (str.size() >= 2 && str.substr(0, 2) == "no") {
                    error += strprintf(", if you intended to specify a negated option, use %s=1 instead", str);
                }
                return false;
        ++linenr;
    return true;
    std::vector<std::pair<std::string, std::string>> options;
    if (!GetConfigOptions(stream, error, options)) {
        return false;
    }
    for (const std::pair<std::string, std::string>& option : options) {
    WCHAR pszPath[MAX_PATH] = L"";
    if(SHGetSpecialFolderPathW(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathW() failed, could not obtain requested path.\n");

identifier:GetConfigOptions,stream,error,options,linenr,str,begin,error,strprintf,linenr,str,error,strprintf,linenr,str,str,size,str,substr,error,strprintf,str,linenr,options,GetConfigOptions,stream,error,options,option,options,WCHAR,pszPath,MAX_PATH,L,SHGetSpecialFolderPathW,nullptr,pszPath,nFolder,fCreate,LogPrintf,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (const char c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
Mutex g_best_block_mutex;
std::condition_variable g_best_block_cv;
            for (const int height : prevheights) {
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        const CTransaction* ptxConflicting = pool.GetConflictTx(txin.prevout);
        if (ptxConflicting) {
            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);
            for (const auto& mi : setIterConflicting) {
                    if (pool.exists(tx.vin[j].prevout.hash)) {
                    }
    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());
    unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))
        LOCK(g_best_block_mutex);
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);
    for (const BlockMap::value_type& entry : mapBlockIndex) {
    for (const std::pair<const uint256, CBlockIndex*>& entry : mapBlockIndex) {

identifier:Mutex,g_best_block_mutex,g_best_block_cv,height,prevheights,GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,CTransaction,ptxConflicting,pool,GetConflictTx,txin,prevout,ptxConflicting,CTxMemPool::setEntries,setIterConflicting,pool,GetIterSet,setConflicts,mi,setIterConflicting,pool,exists,tx,vin,j,prevout,hash,nSize,GetSerializeSize,block,fileout,GetVersion,nSize,GetSerializeSize,blockundo,fileout,GetVersion,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,CLIENT_VERSION,LOCK,g_best_block_mutex,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,CLIENT_VERSION,BlockMap::value_type,entry,mapBlockIndex,uint256,CBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
extern Mutex g_best_block_mutex;
extern std::condition_variable g_best_block_cv;

identifier:Mutex,g_best_block_mutex,g_best_block_cv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (const KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An unused temporary BerkeleyEnvironment object may be created inside the
            for (const auto& env : g_dbenvs) {

identifier:env,g_dbenvs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
    //! Was the wallet component compiled in.
    bool HasWalletSupport() const override {return true;}


identifier:HasWalletSupport,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (const unsigned char c : str) {
            if (!ExtractDestination(script, dest) && !internal) {
                throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set to true for nonstandard scriptPubKey imports.");
            }
                if (!(pubkey_dest == dest)) {
                if (!(pubkey_dest == dest)) {
                // add to address book or update label
                if (IsValidDestination(dest)) {
                    pwallet->SetAddressBook(dest, label, "receive");

identifier:c,str,ExtractDestination,script,dest,internal,throw,JSONRPCError,RPC_INVALID_PARAMETER,pubkey_dest,dest,pubkey_dest,dest,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    for (const COutPoint& outpt : vOutpts) {

identifier:COutPoint,outpt,vOutpts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
      }
      // test with many inputs
      for (CAmount amt=1500; amt < COIN; amt*=10) {
           empty_wallet();
           // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
           for (uint16_t j = 0; j < 676; j++)
               add_coin(amt);

           // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.
           for (int i = 0; i < RUN_TESTS; i++) {

           }
      }
      // test randomness
      {
          empty_wallet();
          for (int i2 = 0; i2 < 100; i2++)
              add_coin(COIN);
          // Again, we only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.
          for (int i = 0; i < RUN_TESTS; i++) {
          }
          // add 75 cents in small change.  not enough to make 90 cents,
          // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
          // one of which should be picked at random
          add_coin(5 * CENT);
          add_coin(10 * CENT);
          add_coin(15 * CENT);
          add_coin(20 * CENT);
          add_coin(25 * CENT);
          for (int i = 0; i < RUN_TESTS; i++) {
            int fails = 0;
          }
      }


identifier:CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,i,i,RUN_TESTS,i,empty_wallet,i2,i2,i2,add_coin,COIN,i,i,RUN_TESTS,i,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,i,i,RUN_TESTS,i,fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/wallet_tests.cpp
changed code snippet:
    std::map<CTxDestination, std::vector<COutput>> list;
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }

identifier:CTxDestination,COutput,list,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            encrypted_batch = nullptr;
            encrypted_batch = nullptr;
    for (const CTxIn& input : tx.vin) {
    for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
    AssertLockHeld(cs_main);
    AssertLockHeld(cs_wallet);
    for (const COutput& coin : availableCoins) {
    for (const COutPoint& output : lockedCoins) {
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);
        for (const int64_t nIndex : setInternalKeyPool) {
        for (const int64_t nIndex : setExternalKeyPool) {
        for (const int64_t nIndex : set_pre_split_keypool) {
            for (const CTxIn& txin : pcoin->tx->vin)
               for (const CTxOut& txout : pcoin->tx->vout)
        for (const CTxDestination& address : _grouping)
        for (const CTxDestination& element : *merged)
    for (const std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)

identifier:encrypted_batch,nullptr,encrypted_batch,nullptr,CTxIn,input,tx,vin,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,AssertLockHeld,cs_main,AssertLockHeld,cs_wallet,COutput,coin,availableCoins,COutPoint,output,lockedCoins,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,PROTOCOL_VERSION,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.h
changed code snippet:
    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_wallet);

identifier:CTxDestination,COutput,ListCoins,EXCLUSIVE_LOCKS_REQUIRED,cs_main,cs_wallet,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
    for (const uint256& hash : wss.vWalletUpgrade)
    for (const uint256& hash : vTxHash) {
    for (const uint256& hash : vTxHash) {

identifier:uint256,hash,wss,vWalletUpgrade,uint256,hash,vTxHash,uint256,hash,vTxHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:
    /** Is the wallet component enabled */
    virtual bool HasWalletSupport() const = 0;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:virtual,HasWalletSupport,WalletInitInterface,g_wallet_init_interface,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:4103cc31690e5be21854a9628f57c54b880ee195
commit B:d38bf9105d33147c899117a4c20ba7872733186f
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
    // ifdef can be removed once we switch to better endpoint support and API versioning
    RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
#endif
#ifdef ENABLE_WALLET
    UnregisterHTTPHandler("/wallet/", false);
#endif

identifier:ifdef,ENABLE_WALLET,RegisterHTTPHandler,HTTPReq_JSONRPC,endif,ifdef,ENABLE_WALLET,UnregisterHTTPHandler,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#if !(ENABLE_WALLET)
class DummyWalletInit : public WalletInitInterface {
public:

    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();
#endif


identifier:ENABLE_WALLET,class,DummyWalletInit,public,WalletInitInterface,public,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:
class WalletInitInterface;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:class,WalletInitInterface,WalletInitInterface,g_wallet_init_interface,
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
#else
#include <codecvt>
    wchar_t buf[256];
    if(FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, ARRAYSIZE(buf), nullptr))
        return strprintf("%s (%d)", std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>,wchar_t>().to_bytes(buf), err);

identifier:include,codecvt,wchar_t,buf,FormatMessageW,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,ARRAYSIZE,buf,nullptr,strprintf,wchar_t,wchar_t,to_bytes,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return MoveFileExW(src.wstring().c_str(), dest.wstring().c_str(),

identifier:MoveFileExW,src,wstring,c_str,dest,wstring,c_str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:d38bf9105d33147c899117a4c20ba7872733186f
commit B:362518791ade834d7f1f25b679ba236dcf5c3ad0
++@DIFF ENTRY SEPERATOR@++
changed file:src/netbase.cpp
changed code snippet:
    char buf[256];
    if(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK,
            buf, sizeof(buf), nullptr))
        return strprintf("%s (%d)", buf, err);

identifier:buf,FormatMessageA,FORMAT_MESSAGE_FROM_SYSTEM,FORMAT_MESSAGE_IGNORE_INSERTS,FORMAT_MESSAGE_MAX_WIDTH_MASK,buf,buf,nullptr,strprintf,buf,err,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    return MoveFileExA(src.string().c_str(), dest.string().c_str(),

identifier:MoveFileExA,src,c_str,dest,c_str,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:362518791ade834d7f1f25b679ba236dcf5c3ad0
commit B:0de0abc85b436031d257378fe136156e26707116
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/guiutil.cpp
changed code snippet:
#include <boost/scoped_array.hpp>

        IShellLink* psl = nullptr;
            CLSCTX_INPROC_SERVER, IID_IShellLink,
            TCHAR pszExePath[MAX_PATH];
            GetModuleFileName(nullptr, pszExePath, sizeof(pszExePath));
#ifdef UNICODE
            boost::scoped_array<TCHAR> args(new TCHAR[strArgs.length() + 1]);
            // Convert the QString to TCHAR*
            strArgs.toWCharArray(args.get());
            // Add missing '\0'-termination to string
            args[strArgs.length()] = '\0';
#endif

            PathRemoveFileSpec(pszExePath);
#ifndef UNICODE
            psl->SetArguments(strArgs.toStdString().c_str());
#else
            psl->SetArguments(args.get());
#endif
                WCHAR pwsz[MAX_PATH];
                // Ensure that the string is ANSI.
                MultiByteToWideChar(CP_ACP, 0, StartupShortcutPath().string().c_str(), -1, pwsz, MAX_PATH);
                hres = ppf->Save(pwsz, TRUE);

identifier:include,boost,scoped_array,hpp,IShellLink,psl,nullptr,CLSCTX_INPROC_SERVER,IID_IShellLink,TCHAR,pszExePath,MAX_PATH,GetModuleFileName,nullptr,pszExePath,pszExePath,ifdef,UNICODE,boost::scoped_array,TCHAR,args,new,TCHAR,strArgs,length,strArgs,toWCharArray,args,get,args,strArgs,length,endif,PathRemoveFileSpec,pszExePath,ifndef,UNICODE,psl,SetArguments,strArgs,toStdString,c_str,psl,SetArguments,args,get,endif,WCHAR,pwsz,MAX_PATH,MultiByteToWideChar,CP_ACP,StartupShortcutPath,c_str,pwsz,MAX_PATH,hres,ppf,Save,pwsz,TRUE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    char pszPath[MAX_PATH] = "";
    if(SHGetSpecialFolderPathA(nullptr, pszPath, nFolder, fCreate))
    LogPrintf("SHGetSpecialFolderPathA() failed, could not obtain requested path.\n");

identifier:pszPath,MAX_PATH,SHGetSpecialFolderPathA,nullptr,pszPath,nFolder,fCreate,LogPrintf,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e3fec3cfa894db6c0c4de8b43ae983383c8d7d7a
commit B:bcffd8743e7f9cf286e641a0df8df25241a9238c
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/coinselector_tests.cpp
changed code snippet:
        // test with many inputs
        for (CAmount amt=1500; amt < COIN; amt*=10) {
             empty_wallet();
             // Create 676 inputs (=  (old MAX_STANDARD_TX_SIZE == 100000)  / 148 bytes per input)
             for (uint16_t j = 0; j < 676; j++)
                 add_coin(amt);
        }
        // test randomness
        {
            empty_wallet();
            for (int i2 = 0; i2 < 100; i2++)
                add_coin(COIN);
            // add 75 cents in small change.  not enough to make 90 cents,
            // then try making 90 cents.  there are multiple competing "smallest bigger" coins,
            // one of which should be picked at random
            add_coin(5 * CENT);
            add_coin(10 * CENT);
            add_coin(15 * CENT);
            add_coin(20 * CENT);
            add_coin(25 * CENT);
            fails = 0;
        }
    }

identifier:CAmount,amt,amt,COIN,amt,empty_wallet,uint16_t,j,j,j,add_coin,amt,empty_wallet,i2,i2,i2,add_coin,COIN,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,add_coin,CENT,fails,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:bcffd8743e7f9cf286e641a0df8df25241a9238c
commit B:3783b139e9ec577472a1809fa372e4016f0cbec9
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);

identifier:size_t,nSize,GetSerializeSize,txout,SER_DISK,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION));
                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;

identifier:result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,utxo_size_inc,GetSerializeSize,out,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s, args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    const int nType;
    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}
    int GetType() const { return nType; }
size_t GetSerializeSize(const T& t, int nType, int nVersion = 0)
    return (CSizeComputer(nType, nVersion) << t).size();
template <typename S, typename T>
size_t GetSerializeSize(const S& s, const T& t)
    return (CSizeComputer(s.GetType(), s.GetVersion()) << t).size();
}

template <typename S, typename... T>
size_t GetSerializeSizeMany(const S& s, const T&... t)
{
    CSizeComputer sc(s.GetType(), s.GetVersion());

identifier:nType,CSizeComputer,nTypeIn,nVersionIn,nSize,nType,nTypeIn,nVersion,nVersionIn,GetType,nType,size_t,GetSerializeSize,T,t,nType,nVersion,CSizeComputer,nType,nVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSize,S,s,T,t,CSizeComputer,s,GetType,s,GetVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSizeMany,S,s,T,t,CSizeComputer,sc,s,GetType,s,GetVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0, 0);
        size += ::GetSerializeSize(VARINT(i), 0, 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, 0, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, 0, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
    unsigned int nSize = GetSerializeSize(fileout, block);
    unsigned int nSize = GetSerializeSize(fileout, blockundo);
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,nSize,GetSerializeSize,fileout,block,nSize,GetSerializeSize,fileout,blockundo,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,SER_DISK,CLIENT_VERSION,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);

identifier:coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,SER_DISK,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,SER_NETWORK,PROTOCOL_VERSION,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:3783b139e9ec577472a1809fa372e4016f0cbec9
commit B:7ab2837b65217e6bf010512c4ea44b09cad69bad
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:7ab2837b65217e6bf010512c4ea44b09cad69bad
commit B:893628be0166b4096b6e52f516e0f65bb63a75a2
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (auto v_i : v) {
    for (auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", _("Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,_,OptionsCategory::OPTIONS,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockfilter.cpp
changed code snippet:
            if (script[0] == OP_RETURN) continue;

identifier:script,OP_RETURN,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <consensus/merkle.h>
#include <chainparamsseeds.h>

/**
 * What makes a good checkpoint block?
 * + Is surrounded by blocks with reasonable timestamps
 *   (no blocks before with a timestamp after, none after with
 *    timestamp before)
 * + Contains no strange transactions
 */


identifier:include,consensus,merkle,h,include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx	transaction for which we are checking input total
     * @return	Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,PROTOCOL_VERSION,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,PROTOCOL_VERSION,GetSerializeSize,txin,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (uint32_t loc : locs)
            for (uint32_t loc : locs) {
        for (uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmaped).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
FILE *freopen(const fs::path& p, const char *mode, FILE *stream)
{
    return ::freopen(p.string().c_str(), mode, stream);
}


identifier:FILE,freopen,fs::path,p,mode,FILE,stream,freopen,p,c_str,mode,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:
    FILE *freopen(const fs::path& p, const char *mode, FILE *stream);

identifier:FILE,freopen,fs::path,p,mode,FILE,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    std::mutex cs;
        std::unique_lock<std::mutex> lock(cs);
                std::unique_lock<std::mutex> lock(cs);
        std::unique_lock<std::mutex> lock(cs);

identifier:cs,lock,cs,lock,cs,lock,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (0 to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u or testnet: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", strprintf("Output debugging information (default: %u, supplying <category> is optional)", 0) + ". " +
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set debuglogfile=0)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);
static CWaitableCriticalSection cs_GenesisWait;
static CConditionVariable condvar_GenesisWait;
            WaitableLock lock_GenesisWait(cs_GenesisWait);
        condvar_GenesisWait.notify_all();
    LogPrintf("Using config file %s\n", GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME)).string());
        WaitableLock lock(cs_GenesisWait);
            condvar_GenesisWait.wait_for(lock, std::chrono::milliseconds(500));

identifier:gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::RPC,CWaitableCriticalSection,cs_GenesisWait,CConditionVariable,condvar_GenesisWait,WaitableLock,lock_GenesisWait,cs_GenesisWait,condvar_GenesisWait,notify_all,LogPrintf,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,WaitableLock,lock,cs_GenesisWait,condvar_GenesisWait,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.cpp
changed code snippet:
        std::string from_account,
        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), std::move(from_account), m_key, g_connman.get(), state)) {

identifier:from_account,m_wallet,CommitTransaction,m_tx,value_map,order_form,from_account,m_key,g_connman,get,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:
        std::string from_account,

identifier:from_account,
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.cpp
changed code snippet:
                m_fileout = fsbridge::freopen(m_file_path, "a", m_fileout);
                if (!m_fileout) {
                    return;
                setbuf(m_fileout, nullptr); // unbuffered


identifier:m_fileout,fsbridge::freopen,m_file_path,m_fileout,m_fileout,setbuf,m_fileout,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(nPrevNodeCount);
        for (auto pnode : vNodes) {
        for (CNode* pnode : vNodes) {
            for (CNode* pnode : vNodes) {
        std::unique_lock<std::mutex> lock(mutexMsgProc);
#else
        std::unique_lock<std::mutex> lock(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,nPrevNodeCount,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,lock,mutexMsgProc,lock,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    std::mutex mutexMsgProc;

identifier:mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
static CCriticalSection g_cs_orphans;
        for (uint256 &orphanHash : vOrphanErase) {
            for (uint256 hash : vEraseQueue)

identifier:CCriticalSection,g_cs_orphans,uint256,orphanHash,vOrphanErase,uint256,hash,vEraseQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.cpp
changed code snippet:
static bool noui_ThreadSafeMessageBox(const std::string& message, const std::string& caption, unsigned int style)
static bool noui_ThreadSafeQuestion(const std::string& /* ignored interactive message */, const std::string& message, const std::string& caption, unsigned int style)
static void noui_InitMessage(const std::string& message)
    // Connect bitcoind signal handlers

identifier:noui_ThreadSafeMessageBox,message,caption,style,noui_ThreadSafeQuestion,message,caption,style,noui_InitMessage,message,
++@DIFF ENTRY SEPERATOR@++
changed file:src/noui.h
changed code snippet:
extern void noui_connect();

identifier:noui_connect,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
/** \class CBlockPolicyEstimator
 * The BlockPolicyEstimator is used for estimating the feerate needed
 * for a transaction to be included in a block within a certain number of
 * blocks.
 *
 * At a high level the algorithm works by grouping transactions into buckets
 * based on having similar feerates and then tracking how long it
 * takes transactions in the various buckets to be mined.  It operates under
 * the assumption that in general transactions of higher feerate will be
 * included in blocks before transactions of lower feerate.   So for
 * example if you wanted to know what feerate you should put on a transaction to
 * be included in a block within the next 5 blocks, you would start by looking
 * at the bucket with the highest feerate transactions and verifying that a
 * sufficiently high percentage of them were confirmed within 5 blocks and
 * then you would look at the next highest feerate bucket, and so on, stopping at
 * the last bucket to pass the test.   The average feerate of transactions in this
 * bucket will give you an indication of the lowest feerate you can put on a
 * transaction and still have a sufficiently high chance of being confirmed
 * within your desired 5 blocks.
 *
 * Here is a brief description of the implementation:
 * When a transaction enters the mempool, we track the height of the block chain
 * at entry.  All further calculations are conducted only on this set of "seen"
 * transactions. Whenever a block comes in, we count the number of transactions
 * in each bucket and the total amount of feerate paid in each bucket. Then we
 * calculate how many blocks Y it took each transaction to be mined.  We convert
 * from a number of blocks to a number of periods Y' each encompassing "scale"
 * blocks.  This is tracked in 3 different data sets each up to a maximum
 * number of periods. Within each data set we have an array of counters in each
 * feerate bucket and we increment all the counters from Y' up to max periods
 * representing that a tx was successfully confirmed in less than or equal to
 * that many periods. We want to save a history of this information, so at any
 * time we have a counter of the total number of transactions that happened in a
 * given feerate bucket and the total number that were confirmed in each of the
 * periods or less for any bucket.  We save this history by keeping an
 * exponentially decaying moving average of each one of these stats.  This is
 * done for a different decay in each of the 3 data sets to keep relevant data
 * from different time horizons.  Furthermore we also keep track of the number
 * unmined (in mempool or left mempool without being included in a block)
 * transactions in each bucket and for how many blocks they have been
 * outstanding and use both of these numbers to increase the number of transactions
 * we've seen in that feerate bucket when calculating an estimate for any number
 * of confirmations below the number of blocks they've been outstanding.
 */

/**

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout);

identifier:size_t,nSize,GetSerializeSize,txout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
static void InitMessage(const std::string &message)
    LogPrintf("init message: %s\n", message);
    for (WalletModel *walletModel : m_wallet_models) {

identifier:InitMessage,message,LogPrintf,message,WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:ThreadSafeMessageBox,BitcoinGUI,gui,message,caption,style,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.h
changed code snippet:
     @param[in] status            current hd enabled status

identifier:param,in,status,current,hd,enabled,status,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
 * @param[out]   result      stringified Result from the executed command(chain)

identifier:param,out,result,stringified,Result,from,the,executed,command,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of miliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,miliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (float f : vSamplesIn) {
    for (float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/walletmodel.cpp
changed code snippet:
        if (!newTx->commit({} /* mapValue */, std::move(vOrderForm), {} /* fromAccount */, rejectReason))

identifier:newTx,commit,vOrderForm,rejectReason,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
static std::mutex cs_rng_state;
        std::unique_lock<std::mutex> lock(cs_rng_state);
        std::unique_lock<std::mutex> lock(cs_rng_state);

identifier:cs_rng_state,lock,cs_rng_state,lock,cs_rng_state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure& e) {

identifier:e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static std::mutex cs_blockchange;
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, PROTOCOL_VERSION));
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
    for (const CTxMemPool::txiter &childiter : setChildren) {
                utxo_size_inc += GetSerializeSize(out, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
            "For more information on output descriptors, see the documentation at TODO\n"

identifier:cs_blockchange,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,PROTOCOL_VERSION,lock,cs_blockchange,lock,cs_blockchange,lock,cs_blockchange,CTxMemPool::txiter,childiter,setChildren,utxo_size_inc,GetSerializeSize,out,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index, or the chain tip if
 * not provided.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,or,the,chain,tip,not,provided,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WaitableLock lock(g_best_block_mutex);
    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WaitableLock,lock,g_best_block_mutex,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#include <wallet/wallet.h>
#include <wallet/walletdb.h>
#endif
#ifdef ENABLE_WALLET
        if (HasWallets() && IsDeprecatedRPCEnabled("validateaddress")) {
            ret.pushKVs(getaddressinfo(request));
        }
#endif
        if (ret["address"].isNull()) {
            std::string currentAddress = EncodeDestination(dest);
            ret.pushKV("address", currentAddress);
            CScript scriptPubKey = GetScriptForDestination(dest);
            ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));

            UniValue detail = DescribeAddress(dest);
            ret.pushKVs(detail);
        }
class CWallet;

            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\nNote that from v0.16, createmultisig no longer accepts addresses."
            " Users must use addmultisigaddress to create multisig addresses with addresses known to the wallet.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,include,wallet,wallet,h,include,wallet,walletdb,h,endif,ifdef,ENABLE_WALLET,HasWallets,IsDeprecatedRPCEnabled,ret,pushKVs,getaddressinfo,request,endif,ret,isNull,currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,class,CWallet,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#endif
            // if redeemScript given and not using the local wallet (private keys
            // given), add redeemScript to the keystore so it can be signed:
#ifdef ENABLE_WALLET
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();
#endif

    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)
        throw std::runtime_error(
            "signrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n"
            "\nDEPRECATED. Sign inputs for raw transaction (serialized, hex-encoded).\n"
            "The second optional argument (may be null) is an array of previous transaction outputs that\n"
            "this transaction depends on but may not yet be in the block chain.\n"
            "The third optional argument (may be null) is an array of base58-encoded private\n"
            "keys that, if given, will be the only keys used to sign the transaction.\n"
#ifdef ENABLE_WALLET
            + HelpRequiringPassphrase(pwallet) + "\n"
#endif
            "\nArguments:\n"
            "1. \"hexstring\"     (string, required) The transaction hex string\n"
            "2. \"prevtxs\"       (string, optional) An json array of previous dependent transaction outputs\n"
            "     [               (json array of json objects, or 'null' if none provided)\n"
            "       {\n"
            "         \"txid\":\"id\",             (string, required) The transaction id\n"
            "         \"vout\":n,                  (numeric, required) The output number\n"
            "         \"scriptPubKey\": \"hex\",   (string, required) script key\n"
            "         \"redeemScript\": \"hex\",   (string, required for P2SH or P2WSH) redeem script\n"
            "         \"amount\": value            (numeric, required) The amount spent\n"
            "       }\n"
            "       ,...\n"
            "    ]\n"
            "3. \"privkeys\"     (string, optional) A json array of base58-encoded private keys for signing\n"
            "    [                  (json array of strings, or 'null' if none provided)\n"
            "      \"privatekey\"   (string) private key in base58-encoding\n"
            "      ,...\n"
            "    ]\n"
            "4. \"sighashtype\"     (string, optional, default=ALL) The signature hash type. Must be one of\n"
            "       \"ALL\"\n"
            "       \"NONE\"\n"
            "       \"SINGLE\"\n"
            "       \"ALL|ANYONECANPAY\"\n"
            "       \"NONE|ANYONECANPAY\"\n"
            "       \"SINGLE|ANYONECANPAY\"\n"

            "\nResult:\n"
            "{\n"
            "  \"hex\" : \"value\",           (string) The hex-encoded raw transaction with signature(s)\n"
            "  \"complete\" : true|false,   (boolean) If the transaction has a complete set of signatures\n"
            "  \"errors\" : [                 (json array of objects) Script verification errors (if there are any)\n"
            "    {\n"
            "      \"txid\" : \"hash\",           (string) The hash of the referenced, previous transaction\n"
            "      \"vout\" : n,                (numeric) The index of the output to spent and used as input\n"
            "      \"scriptSig\" : \"hex\",       (string) The hex-encoded signature script\n"
            "      \"sequence\" : n,            (numeric) Script sequence number\n"
            "      \"error\" : \"text\"           (string) Verification or signing error related to the input\n"
            "    }\n"
            "    ,...\n"
            "  ]\n"
            "}\n"

            "\nExamples:\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"")
            + HelpExampleRpc("signrawtransaction", "\"myhex\"")
        );

    if (!IsDeprecatedRPCEnabled("signrawtransaction")) {
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction is deprecated and will be fully removed in v0.18. "
            "To use signrawtransaction in v0.17, restart bitcoind with -deprecatedrpc=signrawtransaction.\n"
            "Projects should transition to using signrawtransactionwithkey and signrawtransactionwithwallet before upgrading to v0.18");
    }

    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);

    // Make a JSONRPCRequest to pass on to the right signrawtransaction* command
    JSONRPCRequest new_request;
    new_request.id = request.id;
    new_request.params.setArray();

    // For signing with private keys
    if (!request.params[2].isNull()) {
        new_request.params.push_back(request.params[0]);
        // Note: the prevtxs and privkeys are reversed for signrawtransactionwithkey
        new_request.params.push_back(request.params[2]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithkey(new_request);
    } else {
#ifdef ENABLE_WALLET
        // Otherwise sign with the wallet which does not take a privkeys parameter
        new_request.params.push_back(request.params[0]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithwallet(new_request);
#else
        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.
        throw JSONRPCError(RPC_INVALID_PARAMETER, "No private keys available.");
#endif
    }
            "\nAlso see createrawtransaction and signrawtransaction calls.\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
                            "                              will be tried. If false, only non-witness deserialization wil be tried. Only has an effect if\n"
    { "rawtransactions",    "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,endif,ifdef,ENABLE_WALLET,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,endif,request,fHelp,request,params,size,request,params,size,throw,ifdef,ENABLE_WALLET,HelpRequiringPassphrase,pwallet,endif,HelpExampleCli,HelpExampleRpc,IsDeprecatedRPCEnabled,throw,JSONRPCError,RPC_METHOD_DEPRECATED,RPCTypeCheck,request,params,UniValue::VSTR,UniValue::VARR,UniValue::VARR,UniValue::VSTR,JSONRPCRequest,new_request,new_request,id,request,id,new_request,params,setArray,request,params,isNull,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithkey,new_request,ifdef,ENABLE_WALLET,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithwallet,new_request,throw,JSONRPCError,RPC_INVALID_PARAMETER,endif,HelpExampleCli,HelpExampleCli,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practially, this means that callbacks can behave as if they are executed

identifier:Practially,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */
/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s.GetVersion(), args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,GetVersion,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    explicit CSizeComputer(int nVersionIn) : nSize(0), nVersion(nVersionIn) {}
size_t GetSerializeSize(const T& t, int nVersion = 0)
    return (CSizeComputer(nVersion) << t).size();
template <typename... T>
size_t GetSerializeSizeMany(int nVersion, const T&... t)
    CSizeComputer sc(nVersion);

identifier:explicit,CSizeComputer,nVersionIn,nSize,nVersion,nVersionIn,size_t,GetSerializeSize,T,t,nVersion,CSizeComputer,nVersion,t,size,template,typename,T,size_t,GetSerializeSizeMany,nVersion,T,t,CSizeComputer,sc,nVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
     * in the nbits least signficant bits of a 64-bit uint.

identifier:in,the,nbits,least,signficant,bits,of,a,bit,uint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto alloced = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(alloced->first);

identifier:alloced,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,alloced,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    assert(false);

identifier:assert,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
 * Template mixin that adds -Wthread-safety locking
 * annotations to a subset of the mutex API.
};
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)
class CCriticalSection : public AnnotatedMixin<std::recursive_mutex>
{
public:
    ~CCriticalSection() {
        DeleteLock((void*)this);
    }
};
typedef AnnotatedMixin<std::mutex> CWaitableCriticalSection;

/** Just a typedef for std::condition_variable, can be wrapped later if desired */
typedef std::condition_variable CConditionVariable;

/** Just a typedef for std::unique_lock, can be wrapped later if desired */
typedef std::unique_lock<std::mutex> WaitableLock;
/** Wrapper around std::unique_lock<CCriticalSection> */
class SCOPED_LOCKABLE CCriticalBlock
    std::unique_lock<CCriticalSection> lock;

        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));
        if (!lock.try_lock()) {
            lock.lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);
        lock.try_lock();
        if (!lock.owns_lock())
        return lock.owns_lock();
    CCriticalBlock(CCriticalSection& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : lock(mutexIn, std::defer_lock)
    CCriticalBlock(CCriticalSection* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        lock = std::unique_lock<CCriticalSection>(*pmutexIn, std::defer_lock);
    ~CCriticalBlock() UNLOCK_FUNCTION()
        if (lock.owns_lock())
        return lock.owns_lock();
#define LOCK(cs) CCriticalBlock PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__), criticalblock2(cs2, #cs2, __FILE__, __LINE__)
#define TRY_LOCK(cs, name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)

identifier:Template,mixin,that,adds,Wthread,safety,locking,annotations,to,a,subset,of,the,mutex,API,ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,class,CCriticalSection,public,AnnotatedMixin,public,CCriticalSection,DeleteLock,this,AnnotatedMixin,CWaitableCriticalSection,CConditionVariable,WaitableLock,class,SCOPED_LOCKABLE,CCriticalBlock,CCriticalSection,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,owns_lock,lock,owns_lock,CCriticalBlock,CCriticalSection,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,lock,mutexIn,CCriticalBlock,CCriticalSection,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,lock,CCriticalSection,pmutexIn,CCriticalBlock,UNLOCK_FUNCTION,lock,owns_lock,lock,owns_lock,define,LOCK,cs,CCriticalBlock,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,CCriticalBlock,criticalblock1,cs1,cs1,__FILE__,__LINE__,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,CCriticalBlock,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
    CScript included_scripts[5], excluded_scripts[2];
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(400, included_scripts[3]), 1000, true);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(500, included_scripts[4]), 10000, false);

identifier:CScript,included_scripts,excluded_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (auto i : range) {
        for (bool end_fails : {true, false}) {

identifier:i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure& e) {
    } catch (const std::ios_base::failure& e) {
    } catch (std::logic_error& e) {
    for (CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error& e) {
    for (CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:e,e,e,CAmount,base_value,ABSENT,PRUNED,VALUE1,e,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (uint256& h : hashes_insert_copy)
    for (uint256& h : hashes)
            for (auto h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure& e) {
    for (int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,e,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/denialofservice_tests.cpp
changed code snippet:
extern std::map<uint256, COrphanTx> mapOrphanTransactions;
    LOCK(cs_main);
    LOCK(cs_main);

identifier:uint256,COrphanTx,mapOrphanTransactions,LOCK,cs_main,LOCK,cs_main,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (auto chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception& e) {
    } catch (const std::exception& e) {

identifier:e,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/scheduler_tests.cpp
changed code snippet:
            assert(i == counter1++);
            assert(i == counter2++);

identifier:assert,i,counter1,assert,i,counter2,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0);
        size += ::GetSerializeSize(VARINT(i), 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (std::string word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (char opt : "abcdef")
    for (bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
        std::unique_lock<std::mutex> lock(mut);
    std::unique_lock<std::mutex> lock(mut);

identifier:lock,mut,lock,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
    std::mutex mut;

identifier:mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (int64_t nOffset : vSorted)
            for (int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            txiter piter = mapTx.find(tx.vin[i].prevout.hash);
            if (piter != mapTx.end()) {
                parentHashes.insert(piter);
        for (const txiter &phash : setMemPoolParents) {
    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(entry.GetTx().GetHash());
    if (pos != mapDeltas.end()) {
        const CAmount &delta = pos->second;
        if (delta) {
        }
    for (const uint256 &phash : setParentTransactions) {
        txiter pit = mapTx.find(phash);
        if (pit != mapTx.end()) {
        }
        for (const txiter &childiter : setChildren) {
    for (const txiter& it : stage) {

identifier:txiter,piter,mapTx,find,tx,vin,i,prevout,hash,piter,mapTx,end,parentHashes,insert,piter,txiter,phash,setMemPoolParents,uint256,CAmount,const_iterator,pos,mapDeltas,find,entry,GetTx,GetHash,pos,mapDeltas,end,CAmount,delta,pos,second,delta,uint256,phash,setParentTransactions,txiter,pit,mapTx,find,phash,pit,mapTx,end,txiter,childiter,setChildren,txiter,it,stage,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
public:
    bool exists(uint256 hash) const

identifier:public,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:
using namespace std;


identifier:using,namespace,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:
#include <utility>        // std::pair
    bool push_back(std::pair<std::string,UniValue> pear) {
        return pushKV(pear.first, pear.second);
    }
static inline std::pair<std::string,UniValue> Pair(const char *cKey, const char *cVal)
{
    std::string key(cKey);
    UniValue uVal(cVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, std::string strVal)
{
    std::string key(cKey);
    UniValue uVal(strVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, uint64_t u64Val)
{
    std::string key(cKey);
    UniValue uVal(u64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int64_t i64Val)
{
    std::string key(cKey);
    UniValue uVal(i64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, bool iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, double dVal)
{
    std::string key(cKey);
    UniValue uVal(dVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, const UniValue& uVal)
{
    std::string key(cKey);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(std::string key, const UniValue& uVal)
{
    return std::make_pair(key, uVal);
}


identifier:include,utility,push_back,UniValue,pear,pushKV,pear,first,pear,second,inline,UniValue,Pair,cKey,cVal,key,cKey,UniValue,uVal,cVal,key,uVal,inline,UniValue,Pair,cKey,strVal,key,cKey,UniValue,uVal,strVal,key,uVal,inline,UniValue,Pair,cKey,uint64_t,u64Val,key,cKey,UniValue,uVal,u64Val,key,uVal,inline,UniValue,Pair,cKey,int64_t,i64Val,key,cKey,UniValue,uVal,i64Val,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,dVal,key,cKey,UniValue,uVal,dVal,key,uVal,inline,UniValue,Pair,cKey,UniValue,uVal,key,cKey,key,uVal,inline,UniValue,Pair,key,UniValue,uVal,key,uVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
using namespace std;

static bool validNumStr(const string& s)
    string tokenVal;
bool UniValue::setNumStr(const string& val_)
    ostringstream oss;
    ostringstream oss;
    ostringstream oss;
bool UniValue::setStr(const string& val_)

identifier:using,namespace,validNumStr,s,tokenVal,UniValue::setNumStr,val_,ostringstream,oss,ostringstream,oss,ostringstream,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
using namespace std;

enum jtokentype getJsonToken(string& tokenVal, unsigned int& consumed,
        string numStr;
        string valStr;
    vector<UniValue*> stack;
    string tokenVal;

identifier:using,namespace,jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
using namespace std;

static string json_escape(const string& inS)
    string outS;
string UniValue::write(unsigned int prettyIndent,
                       unsigned int indentLevel) const
    string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, string& s) const

identifier:using,namespace,json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
using namespace std;
string srcdir(JSON_TEST_SRC);
static void runtest(string filename, const string& jdata)
        string prefix = filename.substr(0, 4);
        string basename(filename_);
        string filename = srcdir + "/" + basename;
        string jdata;
                string s(buf, bread);

identifier:using,namespace,srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    static inline bool UseDefaultSection(const ArgsManager& am, const std::string& arg)
    static inline bool GetNetBoolArg(const ArgsManager &am, const std::string& net_arg)
static std::vector<std::pair<std::string, std::string>> GetConfigOptions(std::istream& stream)
    std::vector<std::pair<std::string, std::string>> options;
    return options;

    for (const std::pair<std::string, std::string>& option : GetConfigOptions(stream)) {
        if (m_override_args.count("-includeconf") == 0) {

identifier:inline,UseDefaultSection,ArgsManager,am,arg,inline,GetNetBoolArg,ArgsManager,am,net_arg,GetConfigOptions,stream,options,options,option,GetConfigOptions,stream,m_override_args,count,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
    std::map<std::string, std::vector<std::string>> m_override_args;
    std::map<std::string, std::vector<std::string>> m_config_args;
    std::string m_network;
    std::set<std::string> m_network_only_args;
    std::map<OptionsCategory, std::map<std::string, Arg>> m_available_args;
    void ClearArgs() { m_available_args.clear(); }

identifier:m_override_args,m_config_args,m_network,m_network_only_args,OptionsCategory,Arg,m_available_args,ClearArgs,m_available_args,clear,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (auto c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
CWaitableCriticalSection g_best_block_mutex;
CConditionVariable g_best_block_cv;
            for (int height : prevheights) {
    if (::GetSerializeSize(tx, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        auto itConflicting = pool.mapNextTx.find(txin.prevout);
        if (itConflicting != pool.mapNextTx.end())
        {
            const CTransaction *ptxConflicting = itConflicting->second;
            CTxMemPool::setEntries setIterConflicting;
            for (const uint256 &hashConflicting : setConflicts)
            {
                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);
                if (mi == pool.mapTx.end())
                    continue;

                // Save these to avoid repeated lookups
                setIterConflicting.insert(mi);

                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())
    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());
    unsigned int nSize = GetSerializeSize(blockundo, fileout.GetVersion());
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, CLIENT_VERSION) + 40))
        WaitableLock lock(g_best_block_mutex);
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);
    for (BlockMap::value_type& entry : mapBlockIndex) {
    for (auto& entry : mapBlockIndex) {

identifier:CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,height,prevheights,GetSerializeSize,tx,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,itConflicting,pool,mapNextTx,find,txin,prevout,itConflicting,pool,mapNextTx,end,CTransaction,ptxConflicting,itConflicting,second,CTxMemPool::setEntries,setIterConflicting,uint256,hashConflicting,setConflicts,CTxMemPool::txiter,mi,pool,mapTx,find,hashConflicting,mi,pool,mapTx,end,setIterConflicting,insert,mi,pool,mapTx,find,tx,vin,j,prevout,hash,pool,mapTx,end,nSize,GetSerializeSize,block,fileout,GetVersion,nSize,GetSerializeSize,blockundo,fileout,GetVersion,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,CLIENT_VERSION,WaitableLock,lock,g_best_block_mutex,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,CLIENT_VERSION,BlockMap::value_type,entry,mapBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
extern CWaitableCriticalSection g_best_block_mutex;
extern CConditionVariable g_best_block_cv;

identifier:CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An ununsed temporary BerkeleyEnvironment object may be created inside the
            for (auto& env : g_dbenvs) {

identifier:env,g_dbenvs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/feebumper.cpp
changed code snippet:
    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, oldWtx.strFromAccount, reservekey, g_connman.get(), state)) {

identifier:wallet,CommitTransaction,tx,mapValue,oldWtx,vOrderForm,oldWtx,strFromAccount,reservekey,g_connman,get,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
                               " (1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)", false, OptionsCategory::WALLET);

identifier:OptionsCategory::WALLET,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (unsigned char c : str) {
        // Not having Internal + Script
        if (!internal && isScript) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set for hex scriptPubKey");
        }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (scriptPubKey.getType() == UniValue::VOBJ) {
                    // add to address book or update label
                    if (IsValidDestination(dest)) {
                        pwallet->SetAddressBook(dest, label, "receive");
                    }

identifier:c,str,internal,isScript,throw,JSONRPCError,RPC_INVALID_PARAMETER,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,scriptPubKey,getType,UniValue::VOBJ,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
CTxDestination GetLabelDestination(CWallet* const pwallet, const std::string& label, bool bForceNew=false)
{
    CTxDestination dest;
    if (!pwallet->GetLabelDestination(dest, label, bForceNew)) {
        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, "Error: Keypool ran out, please call keypoolrefill first");
    }

    return dest;
}

    std::string old_label = pwallet->mapAddressBook[dest].name;
    // Detect when there are no addresses using this label.
    // If so, delete the account record for it. Labels, unlike addresses, can be deleted,
    // and if we wouldn't do this, the record would stick around forever.
    bool found_address = false;
    for (const std::pair<const CTxDestination, CAddressBookData>& item : pwallet->mapAddressBook) {
        if (item.second.name == label) {
            found_address = true;
            break;
        }
    }
    if (!found_address) {
        pwallet->DeleteLabel(old_label);
    }

    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, "" /* account */, reservekey, g_connman.get(), state)) {
    if (totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth, nullptr)) {
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, "" /* account */, keyChange, g_connman.get(), state)) {
    std::string dummy_account;
    wtx.GetAmounts(listReceived, listSent, nFee, dummy_account, filter);
            CWalletTx *const pwtx = (*it).second.first;
            if (pwtx != nullptr) {
                ListTransactions(pwallet, *pwtx, 0, true, ret, filter);
            }
    for (COutPoint &outpt : vOutpts) {

identifier:CTxDestination,GetLabelDestination,CWallet,pwallet,label,bForceNew,CTxDestination,dest,pwallet,GetLabelDestination,dest,label,bForceNew,throw,JSONRPCError,RPC_WALLET_KEYPOOL_RAN_OUT,dest,old_label,pwallet,mapAddressBook,dest,name,found_address,CTxDestination,CAddressBookData,item,pwallet,mapAddressBook,item,second,name,label,found_address,found_address,pwallet,DeleteLabel,old_label,pwallet,CommitTransaction,tx,mapValue,reservekey,g_connman,get,state,totalAmount,pwallet,GetLegacyBalance,ISMINE_SPENDABLE,nMinDepth,nullptr,pwallet,CommitTransaction,tx,mapValue,keyChange,g_connman,get,state,dummy_account,wtx,GetAmounts,listReceived,listSent,nFee,dummy_account,filter,CWalletTx,pwtx,it,second,first,pwtx,nullptr,ListTransactions,pwallet,pwtx,ret,filter,COutPoint,outpt,vOutpts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/wallet_tests.cpp
changed code snippet:
        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, {}, reservekey, nullptr, state));
    auto list = wallet->ListCoins();
    list = wallet->ListCoins();
    list = wallet->ListCoins();

identifier:BOOST_CHECK,wallet,CommitTransaction,tx,reservekey,nullptr,state,list,wallet,ListCoins,list,wallet,ListCoins,list,wallet,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        copyTo->strFromAccount = copyFrom->strFromAccount;
    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.
    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;
    typedef std::multimap<int64_t, TxPair > TxItems;
        txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, nullptr)));
    }
    std::list<CAccountingEntry> acentries;
    batch.ListAccountCreditDebit("", acentries);
    for (CAccountingEntry& entry : acentries)
    {
        txByTime.insert(std::make_pair(entry.nTime, TxPair(nullptr, &entry)));
        CWalletTx *const pwtx = (*it).second.first;
        CAccountingEntry *const pacentry = (*it).second.second;
        int64_t& nOrderPos = (pwtx != nullptr) ? pwtx->nOrderPos : pacentry->nOrderPos;
            if (pwtx)
            {
                if (!batch.WriteTx(*pwtx))
                    return DBErrors::LOAD_FAIL;
            }
            else
                if (!batch.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))
                    return DBErrors::LOAD_FAIL;
            if (pwtx)
            {
                if (!batch.WriteTx(*pwtx))
                    return DBErrors::LOAD_FAIL;
            }
            else
                if (!batch.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))
                    return DBErrors::LOAD_FAIL;
bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment)
{
    WalletBatch batch(*database);
    if (!batch.TxnBegin())
        return false;

    int64_t nNow = GetAdjustedTime();

    // Debit
    CAccountingEntry debit;
    debit.nOrderPos = IncOrderPosNext(&batch);
    debit.strAccount = strFrom;
    debit.nCreditDebit = -nAmount;
    debit.nTime = nNow;
    debit.strOtherAccount = strTo;
    debit.strComment = strComment;
    AddAccountingEntry(debit, &batch);

    // Credit
    CAccountingEntry credit;
    credit.nOrderPos = IncOrderPosNext(&batch);
    credit.strAccount = strTo;
    credit.nCreditDebit = nAmount;
    credit.nTime = nNow;
    credit.strOtherAccount = strFrom;
    credit.strComment = strComment;
    AddAccountingEntry(credit, &batch);

    if (!batch.TxnCommit())
        return false;

    return true;
}

bool CWallet::GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew)
{
    WalletBatch batch(*database);

    CAccount account;
    batch.ReadAccount(label, account);

    if (!bForceNew) {
        if (!account.vchPubKey.IsValid())
            bForceNew = true;
        else {
            // Check if the current key has been used (TODO: check other addresses with the same key)
            CScript scriptPubKey = GetScriptForDestination(GetDestinationForKey(account.vchPubKey, m_default_address_type));
            for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();
                 it != mapWallet.end() && account.vchPubKey.IsValid();
                 ++it)
                for (const CTxOut& txout : (*it).second.tx->vout)
                    if (txout.scriptPubKey == scriptPubKey) {
                        bForceNew = true;
                        break;
                    }
        }
    }

    // Generate a new key
    if (bForceNew) {
        if (!GetKeyFromPool(account.vchPubKey, false))
            return false;

        LearnRelatedScripts(account.vchPubKey, m_default_address_type);
        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);
        SetAddressBook(dest, label, "receive");
        batch.WriteAccount(label, account);
    } else {
        dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);
    }

    return true;
}

        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));
        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));
    for (auto& input : tx.vin) {
                           std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const
    strSentAccount = strFromAccount;
    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const
            } else if (IsMine(out) & filter && depth >= minDepth && (!account || *account == GetLabelName(out.scriptPubKey))) {
        if (outgoing && (!account || *account == wtx.strFromAccount)) {
    if (account) {
        balance += WalletBatch(*database).GetAccountCreditDebit(*account);
    }

    // TODO: Add AssertLockHeld(cs_wallet) here.
    //
    // Because the return value from this function contains pointers to
    // CWalletTx objects, callers to this function really should acquire the
    // cs_wallet lock before calling it. However, the current caller doesn't
    // acquire this lock yet. There was an attempt to add the missing lock in
    // https://github.com/bitcoin/bitcoin/pull/10340, but that change has been
    // postponed until after https://github.com/bitcoin/bitcoin/pull/10244 to
    // avoid adding some extra complexity to the Qt code.
    LOCK2(cs_main, cs_wallet);
    for (auto& coin : availableCoins) {
    for (const auto& output : lockedCoins) {
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);
bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state)
        wtxNew.strFromAccount = std::move(fromAccount);
void CWallet::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries) {
    WalletBatch batch(*database);
    return batch.ListAccountCreditDebit(strAccount, entries);
}

bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)
{
    WalletBatch batch(*database);

    return AddAccountingEntry(acentry, &batch);
}

bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, WalletBatch *batch)
{
    if (!batch->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {
        return false;
    }

    laccentries.push_back(acentry);
    CAccountingEntry & entry = laccentries.back();
    wtxOrdered.insert(std::make_pair(entry.nOrderPos, TxPair(nullptr, &entry)));

    return true;
}

        for (int64_t nIndex : setInternalKeyPool) {
        for (int64_t nIndex : setExternalKeyPool) {
        for (int64_t nIndex : set_pre_split_keypool) {
            for (CTxIn txin : pcoin->tx->vin)
               for (CTxOut txout : pcoin->tx->vout)
        for (CTxDestination address : _grouping)
        for (CTxDestination element : *merged)
    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)
void CWallet::DeleteLabel(const std::string& label)
{
    WalletBatch batch(*database);
    batch.EraseAccount(label);
}

                CWalletTx* const pwtx = it->second.first;
                CAccountingEntry* const pacentry = it->second.second;
                if (pwtx) {
                    nSmartTime = pwtx->nTimeSmart;
                    if (!nSmartTime) {
                        nSmartTime = pwtx->nTimeReceived;
                    }
                } else {
                    nSmartTime = pacentry->nTime;
                    copyTo->strFromAccount = copyFrom->strFromAccount;

identifier:copyTo,strFromAccount,copyFrom,strFromAccount,CWalletTx,CAccountingEntry,TxPair,int64_t,TxPair,TxItems,txByTime,insert,wtx,nTimeReceived,TxPair,wtx,nullptr,CAccountingEntry,acentries,batch,ListAccountCreditDebit,acentries,CAccountingEntry,entry,acentries,txByTime,insert,entry,nTime,TxPair,nullptr,entry,CWalletTx,pwtx,it,second,first,CAccountingEntry,pacentry,it,second,second,int64_t,nOrderPos,pwtx,nullptr,pwtx,nOrderPos,pacentry,nOrderPos,pwtx,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,batch,WriteAccountingEntry,pacentry,nEntryNo,pacentry,DBErrors::LOAD_FAIL,pwtx,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,batch,WriteAccountingEntry,pacentry,nEntryNo,pacentry,DBErrors::LOAD_FAIL,CWallet::AccountMove,strFrom,strTo,CAmount,nAmount,strComment,WalletBatch,batch,database,batch,TxnBegin,int64_t,nNow,GetAdjustedTime,CAccountingEntry,debit,debit,nOrderPos,IncOrderPosNext,batch,debit,strAccount,strFrom,debit,nCreditDebit,nAmount,debit,nTime,nNow,debit,strOtherAccount,strTo,debit,strComment,strComment,AddAccountingEntry,debit,batch,CAccountingEntry,credit,credit,nOrderPos,IncOrderPosNext,batch,credit,strAccount,strTo,credit,nCreditDebit,nAmount,credit,nTime,nNow,credit,strOtherAccount,strFrom,credit,strComment,strComment,AddAccountingEntry,credit,batch,batch,TxnCommit,CWallet::GetLabelDestination,CTxDestination,dest,label,bForceNew,WalletBatch,batch,database,CAccount,account,batch,ReadAccount,label,account,bForceNew,account,vchPubKey,IsValid,bForceNew,CScript,scriptPubKey,GetScriptForDestination,GetDestinationForKey,account,vchPubKey,m_default_address_type,uint256,CWalletTx,iterator,it,mapWallet,begin,it,mapWallet,end,account,vchPubKey,IsValid,it,CTxOut,txout,it,second,tx,vout,txout,scriptPubKey,scriptPubKey,bForceNew,bForceNew,GetKeyFromPool,account,vchPubKey,LearnRelatedScripts,account,vchPubKey,m_default_address_type,dest,GetDestinationForKey,account,vchPubKey,m_default_address_type,SetAddressBook,dest,label,batch,WriteAccount,label,account,dest,GetDestinationForKey,account,vchPubKey,m_default_address_type,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,TxPair,wtx,nullptr,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,TxPair,wtx,nullptr,input,tx,vin,COutputEntry,listSent,CAmount,nFee,strSentAccount,isminefilter,filter,strSentAccount,strFromAccount,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,CAmount,CWallet::GetLegacyBalance,isminefilter,filter,minDepth,account,IsMine,out,filter,depth,minDepth,account,account,GetLabelName,out,scriptPubKey,outgoing,account,account,wtx,strFromAccount,account,balance,WalletBatch,database,GetAccountCreditDebit,account,LOCK2,cs_main,cs_wallet,coin,availableCoins,output,lockedCoins,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,PROTOCOL_VERSION,CWallet::CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,fromAccount,CReserveKey,reservekey,CConnman,connman,CValidationState,state,wtxNew,strFromAccount,fromAccount,CWallet::ListAccountCreditDebit,strAccount,CAccountingEntry,entries,WalletBatch,batch,database,batch,ListAccountCreditDebit,strAccount,entries,CWallet::AddAccountingEntry,CAccountingEntry,acentry,WalletBatch,batch,database,AddAccountingEntry,acentry,batch,CWallet::AddAccountingEntry,CAccountingEntry,acentry,WalletBatch,batch,batch,WriteAccountingEntry,nAccountingEntryNumber,acentry,laccentries,push_back,acentry,CAccountingEntry,entry,laccentries,back,wtxOrdered,insert,entry,nOrderPos,TxPair,nullptr,entry,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,CWallet::DeleteLabel,label,WalletBatch,batch,database,batch,EraseAccount,label,CWalletTx,pwtx,it,second,first,CAccountingEntry,pacentry,it,second,second,pwtx,nSmartTime,pwtx,nTimeSmart,nSmartTime,nSmartTime,pwtx,nTimeReceived,nSmartTime,pacentry,nTime,copyTo,strFromAccount,copyFrom,strFromAccount,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.h
changed code snippet:
    std::string strFromAccount;
    std::multimap<int64_t, std::pair<CWalletTx*, CAccountingEntry*>>::const_iterator m_it_wtxOrdered;
        strFromAccount.clear();
        mapValueCopy["fromaccount"] = strFromAccount;
        strFromAccount = std::move(mapValue["fromaccount"]);
                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;
/**
 * DEPRECATED Internal transfers.
 * Database key is acentry<account><counter>.
 */
class CAccountingEntry
{
public:
    std::string strAccount;
    CAmount nCreditDebit;
    int64_t nTime;
    std::string strOtherAccount;
    std::string strComment;
    mapValue_t mapValue;
    int64_t nOrderPos; //!< position in ordered transaction list
    uint64_t nEntryNo;

    CAccountingEntry()
    {
        SetNull();
    }

    void SetNull()
    {
        nCreditDebit = 0;
        nTime = 0;
        strAccount.clear();
        strOtherAccount.clear();
        strComment.clear();
        nOrderPos = -1;
        nEntryNo = 0;
    }

    template <typename Stream>
    void Serialize(Stream& s) const {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH)) {
            s << nVersion;
        }
        //! Note: strAccount is serialized as part of the key, not here.
        s << nCreditDebit << nTime << strOtherAccount;

        mapValue_t mapValueCopy = mapValue;
        WriteOrderPos(nOrderPos, mapValueCopy);

        std::string strCommentCopy = strComment;
        if (!mapValueCopy.empty() || !_ssExtra.empty()) {
            CDataStream ss(s.GetType(), s.GetVersion());
            ss.insert(ss.begin(), '\0');
            ss << mapValueCopy;
            ss.insert(ss.end(), _ssExtra.begin(), _ssExtra.end());
            strCommentCopy.append(ss.str());
        }
        s << strCommentCopy;
    }

    template <typename Stream>
    void Unserialize(Stream& s) {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH)) {
            s >> nVersion;
        }
        //! Note: strAccount is serialized as part of the key, not here.
        s >> nCreditDebit >> nTime >> LIMITED_STRING(strOtherAccount, 65536) >> LIMITED_STRING(strComment, 65536);

        size_t nSepPos = strComment.find("\0", 0, 1);
        mapValue.clear();
        if (std::string::npos != nSepPos) {
            CDataStream ss(std::vector<char>(strComment.begin() + nSepPos + 1, strComment.end()), s.GetType(), s.GetVersion());
            ss >> mapValue;
            _ssExtra = std::vector<char>(ss.begin(), ss.end());
        }
        ReadOrderPos(nOrderPos, mapValue);
        if (std::string::npos != nSepPos) {
            strComment.erase(nSepPos);
        }

        mapValue.erase("n");
    }

private:
    std::vector<char> _ssExtra;
};

    std::list<CAccountingEntry> laccentries;
    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;
    typedef std::multimap<int64_t, TxPair > TxItems;
    std::map<CTxDestination, std::vector<COutput>> ListCoins() const;
    bool AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment = "") EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);
    bool GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew = false);
    CAmount GetLegacyBalance(const isminefilter& filter, int minDepth, const std::string* account) const;
    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, std::string fromAccount, CReserveKey& reservekey, CConnman* connman, CValidationState& state);
    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);
    bool AddAccountingEntry(const CAccountingEntry&);
    bool AddAccountingEntry(const CAccountingEntry&, WalletBatch *batch);
    bool m_allow_fallback_fee{true}; //<! will be defined via chainparams
    void DeleteLabel(const std::string& label);

/**
 * DEPRECATED Account information.
 * Stored in wallet with key "acc"+string account name.
 */
class CAccount
{
public:
    CPubKey vchPubKey;

    CAccount()
    {
        SetNull();
    }

    void SetNull()
    {
        vchPubKey = CPubKey();
    }

    ADD_SERIALIZE_METHODS;

    template <typename Stream, typename Operation>
    inline void SerializationOp(Stream& s, Operation ser_action) {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH))
            READWRITE(nVersion);
        READWRITE(vchPubKey);
    }
};


identifier:strFromAccount,int64_t,CWalletTx,CAccountingEntry,const_iterator,m_it_wtxOrdered,strFromAccount,clear,mapValueCopy,strFromAccount,strFromAccount,mapValue,COutputEntry,listSent,CAmount,nFee,strSentAccount,isminefilter,filter,class,CAccountingEntry,public,strAccount,CAmount,nCreditDebit,int64_t,nTime,strOtherAccount,strComment,mapValue_t,mapValue,int64_t,nOrderPos,uint64_t,nEntryNo,CAccountingEntry,SetNull,SetNull,nCreditDebit,nTime,strAccount,clear,strOtherAccount,clear,strComment,clear,nOrderPos,nEntryNo,template,typename,Stream,Serialize,Stream,s,nVersion,s,GetVersion,s,GetType,SER_GETHASH,s,nVersion,s,nCreditDebit,nTime,strOtherAccount,mapValue_t,mapValueCopy,mapValue,WriteOrderPos,nOrderPos,mapValueCopy,strCommentCopy,strComment,mapValueCopy,empty,_ssExtra,empty,CDataStream,ss,s,GetType,s,GetVersion,ss,insert,ss,begin,ss,mapValueCopy,ss,insert,ss,end,_ssExtra,begin,_ssExtra,end,strCommentCopy,append,ss,str,s,strCommentCopy,template,typename,Stream,Unserialize,Stream,s,nVersion,s,GetVersion,s,GetType,SER_GETHASH,s,nVersion,s,nCreditDebit,nTime,LIMITED_STRING,strOtherAccount,LIMITED_STRING,strComment,size_t,nSepPos,strComment,find,mapValue,clear,nSepPos,CDataStream,ss,strComment,begin,nSepPos,strComment,end,s,GetType,s,GetVersion,ss,mapValue,_ssExtra,ss,begin,ss,end,ReadOrderPos,nOrderPos,mapValue,nSepPos,strComment,erase,nSepPos,mapValue,erase,private,_ssExtra,CAccountingEntry,laccentries,CWalletTx,CAccountingEntry,TxPair,int64_t,TxPair,TxItems,CTxDestination,COutput,ListCoins,AccountMove,strFrom,strTo,CAmount,nAmount,strComment,EXCLUSIVE_LOCKS_REQUIRED,cs_wallet,GetLabelDestination,CTxDestination,dest,label,bForceNew,CAmount,GetLegacyBalance,isminefilter,filter,minDepth,account,CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,fromAccount,CReserveKey,reservekey,CConnman,connman,CValidationState,state,ListAccountCreditDebit,strAccount,CAccountingEntry,entries,AddAccountingEntry,CAccountingEntry,AddAccountingEntry,CAccountingEntry,WalletBatch,batch,m_allow_fallback_fee,DeleteLabel,label,class,CAccount,public,CPubKey,vchPubKey,CAccount,SetNull,SetNull,vchPubKey,CPubKey,ADD_SERIALIZE_METHODS,template,typename,Stream,typename,Operation,inline,SerializationOp,Stream,s,Operation,ser_action,nVersion,s,GetVersion,s,GetType,SER_GETHASH,READWRITE,nVersion,READWRITE,vchPubKey,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
bool WalletBatch::ReadAccount(const std::string& strAccount, CAccount& account)
{
    account.SetNull();
    return m_batch.Read(std::make_pair(std::string("acc"), strAccount), account);
}

bool WalletBatch::WriteAccount(const std::string& strAccount, const CAccount& account)
{
    return WriteIC(std::make_pair(std::string("acc"), strAccount), account);
}

bool WalletBatch::EraseAccount(const std::string& strAccount)
{
    return EraseIC(std::make_pair(std::string("acc"), strAccount));
}

bool WalletBatch::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)
{
    return WriteIC(std::make_pair(std::string("acentry"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);
}

CAmount WalletBatch::GetAccountCreditDebit(const std::string& strAccount)
{
    std::list<CAccountingEntry> entries;
    ListAccountCreditDebit(strAccount, entries);

    CAmount nCreditDebit = 0;
    for (const CAccountingEntry& entry : entries)
        nCreditDebit += entry.nCreditDebit;

    return nCreditDebit;
}

void WalletBatch::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries)
{
    bool fAllAccounts = (strAccount == "*");

    Dbc* pcursor = m_batch.GetCursor();
    if (!pcursor)
        throw std::runtime_error(std::string(__func__) + ": cannot create DB cursor");
    bool setRange = true;
    while (true)
    {
        // Read next record
        CDataStream ssKey(SER_DISK, CLIENT_VERSION);
        if (setRange)
            ssKey << std::make_pair(std::string("acentry"), std::make_pair((fAllAccounts ? std::string("") : strAccount), uint64_t(0)));
        CDataStream ssValue(SER_DISK, CLIENT_VERSION);
        int ret = m_batch.ReadAtCursor(pcursor, ssKey, ssValue, setRange);
        setRange = false;
        if (ret == DB_NOTFOUND)
            break;
        else if (ret != 0)
        {
            pcursor->close();
            throw std::runtime_error(std::string(__func__) + ": error scanning DB");
        }

        // Unserialize
        std::string strType;
        ssKey >> strType;
        if (strType != "acentry")
            break;
        CAccountingEntry acentry;
        ssKey >> acentry.strAccount;
        if (!fAllAccounts && acentry.strAccount != strAccount)
            break;

        ssValue >> acentry;
        ssKey >> acentry.nEntryNo;
        entries.push_back(acentry);
    }

    pcursor->close();
}

                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;
                    strErr = strprintf("LoadWallet() upgrading tx ver=%d %d '%s' %s",
                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount, hash.ToString());
        else if (strType == "acentry")
        {
            std::string strAccount;
            ssKey >> strAccount;
            uint64_t nNumber;
            ssKey >> nNumber;
            if (nNumber > pwallet->nAccountingEntryNumber) {
                pwallet->nAccountingEntryNumber = nNumber;
            }

            if (!wss.fAnyUnordered)
            {
                CAccountingEntry acentry;
                ssValue >> acentry;
                if (acentry.nOrderPos == -1)
                    wss.fAnyUnordered = true;
            }
        }
                strType != "minversion") {
    for (uint256 hash : wss.vWalletUpgrade)
    pwallet->laccentries.clear();
    ListAccountCreditDebit("*", pwallet->laccentries);
    for (CAccountingEntry& entry : pwallet->laccentries) {
        pwallet->wtxOrdered.insert(make_pair(entry.nOrderPos, CWallet::TxPair(nullptr, &entry)));
    }

    for (uint256 hash : vTxHash) {
    for (uint256& hash : vTxHash) {

identifier:WalletBatch::ReadAccount,strAccount,CAccount,account,account,SetNull,m_batch,Read,strAccount,account,WalletBatch::WriteAccount,strAccount,CAccount,account,WriteIC,strAccount,account,WalletBatch::EraseAccount,strAccount,EraseIC,strAccount,WalletBatch::WriteAccountingEntry,uint64_t,nAccEntryNum,CAccountingEntry,acentry,WriteIC,acentry,strAccount,nAccEntryNum,acentry,CAmount,WalletBatch::GetAccountCreditDebit,strAccount,CAccountingEntry,entries,ListAccountCreditDebit,strAccount,entries,CAmount,nCreditDebit,CAccountingEntry,entry,entries,nCreditDebit,entry,nCreditDebit,nCreditDebit,WalletBatch::ListAccountCreditDebit,strAccount,CAccountingEntry,entries,fAllAccounts,strAccount,Dbc,pcursor,m_batch,GetCursor,pcursor,throw,__func__,setRange,CDataStream,ssKey,SER_DISK,CLIENT_VERSION,setRange,ssKey,fAllAccounts,strAccount,uint64_t,CDataStream,ssValue,SER_DISK,CLIENT_VERSION,ret,m_batch,ReadAtCursor,pcursor,ssKey,ssValue,setRange,setRange,ret,DB_NOTFOUND,ret,pcursor,close,throw,__func__,strType,ssKey,strType,strType,CAccountingEntry,acentry,ssKey,acentry,strAccount,fAllAccounts,acentry,strAccount,strAccount,ssValue,acentry,ssKey,acentry,nEntryNo,entries,push_back,acentry,pcursor,close,ssValue,fTmp,fUnused,wtx,strFromAccount,strErr,strprintf,wtx,fTimeReceivedIsTxTime,fTmp,wtx,strFromAccount,hash,ToString,strType,strAccount,ssKey,strAccount,uint64_t,nNumber,ssKey,nNumber,nNumber,pwallet,nAccountingEntryNumber,pwallet,nAccountingEntryNumber,nNumber,wss,fAnyUnordered,CAccountingEntry,acentry,ssValue,acentry,acentry,nOrderPos,wss,fAnyUnordered,strType,uint256,hash,wss,vWalletUpgrade,pwallet,laccentries,clear,ListAccountCreditDebit,pwallet,laccentries,CAccountingEntry,entry,pwallet,laccentries,pwallet,wtxOrdered,insert,make_pair,entry,nOrderPos,CWallet::TxPair,nullptr,entry,uint256,hash,vTxHash,uint256,hash,vTxHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.h
changed code snippet:
class CAccount;
class CAccountingEntry;
    /// This writes directly to the database, and will not update the CWallet's cached accounting entries!
    /// Use wallet.AddAccountingEntry instead, to write *and* update its caches.
    bool WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry);
    bool ReadAccount(const std::string& strAccount, CAccount& account);
    bool WriteAccount(const std::string& strAccount, const CAccount& account);
    bool EraseAccount(const std::string& strAccount);

    CAmount GetAccountCreditDebit(const std::string& strAccount);
    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);


identifier:class,CAccount,class,CAccountingEntry,WriteAccountingEntry,uint64_t,nAccEntryNum,CAccountingEntry,acentry,ReadAccount,strAccount,CAccount,account,WriteAccount,strAccount,CAccount,account,EraseAccount,strAccount,CAmount,GetAccountCreditDebit,strAccount,ListAccountCreditDebit,strAccount,CAccountingEntry,acentries,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:893628be0166b4096b6e52f516e0f65bb63a75a2
commit B:da74db0940720407fafaf3582bbaf9c81a4d3b4d
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/sign.h
changed code snippet:
    WriteCompactSize(s, GetSerializeSizeMany(s, args...));

identifier:WriteCompactSize,s,GetSerializeSizeMany,s,args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
template <typename S, typename T>
size_t GetSerializeSize(const S& s, const T& t)
    return (CSizeComputer(s.GetVersion()) << t).size();
}

template <typename S, typename... T>
size_t GetSerializeSizeMany(const S& s, const T&... t)
{
    CSizeComputer sc(s.GetType(), s.GetVersion());

identifier:template,typename,S,typename,T,size_t,GetSerializeSize,S,s,T,t,CSizeComputer,s,GetVersion,t,size,template,typename,S,typename,T,size_t,GetSerializeSizeMany,S,s,T,t,CSizeComputer,sc,s,GetType,s,GetVersion,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
    unsigned int nSize = GetSerializeSize(fileout, block);
    unsigned int nSize = GetSerializeSize(fileout, blockundo);

identifier:nSize,GetSerializeSize,fileout,block,nSize,GetSerializeSize,fileout,blockundo,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:da74db0940720407fafaf3582bbaf9c81a4d3b4d
commit B:fac95398366f644911b58f1605e6bc37fb76782d
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (const auto v_i : v) {
    for (const auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (const CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockencodings.cpp
changed code snippet:
    LogPrint(BCLog::CMPCTBLOCK, "Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\n", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));

identifier:LogPrint,BCLog::CMPCTBLOCK,cmpctblock,header,GetHash,ToString,GetSerializeSize,cmpctblock,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/blockfilter.cpp
changed code snippet:
            if (script.empty() || script[0] == OP_RETURN) continue;
            if (script.empty()) continue;

identifier:script,empty,script,OP_RETURN,script,empty,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:

#include <chainparamsseeds.h>

identifier:include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.cpp
changed code snippet:
static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_OUTPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxOut,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/tx_verify.cpp
changed code snippet:
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,
++@DIFF ENTRY SEPERATOR@++
changed file:src/consensus/validation.h
changed code snippet:
    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);
    return ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(txin, SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(txin.scriptWitness.stack, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,GetSerializeSize,txin,SER_NETWORK,PROTOCOL_VERSION,GetSerializeSize,txin,scriptWitness,stack,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/core_write.cpp
changed code snippet:
    entry.pushKV("size", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));

identifier:entry,pushKV,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (const uint32_t loc : locs)
            for (const uint32_t loc : locs) {
        for (const uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmap'ed).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    Mutex cs;
        LOCK(cs);
                WAIT_LOCK(cs, lock);
        LOCK(cs);

identifier:Mutex,cs,LOCK,cs,WAIT_LOCK,cs,lock,LOCK,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/index/txindex.cpp
changed code snippet:
        pos.nTxOffset += ::GetSerializeSize(*tx, SER_DISK, CLIENT_VERSION);

identifier:pos,nTxOffset,GetSerializeSize,tx,SER_DISK,CLIENT_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    const auto regtestChainParams = CreateChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -noconnect disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services, set -noonion to disable (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort(), regtestChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy, set -noproxy to disable (default: disabled)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", "Output debugging information (default: -nodebug, supplying <category> is optional). "
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::RPC);
static Mutex g_genesis_wait_mutex;
static std::condition_variable g_genesis_wait_cv;
            LOCK(g_genesis_wait_mutex);
        g_genesis_wait_cv.notify_all();
        WAIT_LOCK(g_genesis_wait_mutex, lock);
            g_genesis_wait_cv.wait_for(lock, std::chrono::milliseconds(500));

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,regtestChainParams,CreateChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,regtestChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::RPC,Mutex,g_genesis_wait_mutex,g_genesis_wait_cv,LOCK,g_genesis_wait_mutex,g_genesis_wait_cv,notify_all,WAIT_LOCK,g_genesis_wait_mutex,lock,g_genesis_wait_cv,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.cpp
changed code snippet:
        if (!m_wallet.CommitTransaction(m_tx, std::move(value_map), std::move(order_form), m_key, g_connman.get(), state)) {

identifier:m_wallet,CommitTransaction,m_tx,value_map,order_form,m_key,g_connman,get,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/interfaces/wallet.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/logging.cpp
changed code snippet:
                FILE* new_fileout = fsbridge::fopen(m_file_path, "a");
                if (new_fileout) {
                    setbuf(new_fileout, nullptr); // unbuffered
                    fclose(m_fileout);
                    m_fileout = new_fileout;

identifier:FILE,new_fileout,fsbridge::fopen,m_file_path,new_fileout,setbuf,new_fileout,nullptr,fclose,m_fileout,m_fileout,new_fileout,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (const CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(vNodesSize);
        for (const CNode* pnode : vNodes) {
        for (const CNode* pnode : vNodes) {
            for (const CNode* pnode : vNodes) {
        WAIT_LOCK(mutexMsgProc, lock);
        LOCK(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,vNodesSize,CNode,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,WAIT_LOCK,mutexMsgProc,lock,LOCK,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    Mutex mutexMsgProc;

identifier:Mutex,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
CCriticalSection g_cs_orphans;
        for (const uint256& orphanHash : vOrphanErase) {
            for (const uint256& hash : vEraseQueue)

identifier:CCriticalSection,g_cs_orphans,uint256,orphanHash,vOrphanErase,uint256,hash,vEraseQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/fees.h
changed code snippet:
/** \class CBlockPolicyEstimator
 * The BlockPolicyEstimator is used for estimating the feerate needed
 * for a transaction to be included in a block within a certain number of
 * blocks.
 *
 * At a high level the algorithm works by grouping transactions into buckets
 * based on having similar feerates and then tracking how long it
 * takes transactions in the various buckets to be mined.  It operates under
 * the assumption that in general transactions of higher feerate will be
 * included in blocks before transactions of lower feerate.   So for
 * example if you wanted to know what feerate you should put on a transaction to
 * be included in a block within the next 5 blocks, you would start by looking
 * at the bucket with the highest feerate transactions and verifying that a
 * sufficiently high percentage of them were confirmed within 5 blocks and
 * then you would look at the next highest feerate bucket, and so on, stopping at
 * the last bucket to pass the test.   The average feerate of transactions in this
 * bucket will give you an indication of the lowest feerate you can put on a
 * transaction and still have a sufficiently high chance of being confirmed
 * within your desired 5 blocks.
 *
 * Here is a brief description of the implementation:
 * When a transaction enters the mempool, we track the height of the block chain
 * at entry.  All further calculations are conducted only on this set of "seen"
 * transactions. Whenever a block comes in, we count the number of transactions
 * in each bucket and the total amount of feerate paid in each bucket. Then we
 * calculate how many blocks Y it took each transaction to be mined.  We convert
 * from a number of blocks to a number of periods Y' each encompassing "scale"
 * blocks.  This is tracked in 3 different data sets each up to a maximum
 * number of periods. Within each data set we have an array of counters in each
 * feerate bucket and we increment all the counters from Y' up to max periods
 * representing that a tx was successfully confirmed in less than or equal to
 * that many periods. We want to save a history of this information, so at any
 * time we have a counter of the total number of transactions that happened in a
 * given feerate bucket and the total number that were confirmed in each of the
 * periods or less for any bucket.  We save this history by keeping an
 * exponentially decaying moving average of each one of these stats.  This is
 * done for a different decay in each of the 3 data sets to keep relevant data
 * from different time horizons.  Furthermore we also keep track of the number
 * unmined (in mempool or left mempool without being included in a block)
 * transactions in each bucket and for how many blocks they have been
 * outstanding and use both of these numbers to increase the number of transactions
 * we've seen in that feerate bucket when calculating an estimate for any number
 * of confirmations below the number of blocks they've been outstanding.
 *

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/policy/policy.cpp
changed code snippet:
    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);

identifier:size_t,nSize,GetSerializeSize,txout,SER_DISK,
++@DIFF ENTRY SEPERATOR@++
changed file:src/primitives/transaction.cpp
changed code snippet:
    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);

identifier:GetSerializeSize,this,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    for (const WalletModel* walletModel : m_wallet_models) {

identifier:WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
#ifndef Q_OS_MAC
    // Note: On Mac, the dock icon's menu already has show / hide action.
#endif
    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:ifndef,Q_OS_MAC,endif,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.h
changed code snippet:
     @param[in] hdEnabled         current hd enabled status

identifier:param,in,hdEnabled,current,hd,enabled,status,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (const auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/rpcconsole.cpp
changed code snippet:
 * @param[out]   strResult   stringified result from the executed command(chain)

identifier:param,out,strResult,stringified,result,from,the,executed,command,chain,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (const auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of milliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,milliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (const float f : vSamplesIn) {
    for (const float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/walletmodel.cpp
changed code snippet:
        if (!newTx->commit({} /* mapValue */, std::move(vOrderForm), rejectReason))

identifier:newTx,commit,vOrderForm,rejectReason,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
#include <sync.h>     // for WAIT_LOCK
static Mutex cs_rng_state;
        WAIT_LOCK(cs_rng_state, lock);
        WAIT_LOCK(cs_rng_state, lock);

identifier:include,sync,h,Mutex,cs_rng_state,WAIT_LOCK,cs_rng_state,lock,WAIT_LOCK,cs_rng_state,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static Mutex cs_blockchange;
    result.pushKV("strippedsize", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS));
    result.pushKV("size", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION));
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
    for (CTxMemPool::txiter childiter : setChildren) {
                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;
            "For more information on output descriptors, see the documentation in the doc/descriptors.md file.\n"

identifier:Mutex,cs_blockchange,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,result,pushKV,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,CTxMemPool::txiter,childiter,setChildren,utxo_size_inc,GetSerializeSize,out,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,utxo_size_inc,GetSerializeSize,prevoutput,SER_NETWORK,PROTOCOL_VERSION,PER_UTXO_OVERHEAD,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WAIT_LOCK(g_best_block_mutex, lock);
    for (const FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WAIT_LOCK,g_best_block_mutex,lock,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
        std::string currentAddress = EncodeDestination(dest);
        ret.pushKV("address", currentAddress);
        CScript scriptPubKey = GetScriptForDestination(dest);
        ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));
        UniValue detail = DescribeAddress(dest);
        ret.pushKVs(detail);
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\n.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} },

identifier:currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (const int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
            // if redeemScript and private keys were given, add redeemScript to the keystore so it can be signed
    // This method should be removed entirely in V0.19, along with the entries in the
    // CRPCCommand table and rpc/client.cpp.
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction was removed in v0.18.\n"
        "Clients should transition to using signrawtransactionwithkey and signrawtransactionwithwallet");
            "\nAlso see createrawtransaction and signrawtransactionwithkey calls.\n"
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
                            "                              will be tried. If false, only non-witness deserialization will be tried. Only has an effect if\n"
    { "hidden",             "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} },

identifier:throw,JSONRPCError,RPC_METHOD_DEPRECATED,HelpExampleCli,HelpExampleCli,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practically, this means that callbacks can behave as if they are executed

identifier:Practically,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/bitcoinconsensus.cpp
changed code snippet:
        if (GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) != txToLen)

identifier:GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,txToLen,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If successful, sp is updated to skip the constant and return true. */
/** Parse a function call. If successful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/serialize.h
changed code snippet:
    const int nType;
    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}
    int GetType() const { return nType; }
size_t GetSerializeSize(const T& t, int nType, int nVersion = 0)
    return (CSizeComputer(nType, nVersion) << t).size();
    return (CSizeComputer(s.GetType(), s.GetVersion()) << t).size();

identifier:nType,CSizeComputer,nTypeIn,nVersionIn,nSize,nType,nTypeIn,nVersion,nVersionIn,GetType,nType,size_t,GetSerializeSize,T,t,nType,nVersion,CSizeComputer,nType,nVersion,t,size,CSizeComputer,s,GetType,s,GetVersion,t,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
     * in the nbits least significant bits of a 64-bit uint.

identifier:in,the,nbits,least,significant,bits,of,a,bit,uint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto allocated = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(allocated->first);

identifier:allocated,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,allocated,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    if (g_debug_lockorder_abort) {
        fprintf(stderr, "Assertion failed: detected inconsistent lock order at %s:%i, details in debug log.\n", __FILE__, __LINE__);
        abort();
    }
    throw std::logic_error("potential deadlock detected");
bool g_debug_lockorder_abort = true;


identifier:g_debug_lockorder_abort,fprintf,stderr,__FILE__,__LINE__,abort,throw,g_debug_lockorder_abort,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);

 * Call abort() if a potential lock order deadlock bug is detected, instead of
 * just logging information and throwing a logic_error. Defaults to true, and
 * set to false in DEBUG_LOCKORDER unit tests.
 */
extern bool g_debug_lockorder_abort;
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)

/**
 * Template mixin that adds -Wthread-safety locking annotations and lock order
 * checking to a subset of the mutex API.
    ~AnnotatedMixin() {
        DeleteLock((void*)this);
    }


    using UniqueLock = std::unique_lock<PARENT>;
typedef AnnotatedMixin<std::recursive_mutex> CCriticalSection;
typedef AnnotatedMixin<std::mutex> Mutex;
/** Wrapper around std::unique_lock style lock for Mutex. */
template <typename Mutex, typename Base = typename Mutex::UniqueLock>
class SCOPED_LOCKABLE UniqueLock : public Base
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()));
        if (!Base::try_lock()) {
            Base::lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()), true);
        Base::try_lock();
        if (!Base::owns_lock())
        return Base::owns_lock();
    UniqueLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : Base(mutexIn, std::defer_lock)
    UniqueLock(Mutex* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        *static_cast<Base*>(this) = Base(*pmutexIn, std::defer_lock);
    ~UniqueLock() UNLOCK_FUNCTION()
        if (Base::owns_lock())
        return Base::owns_lock();
template<typename MutexArg>
using DebugLock = UniqueLock<typename std::remove_reference<typename std::remove_pointer<MutexArg>::type>::type>;

#define LOCK(cs) DebugLock<decltype(cs)> PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2)                                               \
    DebugLock<decltype(cs1)> criticalblock1(cs1, #cs1, __FILE__, __LINE__); \
    DebugLock<decltype(cs2)> criticalblock2(cs2, #cs2, __FILE__, __LINE__);
#define TRY_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__, true)
#define WAIT_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__)

identifier:ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,Call,abort,a,potential,lock,order,deadlock,bug,is,detected,instead,of,just,logging,information,and,throwing,a,logic_error,Defaults,to,and,set,to,in,DEBUG_LOCKORDER,unit,tests,g_debug_lockorder_abort,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,template,typename,Mutex,typename,Base,typename,Mutex::UniqueLock,class,SCOPED_LOCKABLE,UniqueLock,public,Base,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::lock,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::owns_lock,Base::owns_lock,UniqueLock,Mutex,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,Base,mutexIn,UniqueLock,Mutex,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,static_cast,Base,this,Base,pmutexIn,UniqueLock,UNLOCK_FUNCTION,Base::owns_lock,Base::owns_lock,template,typename,MutexArg,using,DebugLock,UniqueLock,typename,typename,MutexArg,type,type,define,LOCK,cs,DebugLock,decltype,cs,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,DebugLock,decltype,cs1,criticalblock1,cs1,cs1,__FILE__,__LINE__,DebugLock,decltype,cs2,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,define,WAIT_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/blockfilter_tests.cpp
changed code snippet:
    CScript included_scripts[5], excluded_scripts[3];
    tx_2.vout.emplace_back(400, excluded_scripts[2]); // Script is empty
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(500, included_scripts[3]), 1000, true);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(600, included_scripts[4]), 10000, false);
    block_undo.vtxundo.back().vprevout.emplace_back(CTxOut(700, excluded_scripts[2]), 100000, false);

identifier:CScript,included_scripts,excluded_scripts,tx_2,vout,emplace_back,excluded_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,included_scripts,block_undo,vtxundo,back,vprevout,emplace_back,CTxOut,excluded_scripts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (const size_t i : range) {
        for (const bool end_fails : {true, false}) {

identifier:size_t,i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure&) {
    } catch (const std::ios_base::failure&) {
    } catch (std::logic_error&) {
    for (const CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error&) {
    for (const CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (const CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (const char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (const char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:CAmount,base_value,ABSENT,PRUNED,VALUE1,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (const uint256& h : hashes_insert_copy)
    for (const uint256& h : hashes)
            for (const auto& h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure&) {
    for (const int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/denialofservice_tests.cpp
changed code snippet:
extern CCriticalSection g_cs_orphans;
extern std::map<uint256, COrphanTx> mapOrphanTransactions GUARDED_BY(g_cs_orphans);
    LOCK2(cs_main, g_cs_orphans);
    LOCK2(cs_main, g_cs_orphans);

identifier:CCriticalSection,g_cs_orphans,uint256,COrphanTx,mapOrphanTransactions,GUARDED_BY,g_cs_orphans,LOCK2,cs_main,g_cs_orphans,LOCK2,cs_main,g_cs_orphans,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (const std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (const auto& chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/miner_tests.cpp
changed code snippet:
    size_t freeTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,freeTxSize,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception&) {
    } catch (const std::exception&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/scheduler_tests.cpp
changed code snippet:
            bool expectation = i == counter1++;
            assert(expectation);
            bool expectation = i == counter2++;
            assert(expectation);

identifier:expectation,i,counter1,assert,expectation,expectation,i,counter2,assert,expectation,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/serialize_tests.cpp
changed code snippet:
        size += ::GetSerializeSize(VARINT(i, VarIntMode::NONNEGATIVE_SIGNED), 0, 0);
        size += ::GetSerializeSize(VARINT(i), 0, 0);

identifier:size,GetSerializeSize,VARINT,i,VarIntMode::NONNEGATIVE_SIGNED,size,GetSerializeSize,VARINT,i,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (const unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/sync_tests.cpp
changed code snippet:

#include <sync.h>
#include <test/test_bitcoin.h>

#include <boost/test/unit_test.hpp>

namespace {
template <typename MutexType>
void TestPotentialDeadLockDetected(MutexType& mutex1, MutexType& mutex2)
{
    {
        LOCK2(mutex1, mutex2);
    }
    bool error_thrown = false;
    try {
        LOCK2(mutex2, mutex1);
    } catch (const std::logic_error& e) {
        BOOST_CHECK_EQUAL(e.what(), "potential deadlock detected");
        error_thrown = true;
    }
    #ifdef DEBUG_LOCKORDER
    BOOST_CHECK(error_thrown);
    #else
    BOOST_CHECK(!error_thrown);
    #endif
}
} // namespace

BOOST_FIXTURE_TEST_SUITE(sync_tests, BasicTestingSetup)

BOOST_AUTO_TEST_CASE(potential_deadlock_detected)
{
    #ifdef DEBUG_LOCKORDER
    bool prev = g_debug_lockorder_abort;
    g_debug_lockorder_abort = false;
    #endif

    CCriticalSection rmutex1, rmutex2;
    TestPotentialDeadLockDetected(rmutex1, rmutex2);

    Mutex mutex1, mutex2;
    TestPotentialDeadLockDetected(mutex1, mutex2);

    #ifdef DEBUG_LOCKORDER
    g_debug_lockorder_abort = prev;
    #endif
}

BOOST_AUTO_TEST_SUITE_END()

identifier:include,sync,h,include,test,test_bitcoin,h,include,boost,test,unit_test,hpp,namespace,template,typename,MutexType,TestPotentialDeadLockDetected,MutexType,mutex1,MutexType,mutex2,LOCK2,mutex1,mutex2,error_thrown,LOCK2,mutex2,mutex1,e,BOOST_CHECK_EQUAL,e,what,error_thrown,ifdef,DEBUG_LOCKORDER,BOOST_CHECK,error_thrown,BOOST_CHECK,error_thrown,endif,BOOST_FIXTURE_TEST_SUITE,sync_tests,BasicTestingSetup,BOOST_AUTO_TEST_CASE,potential_deadlock_detected,ifdef,DEBUG_LOCKORDER,prev,g_debug_lockorder_abort,g_debug_lockorder_abort,endif,CCriticalSection,rmutex1,rmutex2,TestPotentialDeadLockDetected,rmutex1,rmutex2,Mutex,mutex1,mutex2,TestPotentialDeadLockDetected,mutex1,mutex2,ifdef,DEBUG_LOCKORDER,g_debug_lockorder_abort,prev,endif,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (const CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (const std::string& word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/uint256_tests.cpp
changed code snippet:
    BOOST_CHECK(GetSerializeSize(R1L, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(ZeroL, 0, PROTOCOL_VERSION) == 32);
    BOOST_CHECK(GetSerializeSize(R1S, 0, PROTOCOL_VERSION) == 20);
    BOOST_CHECK(GetSerializeSize(ZeroS, 0, PROTOCOL_VERSION) == 20);

identifier:BOOST_CHECK,GetSerializeSize,R1L,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroL,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,R1S,PROTOCOL_VERSION,BOOST_CHECK,GetSerializeSize,ZeroS,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (const char opt : "abcdef")
    for (const bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
#include <sync.h>

        LOCK(mut);
    WAIT_LOCK(mut, lock);

identifier:include,sync,h,LOCK,mut,WAIT_LOCK,mut,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
#include <sync.h>

    Mutex mut;

identifier:include,sync,h,Mutex,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (const int64_t nOffset : vSorted)
            for (const int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
        for (txiter phash : setMemPoolParents) {
        for (txiter childiter : setChildren) {
    for (txiter it : stage) {

identifier:txiter,phash,setMemPoolParents,txiter,childiter,setChildren,txiter,it,stage,
++@DIFF ENTRY SEPERATOR@++
changed file:src/undo.h
changed code snippet:
static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);

identifier:size_t,MIN_TRANSACTION_INPUT_WEIGHT,WITNESS_SCALE_FACTOR,GetSerializeSize,CTxIn,SER_NETWORK,PROTOCOL_VERSION,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
    static inline bool UseDefaultSection(const ArgsManager& am, const std::string& arg) EXCLUSIVE_LOCKS_REQUIRED(am.cs_args)
    static inline bool GetNetBoolArg(const ArgsManager &am, const std::string& net_arg) EXCLUSIVE_LOCKS_REQUIRED(am.cs_args)
    LOCK(cs_args);

    LOCK(cs_args);
    LOCK(cs_args);
    LOCK(cs_args);
    LOCK(cs_args);
static bool GetConfigOptions(std::istream& stream, std::string& error, std::vector<std::pair<std::string, std::string>> &options)
    int linenr = 1;
            } else if (*str.begin() == '-') {
                error = strprintf("parse error on line %i: %s, options in configuration file must be specified without leading -", linenr, str);
                return false;
            } else {
                error = strprintf("parse error on line %i: %s", linenr, str);
                if (str.size() >= 2 && str.substr(0, 2) == "no") {
                    error += strprintf(", if you intended to specify a negated option, use %s=1 instead", str);
                }
                return false;
        ++linenr;
    return true;
    std::vector<std::pair<std::string, std::string>> options;
    if (!GetConfigOptions(stream, error, options)) {
        return false;
    }
    for (const std::pair<std::string, std::string>& option : options) {
        bool emptyIncludeConf;
        {
            LOCK(cs_args);
            emptyIncludeConf = m_override_args.count("-includeconf") == 0;
        }
        if (emptyIncludeConf) {
    LOCK(cs_args);

identifier:inline,UseDefaultSection,ArgsManager,am,arg,EXCLUSIVE_LOCKS_REQUIRED,am,cs_args,inline,GetNetBoolArg,ArgsManager,am,net_arg,EXCLUSIVE_LOCKS_REQUIRED,am,cs_args,LOCK,cs_args,LOCK,cs_args,LOCK,cs_args,LOCK,cs_args,LOCK,cs_args,GetConfigOptions,stream,error,options,linenr,str,begin,error,strprintf,linenr,str,error,strprintf,linenr,str,str,size,str,substr,error,strprintf,str,linenr,options,GetConfigOptions,stream,error,options,option,options,emptyIncludeConf,LOCK,cs_args,emptyIncludeConf,m_override_args,count,emptyIncludeConf,LOCK,cs_args,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.h
changed code snippet:
    std::map<std::string, std::vector<std::string>> m_override_args GUARDED_BY(cs_args);
    std::map<std::string, std::vector<std::string>> m_config_args GUARDED_BY(cs_args);
    std::string m_network GUARDED_BY(cs_args);
    std::set<std::string> m_network_only_args GUARDED_BY(cs_args);
    std::map<OptionsCategory, std::map<std::string, Arg>> m_available_args GUARDED_BY(cs_args);
    void ClearArgs() {
        LOCK(cs_args);
        m_available_args.clear();
    }

identifier:m_override_args,GUARDED_BY,cs_args,m_config_args,GUARDED_BY,cs_args,m_network,GUARDED_BY,cs_args,m_network_only_args,GUARDED_BY,cs_args,OptionsCategory,Arg,m_available_args,GUARDED_BY,cs_args,ClearArgs,LOCK,cs_args,m_available_args,clear,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (const char c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
Mutex g_best_block_mutex;
std::condition_variable g_best_block_cv;
            for (const int height : prevheights) {
    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) < MIN_STANDARD_TX_NONWITNESS_SIZE)
        if (!FindUndoPos(state, pindex->nFile, _pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))
        LOCK(g_best_block_mutex);
    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)
    unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);
    for (const BlockMap::value_type& entry : mapBlockIndex) {
    for (const std::pair<const uint256, CBlockIndex*>& entry : mapBlockIndex) {

identifier:Mutex,g_best_block_mutex,g_best_block_cv,height,prevheights,GetSerializeSize,tx,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,MIN_STANDARD_TX_NONWITNESS_SIZE,FindUndoPos,state,pindex,nFile,_pos,GetSerializeSize,blockundo,SER_DISK,CLIENT_VERSION,LOCK,g_best_block_mutex,block,vtx,empty,block,vtx,size,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,GetSerializeSize,block,SER_NETWORK,PROTOCOL_VERSION,SERIALIZE_TRANSACTION_NO_WITNESS,WITNESS_SCALE_FACTOR,MAX_BLOCK_WEIGHT,nBlockSize,GetSerializeSize,block,SER_DISK,CLIENT_VERSION,BlockMap::value_type,entry,mapBlockIndex,uint256,CBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
extern Mutex g_best_block_mutex;
extern std::condition_variable g_best_block_cv;

identifier:Mutex,g_best_block_mutex,g_best_block_cv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (const KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An unused temporary BerkeleyEnvironment object may be created inside the
            for (const auto& env : g_dbenvs) {

identifier:env,g_dbenvs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/feebumper.cpp
changed code snippet:
    if (!wallet->CommitTransaction(tx, std::move(mapValue), oldWtx.vOrderForm, reservekey, g_connman.get(), state)) {

identifier:wallet,CommitTransaction,tx,mapValue,oldWtx,vOrderForm,reservekey,g_connman,get,state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
                               " (1 = keep tx meta data e.g. payment request information, 2 = drop tx meta data)", false, OptionsCategory::WALLET);

identifier:OptionsCategory::WALLET,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (const unsigned char c : str) {

identifier:c,str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, reservekey, g_connman.get(), state)) {
    if (totalAmount > pwallet->GetLegacyBalance(ISMINE_SPENDABLE, nMinDepth)) {
    if (!pwallet->CommitTransaction(tx, std::move(mapValue), {} /* orderForm */, keyChange, g_connman.get(), state)) {
    wtx.GetAmounts(listReceived, listSent, nFee, filter);
            CWalletTx *const pwtx = (*it).second;
            ListTransactions(pwallet, *pwtx, 0, true, ret, filter);
    for (const COutPoint& outpt : vOutpts) {

identifier:pwallet,CommitTransaction,tx,mapValue,reservekey,g_connman,get,state,totalAmount,pwallet,GetLegacyBalance,ISMINE_SPENDABLE,nMinDepth,pwallet,CommitTransaction,tx,mapValue,keyChange,g_connman,get,state,wtx,GetAmounts,listReceived,listSent,nFee,filter,CWalletTx,pwtx,it,second,ListTransactions,pwallet,pwtx,ret,filter,COutPoint,outpt,vOutpts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/test/wallet_tests.cpp
changed code snippet:
        BOOST_CHECK(wallet->CommitTransaction(tx, {}, {}, reservekey, nullptr, state));
    std::map<CTxDestination, std::vector<COutput>> list;
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }
    {
        LOCK2(cs_main, wallet->cs_wallet);
        list = wallet->ListCoins();
    }

identifier:BOOST_CHECK,wallet,CommitTransaction,tx,reservekey,nullptr,state,CTxDestination,COutput,list,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,LOCK2,cs_main,wallet,cs_wallet,list,wallet,ListCoins,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
    // First: get all CWalletTx into a sorted-by-time multimap.
    typedef std::multimap<int64_t, CWalletTx*> TxItems;
        txByTime.insert(std::make_pair(wtx->nTimeReceived, wtx));
        CWalletTx *const pwtx = (*it).second;
        int64_t& nOrderPos = pwtx->nOrderPos;
            if (!batch.WriteTx(*pwtx))
                return DBErrors::LOAD_FAIL;
            if (!batch.WriteTx(*pwtx))
                return DBErrors::LOAD_FAIL;
        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));
        wtx.m_it_wtxOrdered = wtxOrdered.insert(std::make_pair(wtx.nOrderPos, &wtx));
    for (const CTxIn& input : tx.vin) {
                           std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const
    for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth) const
            } else if (IsMine(out) & filter && depth >= minDepth) {
        if (outgoing) {
    AssertLockHeld(cs_main);
    AssertLockHeld(cs_wallet);
    for (const COutput& coin : availableCoins) {
    for (const COutPoint& output : lockedCoins) {
            coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);
                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, SER_NETWORK, PROTOCOL_VERSION);
bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state)
        for (const int64_t nIndex : setInternalKeyPool) {
        for (const int64_t nIndex : setExternalKeyPool) {
        for (const int64_t nIndex : set_pre_split_keypool) {
            for (const CTxIn& txin : pcoin->tx->vin)
               for (const CTxOut& txout : pcoin->tx->vout)
        for (const CTxDestination& address : _grouping)
        for (const CTxDestination& element : *merged)
    for (const std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)
                CWalletTx* const pwtx = it->second;
                nSmartTime = pwtx->nTimeSmart;
                if (!nSmartTime) {
                    nSmartTime = pwtx->nTimeReceived;

identifier:int64_t,CWalletTx,TxItems,txByTime,insert,wtx,nTimeReceived,wtx,CWalletTx,pwtx,it,second,int64_t,nOrderPos,pwtx,nOrderPos,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,batch,WriteTx,pwtx,DBErrors::LOAD_FAIL,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,wtx,wtx,m_it_wtxOrdered,wtxOrdered,insert,wtx,nOrderPos,wtx,CTxIn,input,tx,vin,COutputEntry,listSent,CAmount,nFee,isminefilter,filter,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,CAmount,CWallet::GetLegacyBalance,isminefilter,filter,minDepth,IsMine,out,filter,depth,minDepth,outgoing,AssertLockHeld,cs_main,AssertLockHeld,cs_wallet,COutput,coin,availableCoins,COutPoint,output,lockedCoins,coin_selection_params,change_output_size,GetSerializeSize,change_prototype_txout,SER_DISK,coin_selection_params,tx_noinputs_size,GetSerializeSize,txout,SER_NETWORK,PROTOCOL_VERSION,CWallet::CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,CReserveKey,reservekey,CConnman,connman,CValidationState,state,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,CWalletTx,pwtx,it,second,nSmartTime,pwtx,nTimeSmart,nSmartTime,nSmartTime,pwtx,nTimeReceived,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.h
changed code snippet:
    std::multimap<int64_t, CWalletTx*>::const_iterator m_it_wtxOrdered;
        mapValueCopy["fromaccount"] = "";
                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;
    typedef std::multimap<int64_t, CWalletTx*> TxItems;
    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_main, cs_wallet);
    CAmount GetLegacyBalance(const isminefilter& filter, int minDepth) const;
    bool CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm, CReserveKey& reservekey, CConnman* connman, CValidationState& state);
    bool m_allow_fallback_fee{true}; //!< will be defined via chainparams

identifier:int64_t,CWalletTx,const_iterator,m_it_wtxOrdered,mapValueCopy,COutputEntry,listSent,CAmount,nFee,isminefilter,filter,int64_t,CWalletTx,TxItems,CTxDestination,COutput,ListCoins,EXCLUSIVE_LOCKS_REQUIRED,cs_main,cs_wallet,CAmount,GetLegacyBalance,isminefilter,filter,minDepth,CommitTransaction,CTransactionRef,tx,mapValue_t,mapValue,orderForm,CReserveKey,reservekey,CConnman,connman,CValidationState,state,m_allow_fallback_fee,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
#include <string>
                    std::string unused_string;
                    ssValue >> fTmp >> fUnused >> unused_string;
                    strErr = strprintf("LoadWallet() upgrading tx ver=%d %d %s",
                                       wtx.fTimeReceivedIsTxTime, fTmp, hash.ToString());
                strType != "minversion" && strType != "acentry") {
    for (const uint256& hash : wss.vWalletUpgrade)
    for (const uint256& hash : vTxHash) {
    for (const uint256& hash : vTxHash) {

identifier:include,unused_string,ssValue,fTmp,fUnused,unused_string,strErr,strprintf,wtx,fTimeReceivedIsTxTime,fTmp,hash,ToString,strType,strType,uint256,hash,wss,vWalletUpgrade,uint256,hash,vTxHash,uint256,hash,vTxHash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.h
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:faa669cbcd1fc799517b523b0f850e01b11bf40a
commit B:e2213689328f8ba42af1d32d12c7b78a71f1ddc7
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", "Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)", false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:
std::string get_filesystem_error_message(const fs::filesystem_error& e)
{
#ifndef WIN32
    return e.what();
#else
    // Convert from Multi Byte to utf-16
    std::string mb_string(e.what());
    int size = MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), nullptr, 0);

    std::wstring utf16_string(size, L'\0');
    MultiByteToWideChar(CP_ACP, 0, mb_string.c_str(), mb_string.size(), &*utf16_string.begin(), size);
    // Convert from utf-16 to utf-8
    return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t>().to_bytes(utf16_string);
#endif
}


identifier:get_filesystem_error_message,fs::filesystem_error,e,ifndef,WIN32,e,what,mb_string,e,what,size,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,nullptr,utf16_string,size,L,MultiByteToWideChar,CP_ACP,mb_string,c_str,mb_string,size,utf16_string,begin,size,wchar_t,wchar_t,to_bytes,utf16_string,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

    std::string get_filesystem_error_message(const fs::filesystem_error& e);

identifier:get_filesystem_error_message,fs::filesystem_error,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.", false, OptionsCategory::OPTIONS);

    // Only log conf file usage message if conf file actually exists.
    fs::path config_file_path = GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME));
    if (fs::exists(config_file_path)) {
        LogPrintf("Config file: %s\n", config_file_path.string());
    } else if (gArgs.IsArgSet("-conf")) {
        // Warn if no conf file exists at path provided by user
        InitWarning(strprintf(_("The specified config file %s does not exist\n"), config_file_path.string()));
    } else {
        // Not categorizing as "Warning" because it's the default behavior
        LogPrintf("Config file: %s (not found, skipping)\n", config_file_path.string());
    }


identifier:gArgs,AddArg,OptionsCategory::OPTIONS,fs::path,config_file_path,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,fs::exists,config_file_path,LogPrintf,config_file_path,gArgs,IsArgSet,InitWarning,strprintf,_,config_file_path,LogPrintf,config_file_path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61{false};

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,__func__,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.cpp
changed code snippet:
#include <test/gen/crypto_gen.h>

#include <key.h>

#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Predicate.h>
#include <rapidcheck/gen/Container.h>

/** Generates 1 to 20 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys()
{
    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {
        return keys.size() >= 1 && keys.size() <= 15;
    });
};

identifier:include,test,gen,crypto_gen,h,include,key,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Predicate,h,include,rapidcheck,gen,Container,h,rc::Gen,CKey,MultisigKeys,rc::gen::suchThat,rc::gen::arbitrary,CKey,CKey,keys,keys,size,keys,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.h
changed code snippet:
#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H
#define BITCOIN_TEST_GEN_CRYPTO_GEN_H

#include <key.h>
#include <random.h>
#include <uint256.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Create.h>
#include <rapidcheck/gen/Numeric.h>

/** Generates 1 to 15 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys();

namespace rc
{
/** Generator for a new CKey */
template <>
struct Arbitrary<CKey> {
    static Gen<CKey> arbitrary()
    {
        return rc::gen::map<int>([](int x) {
            CKey key;
            key.MakeNewKey(true);
            return key;
        });
    };
};

/** Generator for a CPrivKey */
template <>
struct Arbitrary<CPrivKey> {
    static Gen<CPrivKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPrivKey();
        });
    };
};

/** Generator for a new CPubKey */
template <>
struct Arbitrary<CPubKey> {
    static Gen<CPubKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPubKey();
        });
    };
};
/** Generates a arbitrary uint256 */
template <>
struct Arbitrary<uint256> {
    static Gen<uint256> arbitrary()
    {
        return rc::gen::just(GetRandHash());
    };
};
} //namespace rc
#endif

identifier:ifndef,BITCOIN_TEST_GEN_CRYPTO_GEN_H,define,BITCOIN_TEST_GEN_CRYPTO_GEN_H,include,key,h,include,random,h,include,uint256,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Create,h,include,rapidcheck,gen,Numeric,h,rc::Gen,CKey,MultisigKeys,namespace,rc,template,Arbitrary,CKey,Gen,CKey,arbitrary,rc::gen::map,x,CKey,key,key,MakeNewKey,key,template,Arbitrary,CPrivKey,Gen,CPrivKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPrivKey,template,Arbitrary,CPubKey,Gen,CPubKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPubKey,template,Arbitrary,uint256,Gen,uint256,arbitrary,rc::gen::just,GetRandHash,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_properties.cpp
changed code snippet:
#include <key.h>

#include <base58.h>
#include <script/script.h>
#include <uint256.h>
#include <util.h>
#include <utilstrencodings.h>
#include <test/test_bitcoin.h>
#include <string>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <rapidcheck/boost_test.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>

#include <test/gen/crypto_gen.h>

BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)

/** Check CKey uniqueness */
RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))
{
    RC_ASSERT(!(key1 == key2));
}

/** Verify that a private key generates the correct public key */
RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))
{
    CPubKey pubKey = key.GetPubKey();
    RC_ASSERT(key.VerifyPubKey(pubKey));
}

/** Create a CKey using the 'Set' function must give us the same key */
RC_BOOST_PROP(key_set_symmetry, (const CKey& key))
{
    CKey key1;
    key1.Set(key.begin(), key.end(), key.IsCompressed());
    RC_ASSERT(key1 == key);
}

/** Create a CKey, sign a piece of data, then verify it with the public key */
RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))
{
    std::vector<unsigned char> vchSig;
    key.Sign(hash, vchSig, 0);
    const CPubKey& pubKey = key.GetPubKey();
    RC_ASSERT(pubKey.Verify(hash, vchSig));
}
BOOST_AUTO_TEST_SUITE_END()

identifier:include,key,h,include,base58,h,include,script,script,h,include,uint256,h,include,util,h,include,utilstrencodings,h,include,test,test_bitcoin,h,include,include,include,boost,test,unit_test,hpp,include,rapidcheck,boost_test,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,test,gen,crypto_gen,h,BOOST_FIXTURE_TEST_SUITE,key_properties,BasicTestingSetup,RC_BOOST_PROP,key_uniqueness,CKey,key1,CKey,key2,RC_ASSERT,key1,key2,RC_BOOST_PROP,key_generates_correct_pubkey,CKey,key,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,key,VerifyPubKey,pubKey,RC_BOOST_PROP,key_set_symmetry,CKey,key,CKey,key1,key1,Set,key,begin,key,end,key,IsCompressed,RC_ASSERT,key1,key,RC_BOOST_PROP,key_sign_symmetry,CKey,key,uint256,hash,vchSig,key,Sign,hash,vchSig,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,pubKey,Verify,hash,vchSig,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
static bool validNumStr(const std::string& s)
    std::string tokenVal;
bool UniValue::setNumStr(const std::string& val_)
    std::ostringstream oss;
    std::ostringstream oss;
    std::ostringstream oss;
bool UniValue::setStr(const std::string& val_)

identifier:validNumStr,s,tokenVal,UniValue::setNumStr,val_,oss,oss,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
enum jtokentype getJsonToken(std::string& tokenVal, unsigned int& consumed,
        std::string numStr;
        std::string valStr;
    std::vector<UniValue*> stack;
    std::string tokenVal;

identifier:jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
static std::string json_escape(const std::string& inS)
    std::string outS;
std::string UniValue::write(unsigned int prettyIndent,
                            unsigned int indentLevel) const
    std::string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, std::string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const

identifier:json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
std::string srcdir(JSON_TEST_SRC);
static void runtest(std::string filename, const std::string& jdata)
        std::string prefix = filename.substr(0, 4);
        std::string basename(filename_);
        std::string filename = srcdir + "/" + basename;
        std::string jdata;
                std::string s(buf, bread);

identifier:srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), fsbridge::get_filesystem_error_message(e));

identifier:LogPrintf,strFile,pathDest,fsbridge::get_filesystem_error_message,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            encrypted_batch = nullptr;
            encrypted_batch = nullptr;
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, fsbridge::get_filesystem_error_message(e));

identifier:encrypted_batch,nullptr,encrypted_batch,nullptr,error_string,strprintf,wallet_file,fsbridge::get_filesystem_error_message,e,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e2213689328f8ba42af1d32d12c7b78a71f1ddc7
commit B:7d038dcb41d93ea0b7401140998225adaab8c065
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", _("Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"), false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,_,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

#include <stdio.h>
#include <util.h>
#include <walletinitinterface.h>

class DummyWalletInit : public WalletInitInterface {
public:

    bool HasWalletSupport() const override {return false;}
    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();

identifier:include,stdio,h,include,util,h,include,walletinitinterface,h,class,DummyWalletInit,public,WalletInitInterface,public,HasWalletSupport,override,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/fs.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#include <walletinitinterface.h>
    if (g_wallet_init_interface.HasWalletSupport()) {
        RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
    }
    if (g_wallet_init_interface.HasWalletSupport()) {
        UnregisterHTTPHandler("/wallet/", false);
    }

identifier:include,walletinitinterface,h,g_wallet_init_interface,HasWalletSupport,RegisterHTTPHandler,HTTPReq_JSONRPC,g_wallet_init_interface,HasWalletSupport,UnregisterHTTPHandler,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);
    LogPrintf("Using config file %s\n", GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME)).string());

identifier:gArgs,AddArg,OptionsCategory::OPTIONS,LogPrintf,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/protocol.cpp
changed code snippet:
        LogPrintf("%s: Unable to remove random auth cookie file: %s\n", __func__, e.what());

identifier:LogPrintf,__func__,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:
using namespace std;


identifier:using,namespace,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:
#include <utility>        // std::pair
    bool push_back(std::pair<std::string,UniValue> pear) {
        return pushKV(pear.first, pear.second);
    }
static inline std::pair<std::string,UniValue> Pair(const char *cKey, const char *cVal)
{
    std::string key(cKey);
    UniValue uVal(cVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, std::string strVal)
{
    std::string key(cKey);
    UniValue uVal(strVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, uint64_t u64Val)
{
    std::string key(cKey);
    UniValue uVal(u64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int64_t i64Val)
{
    std::string key(cKey);
    UniValue uVal(i64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, bool iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, double dVal)
{
    std::string key(cKey);
    UniValue uVal(dVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, const UniValue& uVal)
{
    std::string key(cKey);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(std::string key, const UniValue& uVal)
{
    return std::make_pair(key, uVal);
}


identifier:include,utility,push_back,UniValue,pear,pushKV,pear,first,pear,second,inline,UniValue,Pair,cKey,cVal,key,cKey,UniValue,uVal,cVal,key,uVal,inline,UniValue,Pair,cKey,strVal,key,cKey,UniValue,uVal,strVal,key,uVal,inline,UniValue,Pair,cKey,uint64_t,u64Val,key,cKey,UniValue,uVal,u64Val,key,uVal,inline,UniValue,Pair,cKey,int64_t,i64Val,key,cKey,UniValue,uVal,i64Val,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,dVal,key,cKey,UniValue,uVal,dVal,key,uVal,inline,UniValue,Pair,cKey,UniValue,uVal,key,cKey,key,uVal,inline,UniValue,Pair,key,UniValue,uVal,key,uVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
using namespace std;

static bool validNumStr(const string& s)
    string tokenVal;
bool UniValue::setNumStr(const string& val_)
    ostringstream oss;
    ostringstream oss;
    ostringstream oss;
bool UniValue::setStr(const string& val_)

identifier:using,namespace,validNumStr,s,tokenVal,UniValue::setNumStr,val_,ostringstream,oss,ostringstream,oss,ostringstream,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
using namespace std;

enum jtokentype getJsonToken(string& tokenVal, unsigned int& consumed,
        string numStr;
        string valStr;
    vector<UniValue*> stack;
    string tokenVal;

identifier:using,namespace,jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
using namespace std;

static string json_escape(const string& inS)
    string outS;
string UniValue::write(unsigned int prettyIndent,
                       unsigned int indentLevel) const
    string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, string& s) const

identifier:using,namespace,json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
using namespace std;
string srcdir(JSON_TEST_SRC);
static void runtest(string filename, const string& jdata)
        string prefix = filename.substr(0, 4);
        string basename(filename_);
        string filename = srcdir + "/" + basename;
        string jdata;
                string s(buf, bread);

identifier:using,namespace,srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
                    LogPrintf("error copying %s to %s - %s\n", strFile, pathDest.string(), e.what());

identifier:LogPrintf,strFile,pathDest,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:
    //! Was the wallet component compiled in.
    bool HasWalletSupport() const override {return true;}


identifier:HasWalletSupport,override,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
        error_string = strprintf("Error loading wallet %s. %s", wallet_file, e.what());

identifier:error_string,strprintf,wallet_file,e,what,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:
    /** Is the wallet component enabled */
    virtual bool HasWalletSupport() const = 0;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:virtual,HasWalletSupport,WalletInitInterface,g_wallet_init_interface,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:7d038dcb41d93ea0b7401140998225adaab8c065
commit B:eb2f1bd276108e70aff0f582a407e9b702eb4dd1
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", "Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)", false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx    transaction for which we are checking input total
     * @return  Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/httprpc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
    // ifdef can be removed once we switch to better endpoint support and API versioning
    RegisterHTTPHandler("/wallet/", false, HTTPReq_JSONRPC);
#endif
#ifdef ENABLE_WALLET
    UnregisterHTTPHandler("/wallet/", false);
#endif

identifier:ifdef,ENABLE_WALLET,RegisterHTTPHandler,HTTPReq_JSONRPC,endif,ifdef,ENABLE_WALLET,UnregisterHTTPHandler,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
#if !(ENABLE_WALLET)
class DummyWalletInit : public WalletInitInterface {
public:

    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();
#endif

    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.", false, OptionsCategory::OPTIONS);

    // Only log conf file usage message if conf file actually exists.
    fs::path config_file_path = GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME));
    if (fs::exists(config_file_path)) {
        LogPrintf("Config file: %s\n", config_file_path.string());
    } else if (gArgs.IsArgSet("-conf")) {
        // Warn if no conf file exists at path provided by user
        InitWarning(strprintf(_("The specified config file %s does not exist\n"), config_file_path.string()));
    } else {
        // Not categorizing as "Warning" because it's the default behavior
        LogPrintf("Config file: %s (not found, skipping)\n", config_file_path.string());
    }


identifier:ENABLE_WALLET,class,DummyWalletInit,public,WalletInitInterface,public,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,endif,gArgs,AddArg,OptionsCategory::OPTIONS,fs::path,config_file_path,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,fs::exists,config_file_path,LogPrintf,config_file_path,gArgs,IsArgSet,InitWarning,strprintf,_,config_file_path,LogPrintf,config_file_path,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.h
changed code snippet:
class WalletInitInterface;
extern const WalletInitInterface& g_wallet_init_interface;


identifier:class,WalletInitInterface,WalletInitInterface,g_wallet_init_interface,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
#elif (HAVE_DECL_GETIFADDRS && HAVE_DECL_FREEIFADDRS)

identifier:elif,HAVE_DECL_GETIFADDRS,HAVE_DECL_FREEIFADDRS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61{false};

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.cpp
changed code snippet:
#include <test/gen/crypto_gen.h>

#include <key.h>

#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Predicate.h>
#include <rapidcheck/gen/Container.h>

/** Generates 1 to 20 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys()
{
    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {
        return keys.size() >= 1 && keys.size() <= 15;
    });
};

identifier:include,test,gen,crypto_gen,h,include,key,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Predicate,h,include,rapidcheck,gen,Container,h,rc::Gen,CKey,MultisigKeys,rc::gen::suchThat,rc::gen::arbitrary,CKey,CKey,keys,keys,size,keys,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.h
changed code snippet:
#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H
#define BITCOIN_TEST_GEN_CRYPTO_GEN_H

#include <key.h>
#include <random.h>
#include <uint256.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Create.h>
#include <rapidcheck/gen/Numeric.h>

/** Generates 1 to 15 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys();

namespace rc
{
/** Generator for a new CKey */
template <>
struct Arbitrary<CKey> {
    static Gen<CKey> arbitrary()
    {
        return rc::gen::map<int>([](int x) {
            CKey key;
            key.MakeNewKey(true);
            return key;
        });
    };
};

/** Generator for a CPrivKey */
template <>
struct Arbitrary<CPrivKey> {
    static Gen<CPrivKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPrivKey();
        });
    };
};

/** Generator for a new CPubKey */
template <>
struct Arbitrary<CPubKey> {
    static Gen<CPubKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPubKey();
        });
    };
};
/** Generates a arbitrary uint256 */
template <>
struct Arbitrary<uint256> {
    static Gen<uint256> arbitrary()
    {
        return rc::gen::just(GetRandHash());
    };
};
} //namespace rc
#endif

identifier:ifndef,BITCOIN_TEST_GEN_CRYPTO_GEN_H,define,BITCOIN_TEST_GEN_CRYPTO_GEN_H,include,key,h,include,random,h,include,uint256,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Create,h,include,rapidcheck,gen,Numeric,h,rc::Gen,CKey,MultisigKeys,namespace,rc,template,Arbitrary,CKey,Gen,CKey,arbitrary,rc::gen::map,x,CKey,key,key,MakeNewKey,key,template,Arbitrary,CPrivKey,Gen,CPrivKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPrivKey,template,Arbitrary,CPubKey,Gen,CPubKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPubKey,template,Arbitrary,uint256,Gen,uint256,arbitrary,rc::gen::just,GetRandHash,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_properties.cpp
changed code snippet:
#include <key.h>

#include <base58.h>
#include <script/script.h>
#include <uint256.h>
#include <util.h>
#include <utilstrencodings.h>
#include <test/test_bitcoin.h>
#include <string>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <rapidcheck/boost_test.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>

#include <test/gen/crypto_gen.h>

BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)

/** Check CKey uniqueness */
RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))
{
    RC_ASSERT(!(key1 == key2));
}

/** Verify that a private key generates the correct public key */
RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))
{
    CPubKey pubKey = key.GetPubKey();
    RC_ASSERT(key.VerifyPubKey(pubKey));
}

/** Create a CKey using the 'Set' function must give us the same key */
RC_BOOST_PROP(key_set_symmetry, (const CKey& key))
{
    CKey key1;
    key1.Set(key.begin(), key.end(), key.IsCompressed());
    RC_ASSERT(key1 == key);
}

/** Create a CKey, sign a piece of data, then verify it with the public key */
RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))
{
    std::vector<unsigned char> vchSig;
    key.Sign(hash, vchSig, 0);
    const CPubKey& pubKey = key.GetPubKey();
    RC_ASSERT(pubKey.Verify(hash, vchSig));
}
BOOST_AUTO_TEST_SUITE_END()

identifier:include,key,h,include,base58,h,include,script,script,h,include,uint256,h,include,util,h,include,utilstrencodings,h,include,test,test_bitcoin,h,include,include,include,boost,test,unit_test,hpp,include,rapidcheck,boost_test,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,test,gen,crypto_gen,h,BOOST_FIXTURE_TEST_SUITE,key_properties,BasicTestingSetup,RC_BOOST_PROP,key_uniqueness,CKey,key1,CKey,key2,RC_ASSERT,key1,key2,RC_BOOST_PROP,key_generates_correct_pubkey,CKey,key,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,key,VerifyPubKey,pubKey,RC_BOOST_PROP,key_set_symmetry,CKey,key,CKey,key1,key1,Set,key,begin,key,end,key,IsCompressed,RC_ASSERT,key1,key,RC_BOOST_PROP,key_sign_symmetry,CKey,key,uint256,hash,vchSig,key,Sign,hash,vchSig,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,pubKey,Verify,hash,vchSig,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            boost::optional<txiter> piter = GetIter(tx.vin[i].prevout.hash);
            if (piter) {
                parentHashes.insert(*piter);
    CAmount delta{0};
    ApplyDelta(entry.GetTx().GetHash(), delta);
    if (delta) {
    for (const auto& pit : GetIterSet(setParentTransactions)) {
const CTransaction* CTxMemPool::GetConflictTx(const COutPoint& prevout) const
{
    const auto it = mapNextTx.find(prevout);
    return it == mapNextTx.end() ? nullptr : it->second;
}

boost::optional<CTxMemPool::txiter> CTxMemPool::GetIter(const uint256& txid) const
{
    auto it = mapTx.find(txid);
    if (it != mapTx.end()) return it;
    return boost::optional<txiter>{};
}

CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) const
{
    CTxMemPool::setEntries ret;
    for (const auto& h : hashes) {
        const auto mi = GetIter(h);
        if (mi) ret.insert(*mi);
    }
    return ret;
}


identifier:boost::optional,txiter,piter,GetIter,tx,vin,i,prevout,hash,piter,parentHashes,insert,piter,CAmount,delta,ApplyDelta,entry,GetTx,GetHash,delta,delta,pit,GetIterSet,setParentTransactions,CTransaction,CTxMemPool::GetConflictTx,COutPoint,prevout,it,mapNextTx,find,prevout,it,mapNextTx,end,nullptr,it,second,boost::optional,CTxMemPool::txiter,CTxMemPool::GetIter,uint256,txid,it,mapTx,find,txid,it,mapTx,end,it,boost::optional,txiter,CTxMemPool::setEntries,CTxMemPool::GetIterSet,uint256,hashes,CTxMemPool::setEntries,ret,h,hashes,mi,GetIter,h,mi,ret,insert,mi,ret,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
    /** Get the transaction in the pool that spends the same prevout */
    const CTransaction* GetConflictTx(const COutPoint& prevout) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Returns an iterator to the given hash, if found */
    boost::optional<txiter> GetIter(const uint256& txid) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    /** Translate a set of hashes into a set of pool iterators to avoid repeated lookups */
    setEntries GetIterSet(const std::set<uint256>& hashes) const EXCLUSIVE_LOCKS_REQUIRED(cs);

    bool exists(const uint256& hash) const

identifier:CTransaction,GetConflictTx,COutPoint,prevout,EXCLUSIVE_LOCKS_REQUIRED,cs,boost::optional,txiter,GetIter,uint256,txid,EXCLUSIVE_LOCKS_REQUIRED,cs,setEntries,GetIterSet,uint256,hashes,EXCLUSIVE_LOCKS_REQUIRED,cs,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
static bool validNumStr(const std::string& s)
    std::string tokenVal;
bool UniValue::setNumStr(const std::string& val_)
    std::ostringstream oss;
    std::ostringstream oss;
    std::ostringstream oss;
bool UniValue::setStr(const std::string& val_)

identifier:validNumStr,s,tokenVal,UniValue::setNumStr,val_,oss,oss,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
enum jtokentype getJsonToken(std::string& tokenVal, unsigned int& consumed,
        std::string numStr;
        std::string valStr;
    std::vector<UniValue*> stack;
    std::string tokenVal;

identifier:jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
static std::string json_escape(const std::string& inS)
    std::string outS;
std::string UniValue::write(unsigned int prettyIndent,
                            unsigned int indentLevel) const
    std::string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, std::string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, std::string& s) const

identifier:json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
std::string srcdir(JSON_TEST_SRC);
static void runtest(std::string filename, const std::string& jdata)
        std::string prefix = filename.substr(0, 4);
        std::string basename(filename_);
        std::string filename = srcdir + "/" + basename;
        std::string jdata;
                std::string s(buf, bread);

identifier:srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        const CTransaction* ptxConflicting = pool.GetConflictTx(txin.prevout);
        if (ptxConflicting) {
            const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);
            for (const auto& mi : setIterConflicting) {
                    if (pool.exists(tx.vin[j].prevout.hash)) {
                    }

identifier:CTransaction,ptxConflicting,pool,GetConflictTx,txin,prevout,ptxConflicting,CTxMemPool::setEntries,setIterConflicting,pool,GetIterSet,setConflicts,mi,setIterConflicting,pool,exists,tx,vin,j,prevout,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/init.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
            if (!ExtractDestination(script, dest) && !internal) {
                throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set to true for nonstandard scriptPubKey imports.");
            }
                if (!(pubkey_dest == dest)) {
                if (!(pubkey_dest == dest)) {
                // add to address book or update label
                if (IsValidDestination(dest)) {
                    pwallet->SetAddressBook(dest, label, "receive");

identifier:ExtractDestination,script,dest,internal,throw,JSONRPCError,RPC_INVALID_PARAMETER,pubkey_dest,dest,pubkey_dest,dest,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
            encrypted_batch = nullptr;
            encrypted_batch = nullptr;

identifier:encrypted_batch,nullptr,encrypted_batch,nullptr,
++@DIFF ENTRY SEPERATOR@++
changed file:src/walletinitinterface.h
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:13c842e02816e5bdd7e6dd4d3a60482d9f272708
commit B:e0a4f9de7fbb675dcc7207f91b60b66f14dc227a
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
        // Not having Internal + Script
        if (!internal && isScript) {
            throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal must be set for hex scriptPubKey");
        }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (!isScript && !(pubkey_dest == dest)) {
                // Consistency check.
                if (isScript) {
                    CTxDestination destination;

                    if (ExtractDestination(script, destination)) {
                        if (!(destination == pubkey_dest)) {
                            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Consistency check failed");
                        }
                    }
                }

                if (scriptPubKey.getType() == UniValue::VOBJ) {
                    // add to address book or update label
                    if (IsValidDestination(dest)) {
                        pwallet->SetAddressBook(dest, label, "receive");
                    }

identifier:internal,isScript,throw,JSONRPCError,RPC_INVALID_PARAMETER,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,isScript,pubkey_dest,dest,isScript,CTxDestination,destination,ExtractDestination,script,destination,destination,pubkey_dest,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,scriptPubKey,getType,UniValue::VOBJ,IsValidDestination,dest,pwallet,SetAddressBook,dest,label,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:e0a4f9de7fbb675dcc7207f91b60b66f14dc227a
commit B:838b85e120fd7957cf4abce0905d3aff96fa7278
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
            txiter piter = mapTx.find(tx.vin[i].prevout.hash);
            if (piter != mapTx.end()) {
                parentHashes.insert(piter);
    std::map<uint256, CAmount>::const_iterator pos = mapDeltas.find(entry.GetTx().GetHash());
    if (pos != mapDeltas.end()) {
        const CAmount &delta = pos->second;
        if (delta) {
        }
    for (const uint256 &phash : setParentTransactions) {
        txiter pit = mapTx.find(phash);
        if (pit != mapTx.end()) {
        }

identifier:txiter,piter,mapTx,find,tx,vin,i,prevout,hash,piter,mapTx,end,parentHashes,insert,piter,uint256,CAmount,const_iterator,pos,mapDeltas,find,entry,GetTx,GetHash,pos,mapDeltas,end,CAmount,delta,pos,second,delta,uint256,phash,setParentTransactions,txiter,pit,mapTx,find,phash,pit,mapTx,end,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.h
changed code snippet:
public:
    bool exists(uint256 hash) const

identifier:public,exists,uint256,hash,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
        auto itConflicting = pool.mapNextTx.find(txin.prevout);
        if (itConflicting != pool.mapNextTx.end())
        {
            const CTransaction *ptxConflicting = itConflicting->second;
            CTxMemPool::setEntries setIterConflicting;
            for (const uint256 &hashConflicting : setConflicts)
            {
                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);
                if (mi == pool.mapTx.end())
                    continue;

                // Save these to avoid repeated lookups
                setIterConflicting.insert(mi);

                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())

identifier:itConflicting,pool,mapNextTx,find,txin,prevout,itConflicting,pool,mapNextTx,end,CTransaction,ptxConflicting,itConflicting,second,CTxMemPool::setEntries,setIterConflicting,uint256,hashConflicting,setConflicts,CTxMemPool::txiter,mi,pool,mapTx,find,hashConflicting,mi,pool,mapTx,end,setIterConflicting,insert,mi,pool,mapTx,find,tx,vin,j,prevout,hash,pool,mapTx,end,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:838b85e120fd7957cf4abce0905d3aff96fa7278
commit B:7c7bb6e7726a13443a9ad0231808f2858636b39f
++@DIFF ENTRY SEPERATOR@++
changed file:src/coins.h
changed code snippet:
     * @param[in] tx	transaction for which we are checking input total
     * @return	Sum of value of all inputs (scriptSigs)

identifier:param,in,tx,transaction,which,we,are,checking,input,total,Sum,of,value,of,all,inputs,scriptSigs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/client.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/server.cpp
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:7c7bb6e7726a13443a9ad0231808f2858636b39f
commit B:6eeac2e628b5332dcaee60e5c83861c94e44d04d
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
#else

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:6eeac2e628b5332dcaee60e5c83861c94e44d04d
commit B:321075609d23a1e23b7b905294516a497c14d07d
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:

identifier:
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:321075609d23a1e23b7b905294516a497c14d07d
commit B:e5eb8ba564144bb8e772d49c2aa7e4f22e37af7e
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;

identifier:constexpr,DEFAULT_ENABLE_BIP61,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:793d2b74306d6628ef5b92dce9a081f8951efc2d
commit B:fbfa2e46ff7387b15c0e231bab00917a8cbbe3e2
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/gen/gen.cpp
changed code snippet:
using namespace std;


identifier:using,namespace,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/include/univalue.h
changed code snippet:
#include <utility>        // std::pair
    bool push_back(std::pair<std::string,UniValue> pear) {
        return pushKV(pear.first, pear.second);
    }
static inline std::pair<std::string,UniValue> Pair(const char *cKey, const char *cVal)
{
    std::string key(cKey);
    UniValue uVal(cVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, std::string strVal)
{
    std::string key(cKey);
    UniValue uVal(strVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, uint64_t u64Val)
{
    std::string key(cKey);
    UniValue uVal(u64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int64_t i64Val)
{
    std::string key(cKey);
    UniValue uVal(i64Val);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, bool iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, int iVal)
{
    std::string key(cKey);
    UniValue uVal(iVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, double dVal)
{
    std::string key(cKey);
    UniValue uVal(dVal);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(const char *cKey, const UniValue& uVal)
{
    std::string key(cKey);
    return std::make_pair(key, uVal);
}

static inline std::pair<std::string,UniValue> Pair(std::string key, const UniValue& uVal)
{
    return std::make_pair(key, uVal);
}


identifier:include,utility,push_back,UniValue,pear,pushKV,pear,first,pear,second,inline,UniValue,Pair,cKey,cVal,key,cKey,UniValue,uVal,cVal,key,uVal,inline,UniValue,Pair,cKey,strVal,key,cKey,UniValue,uVal,strVal,key,uVal,inline,UniValue,Pair,cKey,uint64_t,u64Val,key,cKey,UniValue,uVal,u64Val,key,uVal,inline,UniValue,Pair,cKey,int64_t,i64Val,key,cKey,UniValue,uVal,i64Val,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,iVal,key,cKey,UniValue,uVal,iVal,key,uVal,inline,UniValue,Pair,cKey,dVal,key,cKey,UniValue,uVal,dVal,key,uVal,inline,UniValue,Pair,cKey,UniValue,uVal,key,cKey,key,uVal,inline,UniValue,Pair,key,UniValue,uVal,key,uVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue.cpp
changed code snippet:
using namespace std;

static bool validNumStr(const string& s)
    string tokenVal;
bool UniValue::setNumStr(const string& val_)
    ostringstream oss;
    ostringstream oss;
    ostringstream oss;
bool UniValue::setStr(const string& val_)

identifier:using,namespace,validNumStr,s,tokenVal,UniValue::setNumStr,val_,ostringstream,oss,ostringstream,oss,ostringstream,oss,UniValue::setStr,val_,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_read.cpp
changed code snippet:
using namespace std;

enum jtokentype getJsonToken(string& tokenVal, unsigned int& consumed,
        string numStr;
        string valStr;
    vector<UniValue*> stack;
    string tokenVal;

identifier:using,namespace,jtokentype,getJsonToken,tokenVal,consumed,numStr,valStr,UniValue,stack,tokenVal,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/lib/univalue_write.cpp
changed code snippet:
using namespace std;

static string json_escape(const string& inS)
    string outS;
string UniValue::write(unsigned int prettyIndent,
                       unsigned int indentLevel) const
    string s;
static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, string& s)
void UniValue::writeArray(unsigned int prettyIndent, unsigned int indentLevel, string& s) const
void UniValue::writeObject(unsigned int prettyIndent, unsigned int indentLevel, string& s) const

identifier:using,namespace,json_escape,inS,outS,UniValue::write,prettyIndent,indentLevel,s,indentStr,prettyIndent,indentLevel,s,UniValue::writeArray,prettyIndent,indentLevel,s,UniValue::writeObject,prettyIndent,indentLevel,s,
++@DIFF ENTRY SEPERATOR@++
changed file:src/univalue/test/unitester.cpp
changed code snippet:
using namespace std;
string srcdir(JSON_TEST_SRC);
static void runtest(string filename, const string& jdata)
        string prefix = filename.substr(0, 4);
        string basename(filename_);
        string filename = srcdir + "/" + basename;
        string jdata;
                string s(buf, bread);

identifier:using,namespace,srcdir,JSON_TEST_SRC,runtest,filename,jdata,prefix,filename,substr,basename,filename_,filename,srcdir,basename,jdata,s,buf,bread,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:fbfa2e46ff7387b15c0e231bab00917a8cbbe3e2
commit B:ae251fa2aae89acb10b65aafe0b52c48e97b6b00
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    LogPrintf("Using config file %s\n", GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME)).string());

identifier:LogPrintf,GetConfigFile,gArgs,GetArg,BITCOIN_CONF_FILENAME,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:bc8aa2ba7879b25b90a36413e3bf6842b2527a4b
commit B:7177e093f9e4ae0dcf1bb46e93cb15d367d3dad5
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpccookiefile=<loc>", _("Location of the auth cookie. Relative paths will be prefixed by a net-specific datadir location. (default: data dir)"), false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,_,OptionsCategory::OPTIONS,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:7177e093f9e4ae0dcf1bb46e93cb15d367d3dad5
commit B:faea5bfc5a975874acf763082852ed532ed81a95
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (auto v_i : v) {
    for (auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:
#include <consensus/merkle.h>
#include <chainparamsseeds.h>

/**
 * What makes a good checkpoint block?
 * + Is surrounded by blocks with reasonable timestamps
 *   (no blocks before with a timestamp after, none after with
 *    timestamp before)
 * + Contains no strange transactions
 */


identifier:include,consensus,merkle,h,include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (uint32_t loc : locs)
            for (uint32_t loc : locs) {
        for (uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmaped).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    std::mutex cs;
        std::unique_lock<std::mutex> lock(cs);
                std::unique_lock<std::mutex> lock(cs);
        std::unique_lock<std::mutex> lock(cs);

identifier:cs,lock,cs,lock,cs,lock,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (0 to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -connect=0 disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u or testnet: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u)", defaultChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", strprintf("Output debugging information (default: %u, supplying <category> is optional)", 0) + ". " +
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set debuglogfile=0)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()), false, OptionsCategory::RPC);
static CWaitableCriticalSection cs_GenesisWait;
static CConditionVariable condvar_GenesisWait;
            WaitableLock lock_GenesisWait(cs_GenesisWait);
        condvar_GenesisWait.notify_all();
        WaitableLock lock(cs_GenesisWait);
            condvar_GenesisWait.wait_for(lock, std::chrono::milliseconds(500));

identifier:gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,OptionsCategory::RPC,CWaitableCriticalSection,cs_GenesisWait,CConditionVariable,condvar_GenesisWait,WaitableLock,lock_GenesisWait,cs_GenesisWait,condvar_GenesisWait,notify_all,WaitableLock,lock,cs_GenesisWait,condvar_GenesisWait,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(nPrevNodeCount);
        for (auto pnode : vNodes) {
        for (CNode* pnode : vNodes) {
            for (CNode* pnode : vNodes) {
        std::unique_lock<std::mutex> lock(mutexMsgProc);
        std::unique_lock<std::mutex> lock(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,nPrevNodeCount,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,lock,mutexMsgProc,lock,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    std::mutex mutexMsgProc;

identifier:mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
        for (uint256 &orphanHash : vOrphanErase) {
            for (uint256 hash : vEraseQueue)

identifier:uint256,orphanHash,vOrphanErase,uint256,hash,vEraseQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61{false};

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    for (WalletModel *walletModel : m_wallet_models) {

identifier:WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of miliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,miliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (float f : vSamplesIn) {
    for (float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (isminetype mine : wtx.txin_is_mine)
        for (isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
static std::mutex cs_rng_state;
        std::unique_lock<std::mutex> lock(cs_rng_state);
        std::unique_lock<std::mutex> lock(cs_rng_state);

identifier:cs_rng_state,lock,cs_rng_state,lock,cs_rng_state,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure& e) {

identifier:e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static std::mutex cs_blockchange;
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
        std::unique_lock<std::mutex> lock(cs_blockchange);
    for (const CTxMemPool::txiter &childiter : setChildren) {
            "For more information on output descriptors, see the documentation at TODO\n"

identifier:cs_blockchange,lock,cs_blockchange,lock,cs_blockchange,lock,cs_blockchange,CTxMemPool::txiter,childiter,setChildren,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index, or the chain tip if
 * not provided.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,or,the,chain,tip,not,provided,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WaitableLock lock(g_best_block_mutex);
    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WaitableLock,lock,g_best_block_mutex,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#include <wallet/wallet.h>
#include <wallet/walletdb.h>
#endif
#ifdef ENABLE_WALLET
        if (HasWallets() && IsDeprecatedRPCEnabled("validateaddress")) {
            ret.pushKVs(getaddressinfo(request));
        }
#endif
        if (ret["address"].isNull()) {
            std::string currentAddress = EncodeDestination(dest);
            ret.pushKV("address", currentAddress);
            CScript scriptPubKey = GetScriptForDestination(dest);
            ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));

            UniValue detail = DescribeAddress(dest);
            ret.pushKVs(detail);
        }
class CWallet;

            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\nNote that from v0.16, createmultisig no longer accepts addresses."
            " Users must use addmultisigaddress to create multisig addresses with addresses known to the wallet.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,include,wallet,wallet,h,include,wallet,walletdb,h,endif,ifdef,ENABLE_WALLET,HasWallets,IsDeprecatedRPCEnabled,ret,pushKVs,getaddressinfo,request,endif,ret,isNull,currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,class,CWallet,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
#ifdef ENABLE_WALLET
#include <wallet/rpcwallet.h>
#endif
            // if redeemScript given and not using the local wallet (private keys
            // given), add redeemScript to the keystore so it can be signed:
#ifdef ENABLE_WALLET
    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);
    CWallet* const pwallet = wallet.get();
#endif

    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)
        throw std::runtime_error(
            "signrawtransaction \"hexstring\" ( [{\"txid\":\"id\",\"vout\":n,\"scriptPubKey\":\"hex\",\"redeemScript\":\"hex\"},...] [\"privatekey1\",...] sighashtype )\n"
            "\nDEPRECATED. Sign inputs for raw transaction (serialized, hex-encoded).\n"
            "The second optional argument (may be null) is an array of previous transaction outputs that\n"
            "this transaction depends on but may not yet be in the block chain.\n"
            "The third optional argument (may be null) is an array of base58-encoded private\n"
            "keys that, if given, will be the only keys used to sign the transaction.\n"
#ifdef ENABLE_WALLET
            + HelpRequiringPassphrase(pwallet) + "\n"
#endif
            "\nArguments:\n"
            "1. \"hexstring\"     (string, required) The transaction hex string\n"
            "2. \"prevtxs\"       (string, optional) An json array of previous dependent transaction outputs\n"
            "     [               (json array of json objects, or 'null' if none provided)\n"
            "       {\n"
            "         \"txid\":\"id\",             (string, required) The transaction id\n"
            "         \"vout\":n,                  (numeric, required) The output number\n"
            "         \"scriptPubKey\": \"hex\",   (string, required) script key\n"
            "         \"redeemScript\": \"hex\",   (string, required for P2SH or P2WSH) redeem script\n"
            "         \"amount\": value            (numeric, required) The amount spent\n"
            "       }\n"
            "       ,...\n"
            "    ]\n"
            "3. \"privkeys\"     (string, optional) A json array of base58-encoded private keys for signing\n"
            "    [                  (json array of strings, or 'null' if none provided)\n"
            "      \"privatekey\"   (string) private key in base58-encoding\n"
            "      ,...\n"
            "    ]\n"
            "4. \"sighashtype\"     (string, optional, default=ALL) The signature hash type. Must be one of\n"
            "       \"ALL\"\n"
            "       \"NONE\"\n"
            "       \"SINGLE\"\n"
            "       \"ALL|ANYONECANPAY\"\n"
            "       \"NONE|ANYONECANPAY\"\n"
            "       \"SINGLE|ANYONECANPAY\"\n"

            "\nResult:\n"
            "{\n"
            "  \"hex\" : \"value\",           (string) The hex-encoded raw transaction with signature(s)\n"
            "  \"complete\" : true|false,   (boolean) If the transaction has a complete set of signatures\n"
            "  \"errors\" : [                 (json array of objects) Script verification errors (if there are any)\n"
            "    {\n"
            "      \"txid\" : \"hash\",           (string) The hash of the referenced, previous transaction\n"
            "      \"vout\" : n,                (numeric) The index of the output to spent and used as input\n"
            "      \"scriptSig\" : \"hex\",       (string) The hex-encoded signature script\n"
            "      \"sequence\" : n,            (numeric) Script sequence number\n"
            "      \"error\" : \"text\"           (string) Verification or signing error related to the input\n"
            "    }\n"
            "    ,...\n"
            "  ]\n"
            "}\n"

            "\nExamples:\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"")
            + HelpExampleRpc("signrawtransaction", "\"myhex\"")
        );

    if (!IsDeprecatedRPCEnabled("signrawtransaction")) {
        throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction is deprecated and will be fully removed in v0.18. "
            "To use signrawtransaction in v0.17, restart bitcoind with -deprecatedrpc=signrawtransaction.\n"
            "Projects should transition to using signrawtransactionwithkey and signrawtransactionwithwallet before upgrading to v0.18");
    }

    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);

    // Make a JSONRPCRequest to pass on to the right signrawtransaction* command
    JSONRPCRequest new_request;
    new_request.id = request.id;
    new_request.params.setArray();

    // For signing with private keys
    if (!request.params[2].isNull()) {
        new_request.params.push_back(request.params[0]);
        // Note: the prevtxs and privkeys are reversed for signrawtransactionwithkey
        new_request.params.push_back(request.params[2]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithkey(new_request);
    } else {
#ifdef ENABLE_WALLET
        // Otherwise sign with the wallet which does not take a privkeys parameter
        new_request.params.push_back(request.params[0]);
        new_request.params.push_back(request.params[1]);
        new_request.params.push_back(request.params[3]);
        return signrawtransactionwithwallet(new_request);
#else
        // If we have made it this far, then wallet is disabled and no private keys were given, so fail here.
        throw JSONRPCError(RPC_INVALID_PARAMETER, "No private keys available.");
#endif
    }
            "\nAlso see createrawtransaction and signrawtransaction calls.\n"
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
            + HelpExampleCli("signrawtransaction", "\"myhex\"") +
                            "                              will be tried. If false, only non-witness deserialization wil be tried. Only has an effect if\n"
    { "rawtransactions",    "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} }, /* uses wallet if enabled */

identifier:ifdef,ENABLE_WALLET,include,wallet,rpcwallet,h,endif,ifdef,ENABLE_WALLET,CWallet,wallet,GetWalletForJSONRPCRequest,request,CWallet,pwallet,wallet,get,endif,request,fHelp,request,params,size,request,params,size,throw,ifdef,ENABLE_WALLET,HelpRequiringPassphrase,pwallet,endif,HelpExampleCli,HelpExampleRpc,IsDeprecatedRPCEnabled,throw,JSONRPCError,RPC_METHOD_DEPRECATED,RPCTypeCheck,request,params,UniValue::VSTR,UniValue::VARR,UniValue::VARR,UniValue::VSTR,JSONRPCRequest,new_request,new_request,id,request,id,new_request,params,setArray,request,params,isNull,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithkey,new_request,ifdef,ENABLE_WALLET,new_request,params,push_back,request,params,new_request,params,push_back,request,params,new_request,params,push_back,request,params,signrawtransactionwithwallet,new_request,throw,JSONRPCError,RPC_INVALID_PARAMETER,endif,HelpExampleCli,HelpExampleCli,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practially, this means that callbacks can behave as if they are executed

identifier:Practially,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */
/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
     * in the nbits least signficant bits of a 64-bit uint.

identifier:in,the,nbits,least,signficant,bits,of,a,bit,uint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto alloced = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(alloced->first);

identifier:alloced,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,alloced,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    assert(false);

identifier:assert,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
 * Template mixin that adds -Wthread-safety locking
 * annotations to a subset of the mutex API.
};
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)
class CCriticalSection : public AnnotatedMixin<std::recursive_mutex>
{
public:
    ~CCriticalSection() {
        DeleteLock((void*)this);
    }
};
typedef AnnotatedMixin<std::mutex> CWaitableCriticalSection;

/** Just a typedef for std::condition_variable, can be wrapped later if desired */
typedef std::condition_variable CConditionVariable;

/** Just a typedef for std::unique_lock, can be wrapped later if desired */
typedef std::unique_lock<std::mutex> WaitableLock;
/** Wrapper around std::unique_lock<CCriticalSection> */
class SCOPED_LOCKABLE CCriticalBlock
    std::unique_lock<CCriticalSection> lock;

        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));
        if (!lock.try_lock()) {
            lock.lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);
        lock.try_lock();
        if (!lock.owns_lock())
        return lock.owns_lock();
    CCriticalBlock(CCriticalSection& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : lock(mutexIn, std::defer_lock)
    CCriticalBlock(CCriticalSection* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        lock = std::unique_lock<CCriticalSection>(*pmutexIn, std::defer_lock);
    ~CCriticalBlock() UNLOCK_FUNCTION()
        if (lock.owns_lock())
        return lock.owns_lock();
#define LOCK(cs) CCriticalBlock PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__), criticalblock2(cs2, #cs2, __FILE__, __LINE__)
#define TRY_LOCK(cs, name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)

identifier:Template,mixin,that,adds,Wthread,safety,locking,annotations,to,a,subset,of,the,mutex,API,ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,class,CCriticalSection,public,AnnotatedMixin,public,CCriticalSection,DeleteLock,this,AnnotatedMixin,CWaitableCriticalSection,CConditionVariable,WaitableLock,class,SCOPED_LOCKABLE,CCriticalBlock,CCriticalSection,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,lock,EnterCritical,pszName,pszFile,nLine,lock,mutex,lock,try_lock,lock,owns_lock,lock,owns_lock,CCriticalBlock,CCriticalSection,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,lock,mutexIn,CCriticalBlock,CCriticalSection,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,lock,CCriticalSection,pmutexIn,CCriticalBlock,UNLOCK_FUNCTION,lock,owns_lock,lock,owns_lock,define,LOCK,cs,CCriticalBlock,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,CCriticalBlock,criticalblock1,cs1,cs1,__FILE__,__LINE__,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,CCriticalBlock,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (auto i : range) {
        for (bool end_fails : {true, false}) {

identifier:i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure& e) {
    } catch (const std::ios_base::failure& e) {
    } catch (std::logic_error& e) {
    for (CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error& e) {
    for (CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:e,e,e,CAmount,base_value,ABSENT,PRUNED,VALUE1,e,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (uint256& h : hashes_insert_copy)
    for (uint256& h : hashes)
            for (auto h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (bool obfuscate : {false, true}) {
    for (int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure& e) {
    for (int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,e,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (auto chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception& e) {
    } catch (const std::exception& e) {

identifier:e,e,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (std::string word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (char opt : "abcdef")
    for (bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
        std::unique_lock<std::mutex> lock(mut);
    std::unique_lock<std::mutex> lock(mut);

identifier:lock,mut,lock,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
    std::mutex mut;

identifier:mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (int64_t nOffset : vSorted)
            for (int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
        for (const txiter &phash : setMemPoolParents) {
        for (const txiter &childiter : setChildren) {
    for (const txiter& it : stage) {

identifier:txiter,phash,setMemPoolParents,txiter,childiter,setChildren,txiter,it,stage,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
static std::vector<std::pair<std::string, std::string>> GetConfigOptions(std::istream& stream)
    std::vector<std::pair<std::string, std::string>> options;
    return options;

    for (const std::pair<std::string, std::string>& option : GetConfigOptions(stream)) {

identifier:GetConfigOptions,stream,options,options,option,GetConfigOptions,stream,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (auto c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
CWaitableCriticalSection g_best_block_mutex;
CConditionVariable g_best_block_cv;
            for (int height : prevheights) {
        WaitableLock lock(g_best_block_mutex);
    for (BlockMap::value_type& entry : mapBlockIndex) {
    for (auto& entry : mapBlockIndex) {

identifier:CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,height,prevheights,WaitableLock,lock,g_best_block_mutex,BlockMap::value_type,entry,mapBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
extern CWaitableCriticalSection g_best_block_mutex;
extern CConditionVariable g_best_block_cv;

identifier:CWaitableCriticalSection,g_best_block_mutex,CConditionVariable,g_best_block_cv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An ununsed temporary BerkeleyEnvironment object may be created inside the
            for (auto& env : g_dbenvs) {

identifier:env,g_dbenvs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (unsigned char c : str) {

identifier:c,str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    std::string old_label = pwallet->mapAddressBook[dest].name;
    for (COutPoint &outpt : vOutpts) {

identifier:old_label,pwallet,mapAddressBook,dest,name,COutPoint,outpt,vOutpts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
    for (auto& input : tx.vin) {
    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
    for (auto& coin : availableCoins) {
    for (const auto& output : lockedCoins) {
        for (int64_t nIndex : setInternalKeyPool) {
        for (int64_t nIndex : setExternalKeyPool) {
        for (int64_t nIndex : set_pre_split_keypool) {
            for (CTxIn txin : pcoin->tx->vin)
               for (CTxOut txout : pcoin->tx->vout)
        for (CTxDestination address : _grouping)
        for (CTxDestination element : *merged)
    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)

identifier:input,tx,vin,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,coin,availableCoins,output,lockedCoins,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
    for (uint256 hash : wss.vWalletUpgrade)
    for (uint256 hash : vTxHash) {
    for (uint256& hash : vTxHash) {

identifier:uint256,hash,wss,vWalletUpgrade,uint256,hash,vTxHash,uint256,hash,vTxHash,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:faea5bfc5a975874acf763082852ed532ed81a95
commit B:e7a72455fa4d5c5b1a37ceae1ec557354b3009c2
++@DIFF ENTRY SEPERATOR@++
changed file:src/bech32.cpp
changed code snippet:
    for (const auto v_i : v) {
    for (const auto c : combined) {

identifier:v_i,v,c,combined,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-cli.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Connect to JSON-RPC on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::OPTIONS);

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::OPTIONS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/bitcoin-tx.cpp
changed code snippet:
        for (const CPubKey& pubkey : pubkeys) {

identifier:CPubKey,pubkey,pubkeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/chainparams.cpp
changed code snippet:

#include <chainparamsseeds.h>

identifier:include,chainparamsseeds,h,
++@DIFF ENTRY SEPERATOR@++
changed file:src/cuckoocache.h
changed code snippet:
        for (const uint32_t loc : locs)
            for (const uint32_t loc : locs) {
        for (const uint32_t loc : locs)

identifier:uint32_t,loc,locs,uint32_t,loc,locs,uint32_t,loc,locs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/dbwrapper.cpp
changed code snippet:
    // closed after being mmap'ed).

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/httpserver.cpp
changed code snippet:
    Mutex cs;
        LOCK(cs);
                WAIT_LOCK(cs, lock);
        LOCK(cs);

identifier:Mutex,cs,LOCK,cs,WAIT_LOCK,cs,lock,LOCK,cs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    const auto regtestBaseParams = CreateBaseChainParams(CBaseChainParams::REGTEST);
    const auto regtestChainParams = CreateChainParams(CBaseChainParams::REGTEST);
    gArgs.AddArg("-debuglogfile=<file>", strprintf("Specify location of debug log file. Relative paths will be prefixed by a net-specific datadir location. (-nodebuglogfile to disable; default: %s)", DEFAULT_DEBUGLOGFILE), false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks. When in pruning mode or if blocks on disk might be corrupted, use full -reindex instead.", false, OptionsCategory::OPTIONS);
    gArgs.AddArg("-connect=<ip>", "Connect only to the specified node; -noconnect disables automatic connections (the rules for this peer are the same as for -addnode). This option can be specified multiple times to connect to multiple nodes.", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-onion=<ip:port>", "Use separate SOCKS5 proxy to reach peers via Tor hidden services, set -noonion to disable (default: -proxy)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-port=<port>", strprintf("Listen for connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort(), regtestChainParams->GetDefaultPort()), false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-proxy=<ip:port>", "Connect through SOCKS5 proxy, set -noproxy to disable (default: disabled)", false, OptionsCategory::CONNECTION);
    gArgs.AddArg("-checkblockindex", strprintf("Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-checkmempool=<n>", strprintf("Run checks every <n> transactions (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), true, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-debug=<category>", "Output debugging information (default: -nodebug, supplying <category> is optional). "
    gArgs.AddArg("-printtoconsole", "Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)", false, OptionsCategory::DEBUG_TEST);
    gArgs.AddArg("-rpcport=<port>", strprintf("Listen for JSON-RPC connections on <port> (default: %u, testnet: %u, regtest: %u)", defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort(), regtestBaseParams->RPCPort()), false, OptionsCategory::RPC);
static Mutex g_genesis_wait_mutex;
static std::condition_variable g_genesis_wait_cv;
            LOCK(g_genesis_wait_mutex);
        g_genesis_wait_cv.notify_all();
        WAIT_LOCK(g_genesis_wait_mutex, lock);
            g_genesis_wait_cv.wait_for(lock, std::chrono::milliseconds(500));

identifier:regtestBaseParams,CreateBaseChainParams,CBaseChainParams::REGTEST,regtestChainParams,CreateChainParams,CBaseChainParams::REGTEST,gArgs,AddArg,strprintf,DEFAULT_DEBUGLOGFILE,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::OPTIONS,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,GetDefaultPort,testnetChainParams,GetDefaultPort,regtestChainParams,GetDefaultPort,OptionsCategory::CONNECTION,gArgs,AddArg,OptionsCategory::CONNECTION,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultChainParams,DefaultConsistencyChecks,regtestChainParams,DefaultConsistencyChecks,OptionsCategory::DEBUG_TEST,gArgs,AddArg,gArgs,AddArg,OptionsCategory::DEBUG_TEST,gArgs,AddArg,strprintf,defaultBaseParams,RPCPort,testnetBaseParams,RPCPort,regtestBaseParams,RPCPort,OptionsCategory::RPC,Mutex,g_genesis_wait_mutex,g_genesis_wait_cv,LOCK,g_genesis_wait_mutex,g_genesis_wait_cv,notify_all,WAIT_LOCK,g_genesis_wait_mutex,lock,g_genesis_wait_cv,wait_for,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.cpp
changed code snippet:
    for (const CNode* pnode : vNodes) {
                clientInterface->NotifyNumConnectionsChanged(vNodesSize);
        for (const CNode* pnode : vNodes) {
        for (const CNode* pnode : vNodes) {
            for (const CNode* pnode : vNodes) {
        WAIT_LOCK(mutexMsgProc, lock);
        LOCK(mutexMsgProc);

identifier:CNode,pnode,vNodes,clientInterface,NotifyNumConnectionsChanged,vNodesSize,CNode,pnode,vNodes,CNode,pnode,vNodes,CNode,pnode,vNodes,WAIT_LOCK,mutexMsgProc,lock,LOCK,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net.h
changed code snippet:
    Mutex mutexMsgProc;

identifier:Mutex,mutexMsgProc,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.cpp
changed code snippet:
        for (const uint256& orphanHash : vOrphanErase) {
            for (const uint256& hash : vEraseQueue)

identifier:uint256,orphanHash,vOrphanErase,uint256,hash,vEraseQueue,
++@DIFF ENTRY SEPERATOR@++
changed file:src/net_processing.h
changed code snippet:
static constexpr bool DEFAULT_ENABLE_BIP61 = true;

identifier:constexpr,DEFAULT_ENABLE_BIP61,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoin.cpp
changed code snippet:
    for (const WalletModel* walletModel : m_wallet_models) {

identifier:WalletModel,walletModel,m_wallet_models,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/bitcoingui.cpp
changed code snippet:
#ifndef Q_OS_MAC
    // Note: On Mac, the dock icon's menu already has show / hide action.
#endif
    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:ifndef,Q_OS_MAC,endif,BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/peertablemodel.cpp
changed code snippet:
            for (const auto& node_stats : nodes_stats)

identifier:node_stats,nodes_stats,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/sendcoinsdialog.cpp
changed code snippet:
    for (const BitcoinUnits::Unit u : BitcoinUnits::availableUnits())

identifier:BitcoinUnits::Unit,u,BitcoinUnits::availableUnits,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/splashscreen.cpp
changed code snippet:
    for (const auto& handler : m_connected_wallet_handlers) {

identifier:handler,m_connected_wallet_handlers,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/test/util.h
changed code snippet:
 * @param msec - Number of milliseconds to pause before triggering the callback.

identifier:param,msec,Number,of,milliseconds,to,pause,before,triggering,the,callback,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/trafficgraphwidget.cpp
changed code snippet:
    for (const float f : vSamplesIn) {
    for (const float f : vSamplesOut) {

identifier:f,vSamplesIn,f,vSamplesOut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactiondesc.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/qt/transactionrecord.cpp
changed code snippet:
        for (const isminetype mine : wtx.txin_is_mine)
        for (const isminetype mine : wtx.txout_is_mine)

identifier:isminetype,mine,wtx,txin_is_mine,isminetype,mine,wtx,txout_is_mine,
++@DIFF ENTRY SEPERATOR@++
changed file:src/random.cpp
changed code snippet:
#include <sync.h>     // for WAIT_LOCK
static Mutex cs_rng_state;
        WAIT_LOCK(cs_rng_state, lock);
        WAIT_LOCK(cs_rng_state, lock);

identifier:include,sync,h,Mutex,cs_rng_state,WAIT_LOCK,cs_rng_state,lock,WAIT_LOCK,cs_rng_state,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rest.cpp
changed code snippet:
        } catch (const std::ios_base::failure&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.cpp
changed code snippet:
static Mutex cs_blockchange;
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
        WAIT_LOCK(cs_blockchange, lock);
    for (CTxMemPool::txiter childiter : setChildren) {
            "For more information on output descriptors, see the documentation in the doc/descriptors.md file.\n"

identifier:Mutex,cs_blockchange,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,WAIT_LOCK,cs_blockchange,lock,CTxMemPool::txiter,childiter,setChildren,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/blockchain.h
changed code snippet:
 * Get the difficulty of the net wrt to the given block index.

identifier:Get,the,difficulty,of,the,net,wrt,to,the,given,block,index,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/mining.cpp
changed code snippet:
            WAIT_LOCK(g_best_block_mutex, lock);
    for (const FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {

identifier:WAIT_LOCK,g_best_block_mutex,lock,FeeEstimateHorizon,horizon,FeeEstimateHorizon::SHORT_HALFLIFE,FeeEstimateHorizon::MED_HALFLIFE,FeeEstimateHorizon::LONG_HALFLIFE,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/misc.cpp
changed code snippet:
        std::string currentAddress = EncodeDestination(dest);
        ret.pushKV("address", currentAddress);
        CScript scriptPubKey = GetScriptForDestination(dest);
        ret.pushKV("scriptPubKey", HexStr(scriptPubKey.begin(), scriptPubKey.end()));
        UniValue detail = DescribeAddress(dest);
        ret.pushKVs(detail);
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf("Invalid public key: %s\n.", keys[i].get_str()));
    { "util",               "validateaddress",        &validateaddress,        {"address"} },

identifier:currentAddress,EncodeDestination,dest,ret,pushKV,currentAddress,CScript,scriptPubKey,GetScriptForDestination,dest,ret,pushKV,HexStr,scriptPubKey,begin,scriptPubKey,end,UniValue,detail,DescribeAddress,dest,ret,pushKVs,detail,throw,JSONRPCError,RPC_INVALID_ADDRESS_OR_KEY,strprintf,keys,i,get_str,validateaddress,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/net.cpp
changed code snippet:
            for (const int height : statestats.vHeightInFlight) {

identifier:height,statestats,vHeightInFlight,
++@DIFF ENTRY SEPERATOR@++
changed file:src/rpc/rawtransaction.cpp
changed code snippet:
            // if redeemScript and private keys were given, add redeemScript to the keystore so it can be signed
    // This method should be removed entirely in V0.19, along with the entries in the
    // CRPCCommand table and rpc/client.cpp.
    throw JSONRPCError(RPC_METHOD_DEPRECATED, "signrawtransaction was removed in v0.18.\n"
        "Clients should transition to using signrawtransactionwithkey and signrawtransactionwithwallet");
            "\nAlso see createrawtransaction and signrawtransactionwithkey calls.\n"
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
            + HelpExampleCli("signrawtransactionwithwallet", "\"myhex\"") +
                            "                              will be tried. If false, only non-witness deserialization will be tried. Only has an effect if\n"
    { "hidden",             "signrawtransaction",           &signrawtransaction,        {"hexstring","prevtxs","privkeys","sighashtype"} },

identifier:throw,JSONRPCError,RPC_METHOD_DEPRECATED,HelpExampleCli,HelpExampleCli,signrawtransaction,
++@DIFF ENTRY SEPERATOR@++
changed file:src/scheduler.h
changed code snippet:
     * Practically, this means that callbacks can behave as if they are executed

identifier:Practically,this,means,that,callbacks,can,behave,as,they,are,executed,
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.cpp
changed code snippet:
/** Parse a constant. If successful, sp is updated to skip the constant and return true. */
/** Parse a function call. If successful, sp is updated to be the function's argument(s). */

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/script/descriptor.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/streams.h
changed code snippet:
     * in the nbits least significant bits of a 64-bit uint.

identifier:in,the,nbits,least,significant,bits,of,a,bit,uint,
++@DIFF ENTRY SEPERATOR@++
changed file:src/support/lockedpool.cpp
changed code snippet:
    auto allocated = chunks_used.emplace(size_ptr_it->second + size_remaining, size).first;
    return reinterpret_cast<void*>(allocated->first);

identifier:allocated,chunks_used,emplace,size_ptr_it,second,size_remaining,size,first,reinterpret_cast,allocated,first,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.cpp
changed code snippet:
    if (g_debug_lockorder_abort) {
        fprintf(stderr, "Assertion failed: detected inconsistent lock order at %s:%i, details in debug log.\n", __FILE__, __LINE__);
        abort();
    }
    throw std::logic_error("potential deadlock detected");
bool g_debug_lockorder_abort = true;


identifier:g_debug_lockorder_abort,fprintf,stderr,__FILE__,__LINE__,abort,throw,g_debug_lockorder_abort,
++@DIFF ENTRY SEPERATOR@++
changed file:src/sync.h
changed code snippet:
#ifdef DEBUG_LOCKORDER
void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);
void LeaveCritical();
std::string LocksHeld();
void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs);
void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);
void DeleteLock(void* cs);

 * Call abort() if a potential lock order deadlock bug is detected, instead of
 * just logging information and throwing a logic_error. Defaults to true, and
 * set to false in DEBUG_LOCKORDER unit tests.
 */
extern bool g_debug_lockorder_abort;
#else
void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}
void static inline LeaveCritical() {}
void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}
void static inline AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}
void static inline DeleteLock(void* cs) {}
#endif
#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)
#define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)

/**
 * Template mixin that adds -Wthread-safety locking annotations and lock order
 * checking to a subset of the mutex API.
    ~AnnotatedMixin() {
        DeleteLock((void*)this);
    }


    using UniqueLock = std::unique_lock<PARENT>;
typedef AnnotatedMixin<std::recursive_mutex> CCriticalSection;
typedef AnnotatedMixin<std::mutex> Mutex;
/** Wrapper around std::unique_lock style lock for Mutex. */
template <typename Mutex, typename Base = typename Mutex::UniqueLock>
class SCOPED_LOCKABLE UniqueLock : public Base
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()));
        if (!Base::try_lock()) {
            Base::lock();
        EnterCritical(pszName, pszFile, nLine, (void*)(Base::mutex()), true);
        Base::try_lock();
        if (!Base::owns_lock())
        return Base::owns_lock();
    UniqueLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(mutexIn) : Base(mutexIn, std::defer_lock)
    UniqueLock(Mutex* pmutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) EXCLUSIVE_LOCK_FUNCTION(pmutexIn)
        *static_cast<Base*>(this) = Base(*pmutexIn, std::defer_lock);
    ~UniqueLock() UNLOCK_FUNCTION()
        if (Base::owns_lock())
        return Base::owns_lock();
template<typename MutexArg>
using DebugLock = UniqueLock<typename std::remove_reference<typename std::remove_pointer<MutexArg>::type>::type>;

#define LOCK(cs) DebugLock<decltype(cs)> PASTE2(criticalblock, __COUNTER__)(cs, #cs, __FILE__, __LINE__)
#define LOCK2(cs1, cs2)                                               \
    DebugLock<decltype(cs1)> criticalblock1(cs1, #cs1, __FILE__, __LINE__); \
    DebugLock<decltype(cs2)> criticalblock2(cs2, #cs2, __FILE__, __LINE__);
#define TRY_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__, true)
#define WAIT_LOCK(cs, name) DebugLock<decltype(cs)> name(cs, #cs, __FILE__, __LINE__)

identifier:ifdef,DEBUG_LOCKORDER,EnterCritical,pszName,pszFile,nLine,cs,fTry,LeaveCritical,LocksHeld,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,DeleteLock,cs,Call,abort,a,potential,lock,order,deadlock,bug,is,detected,instead,of,just,logging,information,and,throwing,a,logic_error,Defaults,to,and,set,to,in,DEBUG_LOCKORDER,unit,tests,g_debug_lockorder_abort,inline,EnterCritical,pszName,pszFile,nLine,cs,fTry,inline,LeaveCritical,inline,AssertLockHeldInternal,pszName,pszFile,nLine,cs,ASSERT_EXCLUSIVE_LOCK,cs,inline,AssertLockNotHeldInternal,pszName,pszFile,nLine,cs,inline,DeleteLock,cs,endif,define,AssertLockHeld,cs,AssertLockHeldInternal,cs,__FILE__,__LINE__,cs,define,AssertLockNotHeld,cs,AssertLockNotHeldInternal,cs,__FILE__,__LINE__,cs,template,typename,Mutex,typename,Base,typename,Mutex::UniqueLock,class,SCOPED_LOCKABLE,UniqueLock,public,Base,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::lock,EnterCritical,pszName,pszFile,nLine,Base::mutex,Base::try_lock,Base::owns_lock,Base::owns_lock,UniqueLock,Mutex,mutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,mutexIn,Base,mutexIn,UniqueLock,Mutex,pmutexIn,pszName,pszFile,nLine,fTry,EXCLUSIVE_LOCK_FUNCTION,pmutexIn,static_cast,Base,this,Base,pmutexIn,UniqueLock,UNLOCK_FUNCTION,Base::owns_lock,Base::owns_lock,template,typename,MutexArg,using,DebugLock,UniqueLock,typename,typename,MutexArg,type,type,define,LOCK,cs,DebugLock,decltype,cs,PASTE2,criticalblock,__COUNTER__,cs,cs,__FILE__,__LINE__,define,LOCK2,cs1,cs2,DebugLock,decltype,cs1,criticalblock1,cs1,cs1,__FILE__,__LINE__,DebugLock,decltype,cs2,criticalblock2,cs2,cs2,__FILE__,__LINE__,define,TRY_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,define,WAIT_LOCK,cs,name,DebugLock,decltype,cs,name,cs,cs,__FILE__,__LINE__,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/checkqueue_tests.cpp
changed code snippet:
    for (const size_t i : range) {
        for (const bool end_fails : {true, false}) {

identifier:size_t,i,range,end_fails,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/coins_tests.cpp
changed code snippet:
    } catch (const std::ios_base::failure&) {
    } catch (const std::ios_base::failure&) {
    } catch (std::logic_error&) {
    for (const CAmount base_value : {ABSENT, PRUNED, VALUE1})
    } catch (std::logic_error&) {
    for (const CAmount parent_value : {ABSENT, PRUNED, VALUE1})
        for (const CAmount child_value : {ABSENT, PRUNED, VALUE2})
            for (const char parent_flags : parent_value == ABSENT ? ABSENT_FLAGS : FLAGS)
                for (const char child_flags : child_value == ABSENT ? ABSENT_FLAGS : CLEAN_FLAGS)

identifier:CAmount,base_value,ABSENT,PRUNED,VALUE1,CAmount,parent_value,ABSENT,PRUNED,VALUE1,CAmount,child_value,ABSENT,PRUNED,VALUE2,parent_flags,parent_value,ABSENT,ABSENT_FLAGS,FLAGS,child_flags,child_value,ABSENT,ABSENT_FLAGS,CLEAN_FLAGS,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/cuckoocache_tests.cpp
changed code snippet:
    for (const uint256& h : hashes_insert_copy)
    for (const uint256& h : hashes)
            for (const auto& h : inserts)

identifier:uint256,h,hashes_insert_copy,uint256,h,hashes,h,inserts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/dbwrapper_tests.cpp
changed code snippet:
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const bool obfuscate : {false, true}) {
    for (const int seek_start : {0x00, 0x80}) {
                } catch (const std::ios_base::failure&) {
    for (const int seek_start : {0, 5}) {

identifier:obfuscate,obfuscate,obfuscate,seek_start,0x00,0x80,seek_start,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.cpp
changed code snippet:
#include <test/gen/crypto_gen.h>

#include <key.h>

#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Predicate.h>
#include <rapidcheck/gen/Container.h>

/** Generates 1 to 20 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys()
{
    return rc::gen::suchThat(rc::gen::arbitrary<std::vector<CKey>>(), [](const std::vector<CKey>& keys) {
        return keys.size() >= 1 && keys.size() <= 15;
    });
};

identifier:include,test,gen,crypto_gen,h,include,key,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Predicate,h,include,rapidcheck,gen,Container,h,rc::Gen,CKey,MultisigKeys,rc::gen::suchThat,rc::gen::arbitrary,CKey,CKey,keys,keys,size,keys,size,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/gen/crypto_gen.h
changed code snippet:
#ifndef BITCOIN_TEST_GEN_CRYPTO_GEN_H
#define BITCOIN_TEST_GEN_CRYPTO_GEN_H

#include <key.h>
#include <random.h>
#include <uint256.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>
#include <rapidcheck/gen/Create.h>
#include <rapidcheck/gen/Numeric.h>

/** Generates 1 to 15 keys for OP_CHECKMULTISIG */
rc::Gen<std::vector<CKey>> MultisigKeys();

namespace rc
{
/** Generator for a new CKey */
template <>
struct Arbitrary<CKey> {
    static Gen<CKey> arbitrary()
    {
        return rc::gen::map<int>([](int x) {
            CKey key;
            key.MakeNewKey(true);
            return key;
        });
    };
};

/** Generator for a CPrivKey */
template <>
struct Arbitrary<CPrivKey> {
    static Gen<CPrivKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPrivKey();
        });
    };
};

/** Generator for a new CPubKey */
template <>
struct Arbitrary<CPubKey> {
    static Gen<CPubKey> arbitrary()
    {
        return gen::map(gen::arbitrary<CKey>(), [](const CKey& key) {
            return key.GetPubKey();
        });
    };
};
/** Generates a arbitrary uint256 */
template <>
struct Arbitrary<uint256> {
    static Gen<uint256> arbitrary()
    {
        return rc::gen::just(GetRandHash());
    };
};
} //namespace rc
#endif

identifier:ifndef,BITCOIN_TEST_GEN_CRYPTO_GEN_H,define,BITCOIN_TEST_GEN_CRYPTO_GEN_H,include,key,h,include,random,h,include,uint256,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,rapidcheck,gen,Create,h,include,rapidcheck,gen,Numeric,h,rc::Gen,CKey,MultisigKeys,namespace,rc,template,Arbitrary,CKey,Gen,CKey,arbitrary,rc::gen::map,x,CKey,key,key,MakeNewKey,key,template,Arbitrary,CPrivKey,Gen,CPrivKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPrivKey,template,Arbitrary,CPubKey,Gen,CPubKey,arbitrary,gen::map,gen::arbitrary,CKey,CKey,key,key,GetPubKey,template,Arbitrary,uint256,Gen,uint256,arbitrary,rc::gen::just,GetRandHash,endif,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/getarg_tests.cpp
changed code snippet:
    for (const std::string& s : vecArg)

identifier:s,vecArg,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_io_tests.cpp
changed code snippet:
        for (const auto& chain : { CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::REGTEST }) {

identifier:chain,CBaseChainParams::MAIN,CBaseChainParams::TESTNET,CBaseChainParams::REGTEST,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/key_properties.cpp
changed code snippet:
#include <key.h>

#include <base58.h>
#include <script/script.h>
#include <uint256.h>
#include <util.h>
#include <utilstrencodings.h>
#include <test/test_bitcoin.h>
#include <string>
#include <vector>

#include <boost/test/unit_test.hpp>
#include <rapidcheck/boost_test.h>
#include <rapidcheck/gen/Arbitrary.h>
#include <rapidcheck/Gen.h>

#include <test/gen/crypto_gen.h>

BOOST_FIXTURE_TEST_SUITE(key_properties, BasicTestingSetup)

/** Check CKey uniqueness */
RC_BOOST_PROP(key_uniqueness, (const CKey& key1, const CKey& key2))
{
    RC_ASSERT(!(key1 == key2));
}

/** Verify that a private key generates the correct public key */
RC_BOOST_PROP(key_generates_correct_pubkey, (const CKey& key))
{
    CPubKey pubKey = key.GetPubKey();
    RC_ASSERT(key.VerifyPubKey(pubKey));
}

/** Create a CKey using the 'Set' function must give us the same key */
RC_BOOST_PROP(key_set_symmetry, (const CKey& key))
{
    CKey key1;
    key1.Set(key.begin(), key.end(), key.IsCompressed());
    RC_ASSERT(key1 == key);
}

/** Create a CKey, sign a piece of data, then verify it with the public key */
RC_BOOST_PROP(key_sign_symmetry, (const CKey& key, const uint256& hash))
{
    std::vector<unsigned char> vchSig;
    key.Sign(hash, vchSig, 0);
    const CPubKey& pubKey = key.GetPubKey();
    RC_ASSERT(pubKey.Verify(hash, vchSig));
}
BOOST_AUTO_TEST_SUITE_END()

identifier:include,key,h,include,base58,h,include,script,script,h,include,uint256,h,include,util,h,include,utilstrencodings,h,include,test,test_bitcoin,h,include,include,include,boost,test,unit_test,hpp,include,rapidcheck,boost_test,h,include,rapidcheck,gen,Arbitrary,h,include,rapidcheck,Gen,h,include,test,gen,crypto_gen,h,BOOST_FIXTURE_TEST_SUITE,key_properties,BasicTestingSetup,RC_BOOST_PROP,key_uniqueness,CKey,key1,CKey,key2,RC_ASSERT,key1,key2,RC_BOOST_PROP,key_generates_correct_pubkey,CKey,key,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,key,VerifyPubKey,pubKey,RC_BOOST_PROP,key_set_symmetry,CKey,key,CKey,key1,key1,Set,key,begin,key,end,key,IsCompressed,RC_ASSERT,key1,key,RC_BOOST_PROP,key_sign_symmetry,CKey,key,uint256,hash,vchSig,key,Sign,hash,vchSig,CPubKey,pubKey,key,GetPubKey,RC_ASSERT,pubKey,Verify,hash,vchSig,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/net_tests.cpp
changed code snippet:
    } catch (const std::exception&) {
    } catch (const std::exception&) {

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/skiplist_tests.cpp
changed code snippet:
    for (const unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {

identifier:timeMax,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/sync_tests.cpp
changed code snippet:

#include <sync.h>
#include <test/test_bitcoin.h>

#include <boost/test/unit_test.hpp>

namespace {
template <typename MutexType>
void TestPotentialDeadLockDetected(MutexType& mutex1, MutexType& mutex2)
{
    {
        LOCK2(mutex1, mutex2);
    }
    bool error_thrown = false;
    try {
        LOCK2(mutex2, mutex1);
    } catch (const std::logic_error& e) {
        BOOST_CHECK_EQUAL(e.what(), "potential deadlock detected");
        error_thrown = true;
    }
    #ifdef DEBUG_LOCKORDER
    BOOST_CHECK(error_thrown);
    #else
    BOOST_CHECK(!error_thrown);
    #endif
}
} // namespace

BOOST_FIXTURE_TEST_SUITE(sync_tests, BasicTestingSetup)

BOOST_AUTO_TEST_CASE(potential_deadlock_detected)
{
    #ifdef DEBUG_LOCKORDER
    bool prev = g_debug_lockorder_abort;
    g_debug_lockorder_abort = false;
    #endif

    CCriticalSection rmutex1, rmutex2;
    TestPotentialDeadLockDetected(rmutex1, rmutex2);

    Mutex mutex1, mutex2;
    TestPotentialDeadLockDetected(mutex1, mutex2);

    #ifdef DEBUG_LOCKORDER
    g_debug_lockorder_abort = prev;
    #endif
}

BOOST_AUTO_TEST_SUITE_END()

identifier:include,sync,h,include,test,test_bitcoin,h,include,boost,test,unit_test,hpp,namespace,template,typename,MutexType,TestPotentialDeadLockDetected,MutexType,mutex1,MutexType,mutex2,LOCK2,mutex1,mutex2,error_thrown,LOCK2,mutex2,mutex1,e,BOOST_CHECK_EQUAL,e,what,error_thrown,ifdef,DEBUG_LOCKORDER,BOOST_CHECK,error_thrown,BOOST_CHECK,error_thrown,endif,BOOST_FIXTURE_TEST_SUITE,sync_tests,BasicTestingSetup,BOOST_AUTO_TEST_CASE,potential_deadlock_detected,ifdef,DEBUG_LOCKORDER,prev,g_debug_lockorder_abort,g_debug_lockorder_abort,endif,CCriticalSection,rmutex1,rmutex2,TestPotentialDeadLockDetected,rmutex1,rmutex2,Mutex,mutex1,mutex2,TestPotentialDeadLockDetected,mutex1,mutex2,ifdef,DEBUG_LOCKORDER,g_debug_lockorder_abort,prev,endif,BOOST_AUTO_TEST_SUITE_END,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/test_bitcoin.cpp
changed code snippet:
    for (const CNode* node : g_connman->vNodes) {

identifier:CNode,node,g_connman,vNodes,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/transaction_tests.cpp
changed code snippet:
    for (const std::string& word : words)

identifier:word,words,
++@DIFF ENTRY SEPERATOR@++
changed file:src/test/util_tests.cpp
changed code snippet:
    for (const char opt : "abcdef")
    for (const bool def : {false, true}) {

identifier:opt,def,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.cpp
changed code snippet:
#include <sync.h>

        LOCK(mut);
    WAIT_LOCK(mut, lock);

identifier:include,sync,h,LOCK,mut,WAIT_LOCK,mut,lock,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadinterrupt.h
changed code snippet:
#include <sync.h>

    Mutex mut;

identifier:include,sync,h,Mutex,mut,
++@DIFF ENTRY SEPERATOR@++
changed file:src/threadsafety.h
changed code snippet:

identifier:
++@DIFF ENTRY SEPERATOR@++
changed file:src/timedata.cpp
changed code snippet:
                for (const int64_t nOffset : vSorted)
            for (const int64_t n : vSorted) {

identifier:int64_t,nOffset,vSorted,int64_t,n,vSorted,
++@DIFF ENTRY SEPERATOR@++
changed file:src/txmempool.cpp
changed code snippet:
        for (txiter phash : setMemPoolParents) {
        for (txiter childiter : setChildren) {
    for (txiter it : stage) {

identifier:txiter,phash,setMemPoolParents,txiter,childiter,setChildren,txiter,it,stage,
++@DIFF ENTRY SEPERATOR@++
changed file:src/util.cpp
changed code snippet:
static bool GetConfigOptions(std::istream& stream, std::string& error, std::vector<std::pair<std::string, std::string>> &options)
    int linenr = 1;
            } else if (*str.begin() == '-') {
                error = strprintf("parse error on line %i: %s, options in configuration file must be specified without leading -", linenr, str);
                return false;
            } else {
                error = strprintf("parse error on line %i: %s", linenr, str);
                if (str.size() >= 2 && str.substr(0, 2) == "no") {
                    error += strprintf(", if you intended to specify a negated option, use %s=1 instead", str);
                }
                return false;
        ++linenr;
    return true;
    std::vector<std::pair<std::string, std::string>> options;
    if (!GetConfigOptions(stream, error, options)) {
        return false;
    }
    for (const std::pair<std::string, std::string>& option : options) {

identifier:GetConfigOptions,stream,error,options,linenr,str,begin,error,strprintf,linenr,str,error,strprintf,linenr,str,str,size,str,substr,error,strprintf,str,linenr,options,GetConfigOptions,stream,error,options,option,options,
++@DIFF ENTRY SEPERATOR@++
changed file:src/utilstrencodings.cpp
changed code snippet:
    for (const char c : str.substr(starting_location)) {

identifier:c,str,substr,starting_location,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.cpp
changed code snippet:
Mutex g_best_block_mutex;
std::condition_variable g_best_block_cv;
            for (const int height : prevheights) {
        LOCK(g_best_block_mutex);
    for (const BlockMap::value_type& entry : mapBlockIndex) {
    for (const std::pair<const uint256, CBlockIndex*>& entry : mapBlockIndex) {

identifier:Mutex,g_best_block_mutex,g_best_block_cv,height,prevheights,LOCK,g_best_block_mutex,BlockMap::value_type,entry,mapBlockIndex,uint256,CBlockIndex,entry,mapBlockIndex,
++@DIFF ENTRY SEPERATOR@++
changed file:src/validation.h
changed code snippet:
extern Mutex g_best_block_mutex;
extern std::condition_variable g_best_block_cv;

identifier:Mutex,g_best_block_mutex,g_best_block_cv,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/crypter.cpp
changed code snippet:
    for (const KeyMap::value_type& mKey : mapKeys)

identifier:KeyMap::value_type,mKey,mapKeys,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/db.cpp
changed code snippet:
    // Note: An unused temporary BerkeleyEnvironment object may be created inside the
            for (const auto& env : g_dbenvs) {

identifier:env,g_dbenvs,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcdump.cpp
changed code snippet:
    for (const unsigned char c : str) {

identifier:c,str,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/rpcwallet.cpp
changed code snippet:
    for (const COutPoint& outpt : vOutpts) {

identifier:COutPoint,outpt,vOutpts,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/wallet.cpp
changed code snippet:
    for (const CTxIn& input : tx.vin) {
    for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {
    for (const std::pair<const unsigned int, CWalletTx*>& item : mapSorted)
    for (const COutput& coin : availableCoins) {
    for (const COutPoint& output : lockedCoins) {
        for (const int64_t nIndex : setInternalKeyPool) {
        for (const int64_t nIndex : setExternalKeyPool) {
        for (const int64_t nIndex : set_pre_split_keypool) {
            for (const CTxIn& txin : pcoin->tx->vin)
               for (const CTxOut& txout : pcoin->tx->vout)
        for (const CTxDestination& address : _grouping)
        for (const CTxDestination& element : *merged)
    for (const std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)

identifier:CTxIn,input,tx,vin,int64_t,CWalletTx,item,mapSorted,CWalletTx,item,mapSorted,COutput,coin,availableCoins,COutPoint,output,lockedCoins,int64_t,nIndex,setInternalKeyPool,int64_t,nIndex,setExternalKeyPool,int64_t,nIndex,set_pre_split_keypool,CTxIn,txin,pcoin,tx,vin,CTxOut,txout,pcoin,tx,vout,CTxDestination,address,_grouping,CTxDestination,element,merged,CTxDestination,uniqueGrouping,uniqueGroupings,
++@DIFF ENTRY SEPERATOR@++
changed file:src/wallet/walletdb.cpp
changed code snippet:
    for (const uint256& hash : wss.vWalletUpgrade)
    for (const uint256& hash : vTxHash) {
    for (const uint256& hash : vTxHash) {

identifier:uint256,hash,wss,vWalletUpgrade,uint256,hash,vTxHash,uint256,hash,vTxHash,
--@COMMIT SEPERATOR@--
repository:C:\Users\adn0019\WORK\bitcoin\bitcoin\.git
branch:refs/heads/master
commit A:eea87ef537b8ef38023e63c306ac163791f6eb66
commit B:3076556cd0317f7a05fd6836133dd6c051c4b53f
++@DIFF ENTRY SEPERATOR@++
changed file:src/dummywallet.cpp
changed code snippet:

#include <stdio.h>
#include <util.h>
#include <walletinitinterface.h>

class DummyWalletInit : public WalletInitInterface {
public:

    void AddWalletOptions() const override;
    bool ParameterInteraction() const override {return true;}
    void RegisterRPC(CRPCTable &) const override {}
    bool Verify() const override {return true;}
    bool Open() const override {LogPrintf("No wallet support compiled in!\n"); return true;}
    void Start(CScheduler& scheduler) const override {}
    void Flush() const override {}
    void Stop() const override {}
    void Close() const override {}
};

void DummyWalletInit::AddWalletOptions() const
{
    std::vector<std::string> opts = {"-addresstype", "-changetype", "-disablewallet", "-discardfee=<amt>", "-fallbackfee=<amt>",
        "-keypool=<n>", "-mintxfee=<amt>", "-paytxfee=<amt>", "-rescan", "-salvagewallet", "-spendzeroconfchange",  "-txconfirmtarget=<n>",
        "-upgradewallet", "-wallet=<path>", "-walletbroadcast", "-walletdir=<dir>", "-walletnotify=<cmd>", "-walletrbf", "-zapwallettxes=<mode>",
        "-dblogsize=<n>", "-flushwallet", "-privdb", "-walletrejectlongchains"};
    gArgs.AddHiddenArgs(opts);
}

const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();

identifier:include,stdio,h,include,util,h,include,walletinitinterface,h,class,DummyWalletInit,public,WalletInitInterface,public,AddWalletOptions,override,ParameterInteraction,override,RegisterRPC,CRPCTable,override,Verify,override,Open,override,LogPrintf,Start,CScheduler,scheduler,override,Flush,override,Stop,override,Close,override,DummyWalletInit::AddWalletOptions,opts,gArgs,AddHiddenArgs,opts,WalletInitInterface,g_wallet_init_interface,DummyWalletInit,
++@DIFF ENTRY SEPERATOR@++
changed file:src/init.cpp
changed code snippet:
    gArgs.AddArg("-reindex-chainstate", "Rebuild chain state from the currently indexed blocks", false, OptionsCategory::OPTIONS);

identifier:gArgs,AddArg,OptionsCategory::OPTIONS,
--@COMMIT SEPERATOR@--
